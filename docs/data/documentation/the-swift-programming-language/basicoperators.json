{"metadata":{"title":"기본 연산자"},"sections":[],"kind":"article","abstract":[{"text":"값을 할당하거나, 산술 연산을 수행하거나, 비교하는 작업을 진행한다.","type":"text"}],"hierarchy":{"paths":[["doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language"]]},"identifier":{"url":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/BasicOperators","interfaceLanguage":"swift"},"schemaVersion":{"major":0,"patch":0,"minor":3},"primaryContentSections":[{"kind":"content","content":[{"inlineContent":[{"type":"emphasis","inlineContent":[{"text":"연산자","type":"text"}]},{"text":"는 값들을 확인하거나 변경하거나 결합할 때 사용하는 특수한 기호나 구문이다. 예를 들어, 덧셈 연산자(","type":"text"},{"code":"+","type":"codeVoice"},{"type":"text","text":")는 두 숫자를 더한다. "},{"type":"codeVoice","code":"let i = 1 + 2"},{"type":"text","text":"와 같이 사용한다. 그리고 논리 AND 연산자("},{"type":"codeVoice","code":"&&"},{"text":")는 두 불리언 값을 결합한다. ","type":"text"},{"code":"if enteredDoorCode && passedRetinaScan","type":"codeVoice"},{"type":"text","text":"과 같이 활용한다."}],"type":"paragraph"},{"inlineContent":[{"text":"Swift는 C 언어와 같은 프로그래밍 언어에서 이미 익숙할 수 있는 연산자를 지원하며, 일반적인 코딩 실수를 방지하기 위해 몇 가지 기능을 개선했다. 할당 연산자(","type":"text"},{"type":"codeVoice","code":"="},{"text":")는 값을 반환하지 않는다. 이는 등호 연산자(","type":"text"},{"type":"codeVoice","code":"=="},{"type":"text","text":")를 사용해야 할 때 실수로 할당 연산자를 사용하는 것을 방지하기 위함이다. 산술 연산자("},{"code":"+","type":"codeVoice"},{"type":"text","text":", "},{"type":"codeVoice","code":"-"},{"text":", ","type":"text"},{"type":"codeVoice","code":"*"},{"text":", ","type":"text"},{"code":"\/","type":"codeVoice"},{"text":", ","type":"text"},{"code":"%","type":"codeVoice"},{"text":" 등)는 값의 오버플로를 감지하고 이를 허용하지 않는다. 이는 저장 타입의 허용 범위를 벗어나는 크거나 작은 숫자를 다룰 때 예상치 못한 결과를 피하기 위함이다. Swift의 오버플로 연산자를 사용하면 값 오버플로 동작을 선택할 수 있다. 이는 ","type":"text"},{"text":"doc:AdvancedOperators#Overflow-Operators","type":"text"},{"text":"에서 자세히 설명한다.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"text":"Swift는 또한 C 언어에는 없는 범위 연산자를 제공한다. ","type":"text"},{"type":"codeVoice","code":"a..<b"},{"text":"와 ","type":"text"},{"code":"a...b","type":"codeVoice"},{"type":"text","text":" 같은 연산자는 값의 범위를 간단히 표현하는 단축어 역할을 한다."}],"type":"paragraph"},{"inlineContent":[{"text":"이 장에서는 Swift의 일반적인 연산자들을 설명한다. ","type":"text"},{"type":"reference","identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/AdvancedOperators","isActive":true},{"type":"text","text":"에서는 Swift의 고급 연산자를 다루고, 커스텀 연산자를 정의하는 방법과 자신만의 커스텀 타입에 표준 연산자를 구현하는 방법을 설명한다."}],"type":"paragraph"},{"level":2,"type":"heading","text":"용어 정리","anchor":"%EC%9A%A9%EC%96%B4-%EC%A0%95%EB%A6%AC"},{"type":"paragraph","inlineContent":[{"text":"연산자는 단항, 이항, 삼항으로 구분한다:","type":"text"}]},{"type":"unorderedList","items":[{"content":[{"inlineContent":[{"inlineContent":[{"type":"text","text":"단항 연산자"}],"type":"strong"},{"type":"text","text":"는 하나의 피연산자를 대상으로 동작한다. 예를 들어 "},{"code":"-a","type":"codeVoice"},{"text":"가 있다.","type":"text"},{"type":"text","text":"\n"},{"type":"text","text":"단항 "},{"inlineContent":[{"type":"text","text":"접두사"}],"type":"emphasis"},{"type":"text","text":" 연산자는 피연산자 바로 앞에 위치한다(예: "},{"type":"codeVoice","code":"!b"},{"text":").","type":"text"},{"type":"text","text":"\n"},{"type":"text","text":"단항 "},{"type":"emphasis","inlineContent":[{"type":"text","text":"접미사"}]},{"text":" 연산자는 피연산자 바로 뒤에 위치한다(예: ","type":"text"},{"type":"codeVoice","code":"c!"},{"text":").","type":"text"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"inlineContent":[{"text":"이항 연산자","type":"text"}],"type":"strong"},{"type":"text","text":"는 두 개의 피연산자를 대상으로 동작한다. 예를 들어 "},{"type":"codeVoice","code":"2 + 3"},{"type":"text","text":"이 있다."},{"text":"\n","type":"text"},{"type":"text","text":"이항 연산자는 두 피연산자 사이에 위치하므로 "},{"type":"emphasis","inlineContent":[{"type":"text","text":"중위"}]},{"type":"text","text":" 연산자라고 부른다."}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"strong","inlineContent":[{"text":"삼항 연산자","type":"text"}]},{"text":"는 세 개의 피연산자를 대상으로 동작한다.","type":"text"},{"text":"\n","type":"text"},{"type":"text","text":"C 언어와 마찬가지로 Swift에는 삼항 조건 연산자("},{"code":"a ? b : c","type":"codeVoice"},{"type":"text","text":") 하나만 존재한다."}]}]}]},{"inlineContent":[{"type":"text","text":"연산자가 영향을 미치는 값을 "},{"type":"emphasis","inlineContent":[{"text":"피연산자","type":"text"}]},{"type":"text","text":"라고 한다."},{"text":"\n","type":"text"},{"text":"예를 들어 ","type":"text"},{"type":"codeVoice","code":"1 + 2"},{"type":"text","text":" 표현식에서 "},{"code":"+","type":"codeVoice"},{"text":" 기호는 중위 연산자이며, 두 피연산자는 ","type":"text"},{"code":"1","type":"codeVoice"},{"text":"과 ","type":"text"},{"type":"codeVoice","code":"2"},{"type":"text","text":"이다."}],"type":"paragraph"},{"type":"heading","level":2,"anchor":"%ED%95%A0%EB%8B%B9-%EC%97%B0%EC%82%B0%EC%9E%90","text":"할당 연산자"},{"inlineContent":[{"inlineContent":[{"type":"text","text":"할당 연산자"}],"type":"emphasis"},{"text":" (","type":"text"},{"type":"codeVoice","code":"a = b"},{"type":"text","text":")는 "},{"type":"codeVoice","code":"a"},{"text":"의 값을 ","type":"text"},{"type":"codeVoice","code":"b"},{"type":"text","text":"의 값으로 초기화하거나 업데이트한다:"}],"type":"paragraph"},{"type":"codeListing","code":["let b = 10","var a = 5","a = b","\/\/ a는 이제 10과 같다"],"syntax":"swift"},{"type":"paragraph","inlineContent":[{"type":"text","text":"할당 연산자의 오른쪽이 여러 값을 가진 튜플이라면, 그 요소들을 여러 상수나 변수로 한 번에 분해할 수 있다:"}]},{"syntax":"swift","code":["let (x, y) = (1, 2)","\/\/ x는 1과 같고, y는 2와 같다"],"type":"codeListing"},{"inlineContent":[{"type":"text","text":"C와 Objective-C의 할당 연산자와 달리, Swift의 할당 연산자는 값을 반환하지 않는다. 따라서 다음 문장은 유효하지 않다:"}],"type":"paragraph"},{"code":["if x = y {","    \/\/ 이 코드는 유효하지 않다. x = y가 값을 반환하지 않기 때문이다.","}"],"type":"codeListing","syntax":"swift"},{"type":"paragraph","inlineContent":[{"text":"이 기능은 실수로 할당 연산자(","type":"text"},{"type":"codeVoice","code":"="},{"text":")를 사용하는 것을 방지한다. 실제로는 동등 연산자(","type":"text"},{"type":"codeVoice","code":"=="},{"text":")를 사용하려는 경우에 말이다. ","type":"text"},{"code":"if x = y","type":"codeVoice"},{"type":"text","text":"를 유효하지 않게 함으로써, Swift는 코드에서 이런 종류의 오류를 피할 수 있게 도와준다."}]},{"level":2,"anchor":"%EC%82%B0%EC%88%A0-%EC%97%B0%EC%82%B0%EC%9E%90","type":"heading","text":"산술 연산자"},{"inlineContent":[{"type":"text","text":"Swift는 모든 숫자 타입에 대해 네 가지 기본 "},{"type":"emphasis","inlineContent":[{"type":"text","text":"산술 연산자"}]},{"type":"text","text":"를 지원한다:"}],"type":"paragraph"},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"덧셈 ("},{"type":"codeVoice","code":"+"},{"text":")","type":"text"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"뺄셈 ("},{"code":"-","type":"codeVoice"},{"type":"text","text":")"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"곱셈 ("},{"code":"*","type":"codeVoice"},{"text":")","type":"text"}]}]},{"content":[{"inlineContent":[{"text":"나눗셈 (","type":"text"},{"code":"\/","type":"codeVoice"},{"text":")","type":"text"}],"type":"paragraph"}]}]},{"type":"codeListing","syntax":"swift","code":["1 + 2       \/\/ 결과는 3","5 - 3       \/\/ 결과는 2","2 * 3       \/\/ 결과는 6","10.0 \/ 2.5  \/\/ 결과는 4.0"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"C와 Objective-C의 산술 연산자와 달리, Swift의 산술 연산자는 기본적으로 값이 오버플로우되는 것을 허용하지 않는다. Swift의 오버플로우 연산자(예: "},{"type":"codeVoice","code":"a &+ b"},{"text":")를 사용하면 오버플로우 동작을 선택할 수 있다. 자세한 내용은 ","type":"text"},{"type":"text","text":"doc:AdvancedOperators#Overflow-Operators"},{"text":"를 참고한다.","type":"text"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"덧셈 연산자는 "},{"type":"codeVoice","code":"String"},{"type":"text","text":" 연결에도 사용할 수 있다:"}]},{"type":"codeListing","code":["\"hello, \" + \"world\"  \/\/ 결과는 \"hello, world\""],"syntax":"swift"},{"level":3,"anchor":"%EB%82%98%EB%A8%B8%EC%A7%80-%EC%97%B0%EC%82%B0%EC%9E%90","type":"heading","text":"나머지 연산자"},{"inlineContent":[{"type":"emphasis","inlineContent":[{"type":"text","text":"나머지 연산자"}]},{"type":"text","text":"("},{"code":"a % b","type":"codeVoice"},{"type":"text","text":")는 "},{"type":"codeVoice","code":"b"},{"type":"text","text":"의 배수가 "},{"code":"a","type":"codeVoice"},{"type":"text","text":" 안에 몇 번 들어갈 수 있는지 계산하고, 남은 값을 반환한다. 이 남은 값을 "},{"type":"emphasis","inlineContent":[{"type":"text","text":"나머지"}]},{"type":"text","text":"라고 부른다."}],"type":"paragraph"},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"나머지 연산자("},{"code":"%","type":"codeVoice"},{"type":"text","text":")는 다른 언어에서 "},{"inlineContent":[{"type":"text","text":"모듈로 연산자"}],"type":"emphasis"},{"type":"text","text":"로 알려져 있다. 하지만 Swift에서는 음수에 대해 다르게 동작하기 때문에, 엄밀히 말하면 모듈로 연산이 아니라 나머지 연산이다."}]}],"style":"note","name":"참고","type":"aside"},{"inlineContent":[{"type":"text","text":"나머지 연산자가 어떻게 동작하는지 살펴보자. "},{"type":"codeVoice","code":"9 % 4"},{"text":"를 계산하려면, 먼저 ","type":"text"},{"type":"codeVoice","code":"4"},{"text":"가 ","type":"text"},{"type":"codeVoice","code":"9"},{"type":"text","text":" 안에 몇 번 들어갈 수 있는지 알아본다:"}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"identifier":"remainderInteger","type":"image"}]},{"inlineContent":[{"code":"4","type":"codeVoice"},{"text":"는 ","type":"text"},{"type":"codeVoice","code":"9"},{"text":" 안에 두 번 들어갈 수 있고, 나머지는 ","type":"text"},{"code":"1","type":"codeVoice"},{"type":"text","text":"이다 (주황색으로 표시)."}],"type":"paragraph"},{"inlineContent":[{"text":"Swift에서는 다음과 같이 작성한다:","type":"text"}],"type":"paragraph"},{"syntax":"swift","code":["9 % 4    \/\/ 결과는 1"],"type":"codeListing"},{"inlineContent":[{"type":"codeVoice","code":"a % b"},{"type":"text","text":"의 답을 구하기 위해, "},{"type":"codeVoice","code":"%"},{"type":"text","text":" 연산자는 다음 방정식을 계산하고 "},{"code":"remainder","type":"codeVoice"},{"type":"text","text":"를 결과로 반환한다:"}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"code":"a","type":"codeVoice"},{"type":"text","text":" = ("},{"code":"b","type":"codeVoice"},{"type":"text","text":" x "},{"code":"some multiplier","type":"codeVoice"},{"text":") + ","type":"text"},{"code":"remainder","type":"codeVoice"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"여기서 "},{"type":"codeVoice","code":"some multiplier"},{"text":"는 ","type":"text"},{"code":"b","type":"codeVoice"},{"type":"text","text":"의 배수 중 "},{"type":"codeVoice","code":"a"},{"text":" 안에 들어갈 수 있는 가장 큰 수이다.","type":"text"}]},{"type":"paragraph","inlineContent":[{"type":"codeVoice","code":"9"},{"text":"와 ","type":"text"},{"code":"4","type":"codeVoice"},{"type":"text","text":"를 이 방정식에 대입하면 다음과 같다:"}]},{"type":"paragraph","inlineContent":[{"type":"codeVoice","code":"9"},{"text":" = (","type":"text"},{"type":"codeVoice","code":"4"},{"text":" x ","type":"text"},{"type":"codeVoice","code":"2"},{"text":") + ","type":"text"},{"type":"codeVoice","code":"1"}]},{"type":"paragraph","inlineContent":[{"type":"codeVoice","code":"a"},{"type":"text","text":"가 음수일 때도 같은 방법을 적용한다:"}]},{"syntax":"swift","code":["-9 % 4   \/\/ 결과는 -1"],"type":"codeListing"},{"inlineContent":[{"code":"-9","type":"codeVoice"},{"type":"text","text":"와 "},{"type":"codeVoice","code":"4"},{"type":"text","text":"를 방정식에 대입하면:"}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"code":"-9","type":"codeVoice"},{"type":"text","text":" = ("},{"code":"4","type":"codeVoice"},{"type":"text","text":" x "},{"type":"codeVoice","code":"-2"},{"text":") + ","type":"text"},{"type":"codeVoice","code":"-1"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"나머지 값으로 "},{"type":"codeVoice","code":"-1"},{"text":"이 나온다.","type":"text"}]},{"type":"paragraph","inlineContent":[{"type":"codeVoice","code":"b"},{"text":"가 음수인 경우, ","type":"text"},{"type":"codeVoice","code":"b"},{"type":"text","text":"의 부호는 무시된다. 즉, "},{"type":"codeVoice","code":"a % b"},{"text":"와 ","type":"text"},{"type":"codeVoice","code":"a % -b"},{"text":"는 항상 같은 결과를 반환한다.","type":"text"}]},{"level":3,"text":"단항 마이너스 연산자","anchor":"%EB%8B%A8%ED%95%AD-%EB%A7%88%EC%9D%B4%EB%84%88%EC%8A%A4-%EC%97%B0%EC%82%B0%EC%9E%90","type":"heading"},{"inlineContent":[{"type":"text","text":"숫자 값의 부호를 전환하려면 "},{"type":"codeVoice","code":"-"},{"type":"text","text":"를 접두사로 사용한다. 이를 "},{"type":"emphasis","inlineContent":[{"type":"text","text":"단항 마이너스 연산자"}]},{"type":"text","text":"라고 부른다."}],"type":"paragraph"},{"type":"codeListing","code":["let three = 3","let minusThree = -three       \/\/ minusThree는 -3과 같다","let plusThree = -minusThree   \/\/ plusThree는 3과 같다. 즉, \"마이너스 마이너스 3\"이다"],"syntax":"swift"},{"type":"paragraph","inlineContent":[{"text":"단항 마이너스 연산자(","type":"text"},{"code":"-","type":"codeVoice"},{"type":"text","text":")는 연산 대상 값 바로 앞에 공백 없이 붙여 사용한다."}]},{"type":"heading","anchor":"%EB%8B%A8%ED%95%AD-%ED%94%8C%EB%9F%AC%EC%8A%A4-%EC%97%B0%EC%82%B0%EC%9E%90","level":3,"text":"단항 플러스 연산자"},{"type":"paragraph","inlineContent":[{"type":"text","text":"단항 플러스 연산자("},{"type":"codeVoice","code":"+"},{"text":")는 단순히 피연산자의 값을 그대로 반환한다. 값에 아무런 변화를 주지 않는다:","type":"text"}]},{"type":"codeListing","syntax":"swift","code":["let minusSix = -6","let alsoMinusSix = +minusSix  \/\/ alsoMinusSix는 -6과 같다"]},{"inlineContent":[{"text":"단항 플러스 연산자는 실제로 아무런 동작을 하지 않지만, 음수에 단항 마이너스 연산자를 사용할 때 양수에 대칭성을 제공하기 위해 활용할 수 있다.","type":"text"}],"type":"paragraph"},{"type":"heading","anchor":"%EB%B3%B5%ED%95%A9-%ED%95%A0%EB%8B%B9-%EC%97%B0%EC%82%B0%EC%9E%90","level":2,"text":"복합 할당 연산자"},{"type":"paragraph","inlineContent":[{"type":"text","text":"C 언어와 마찬가지로, Swift는 할당("},{"code":"=","type":"codeVoice"},{"type":"text","text":")을 다른 연산과 결합한 "},{"type":"emphasis","inlineContent":[{"text":"복합 할당 연산자","type":"text"}]},{"text":"를 제공한다. 예를 들어 ","type":"text"},{"inlineContent":[{"type":"text","text":"덧셈 할당 연산자"}],"type":"emphasis"},{"text":"(","type":"text"},{"code":"+=","type":"codeVoice"},{"type":"text","text":")는 다음과 같이 사용한다:"}]},{"type":"codeListing","syntax":"swift","code":["var a = 1","a += 2","\/\/ a는 이제 3과 같다"]},{"type":"paragraph","inlineContent":[{"code":"a += 2","type":"codeVoice"},{"type":"text","text":"라는 표현은 "},{"code":"a = a + 2","type":"codeVoice"},{"text":"의 축약형이다. 이 연산자는 덧셈과 할당을 동시에 수행한다.","type":"text"}]},{"content":[{"inlineContent":[{"text":"복합 할당 연산자는 값을 반환하지 않는다. 예를 들어, ","type":"text"},{"type":"codeVoice","code":"let b = a += 2"},{"text":"와 같이 작성할 수 없다.","type":"text"}],"type":"paragraph"}],"name":"주의","type":"aside","style":"note"},{"inlineContent":[{"text":"Swift 표준 라이브러리에서 제공하는 연산자에 대한 자세한 정보는 ","type":"text"},{"identifier":"https:\/\/developer.apple.com\/documentation\/swift\/operator_declarations","type":"reference","isActive":true},{"type":"text","text":"를 참고한다."}],"type":"paragraph"},{"level":2,"anchor":"%EB%B9%84%EA%B5%90-%EC%97%B0%EC%82%B0%EC%9E%90","type":"heading","text":"비교 연산자"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Swift는 다음과 같은 비교 연산자를 지원한다:"}]},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"text":"같음 (","type":"text"},{"type":"codeVoice","code":"a == b"},{"type":"text","text":")"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"같지 않음 (","type":"text"},{"type":"codeVoice","code":"a != b"},{"text":")","type":"text"}]}]},{"content":[{"inlineContent":[{"type":"text","text":"큼 ("},{"code":"a > b","type":"codeVoice"},{"text":")","type":"text"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"작음 ("},{"type":"codeVoice","code":"a < b"},{"text":")","type":"text"}]}]},{"content":[{"inlineContent":[{"text":"크거나 같음 (","type":"text"},{"type":"codeVoice","code":"a >= b"},{"type":"text","text":")"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"작거나 같음 ("},{"code":"a <= b","type":"codeVoice"},{"text":")","type":"text"}]}]}],"type":"unorderedList"},{"style":"note","name":"참고","type":"aside","content":[{"inlineContent":[{"type":"text","text":"Swift는 또한 두 객체 참조가 동일한 객체 인스턴스를 가리키는지 테스트하는 두 개의 "},{"type":"emphasis","inlineContent":[{"text":"식별 연산자","type":"text"}]},{"type":"text","text":" ("},{"type":"codeVoice","code":"==="},{"text":"와 ","type":"text"},{"type":"codeVoice","code":"!=="},{"type":"text","text":")를 제공한다. 자세한 내용은 "},{"text":"doc:ClassesAndStructures#Identity-Operators","type":"text"},{"text":"를 참조한다.","type":"text"}],"type":"paragraph"}]},{"inlineContent":[{"type":"text","text":"각 비교 연산자는 해당 문장이 참인지 여부를 나타내는 "},{"type":"codeVoice","code":"Bool"},{"text":" 값을 반환한다:","type":"text"}],"type":"paragraph"},{"type":"codeListing","syntax":"swift","code":["1 == 1   \/\/ 1이 1과 같으므로 true","2 != 1   \/\/ 2가 1과 같지 않으므로 true","2 > 1    \/\/ 2가 1보다 크므로 true","1 < 2    \/\/ 1이 2보다 작으므로 true","1 >= 1   \/\/ 1이 1보다 크거나 같으므로 true","2 <= 1   \/\/ 2가 1보다 작거나 같지 않으므로 false"]},{"type":"paragraph","inlineContent":[{"text":"비교 연산자는 주로 ","type":"text"},{"code":"if","type":"codeVoice"},{"type":"text","text":" 문과 같은 조건문에서 사용된다:"}]},{"code":["let name = \"world\"","if name == \"world\" {","    print(\"hello, world\")","} else {","    print(\"I'm sorry \\(name), but I don't recognize you\")","}","\/\/ name이 \"world\"와 같으므로 \"hello, world\"를 출력한다."],"type":"codeListing","syntax":"swift"},{"inlineContent":[{"code":"if","type":"codeVoice"},{"type":"text","text":" 문에 대한 자세한 내용은 "},{"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/ControlFlow","type":"reference","isActive":true},{"type":"text","text":"를 참조한다."}],"type":"paragraph"},{"inlineContent":[{"text":"같은 타입과 같은 수의 값을 가진 두 튜플을 비교할 수 있다. 튜플은 왼쪽에서 오른쪽으로 한 번에 하나의 값을 비교하며, 서로 다른 두 값을 찾을 때까지 비교를 진행한다. 이 두 값을 비교한 결과가 튜플 비교의 전체 결과를 결정한다. 모든 요소가 같으면 튜플 자체가 같다고 판단한다. 예를 들어:","type":"text"}],"type":"paragraph"},{"syntax":"swift","type":"codeListing","code":["(1, \"zebra\") < (2, \"apple\")   \/\/ 1이 2보다 작으므로 true; \"zebra\"와 \"apple\"은 비교하지 않음","(3, \"apple\") < (3, \"bird\")    \/\/ 3이 3과 같고, \"apple\"이 \"bird\"보다 작으므로 true","(4, \"dog\") == (4, \"dog\")      \/\/ 4가 4와 같고, \"dog\"가 \"dog\"와 같으므로 true"]},{"type":"paragraph","inlineContent":[{"text":"위 예제에서 첫 번째 줄의 왼쪽에서 오른쪽으로의 비교 동작을 확인할 수 있다. ","type":"text"},{"code":"1","type":"codeVoice"},{"text":"이 ","type":"text"},{"type":"codeVoice","code":"2"},{"type":"text","text":"보다 작기 때문에, 튜플의 다른 값과 관계없이 "},{"code":"(1, \"zebra\")","type":"codeVoice"},{"text":"는 ","type":"text"},{"type":"codeVoice","code":"(2, \"apple\")"},{"text":"보다 작다고 판단한다. ","type":"text"},{"type":"codeVoice","code":"\"zebra\""},{"type":"text","text":"가 "},{"type":"codeVoice","code":"\"apple\""},{"text":"보다 작지 않다는 사실은 중요하지 않다. 왜냐하면 비교는 이미 튜플의 첫 번째 요소에 의해 결정되었기 때문이다. 그러나 튜플의 첫 번째 요소가 같을 때는 두 번째 요소를 비교한다. 이는 두 번째와 세 번째 줄에서 볼 수 있다.","type":"text"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"튜플은 해당 연산자가 각 튜플의 모든 값에 적용될 수 있는 경우에만 비교할 수 있다. 예를 들어, 아래 코드에서 보여주듯이 "},{"type":"codeVoice","code":"<"},{"type":"text","text":" 연산자를 사용해 "},{"code":"(String, Int)","type":"codeVoice"},{"type":"text","text":" 타입의 두 튜플을 비교할 수 있다. 이는 "},{"type":"codeVoice","code":"String"},{"text":"과 ","type":"text"},{"code":"Int","type":"codeVoice"},{"text":" 값 모두 ","type":"text"},{"type":"codeVoice","code":"<"},{"type":"text","text":" 연산자로 비교할 수 있기 때문이다. 반대로, "},{"type":"codeVoice","code":"<"},{"type":"text","text":" 연산자는 "},{"type":"codeVoice","code":"Bool"},{"text":" 값에 적용할 수 없으므로 ","type":"text"},{"code":"(String, Bool)","type":"codeVoice"},{"type":"text","text":" 타입의 두 튜플은 "},{"type":"codeVoice","code":"<"},{"type":"text","text":" 연산자로 비교할 수 없다."}]},{"type":"codeListing","code":["(\"blue\", -1) < (\"purple\", 1)        \/\/ OK, true로 평가됨","(\"blue\", false) < (\"purple\", true)  \/\/ < 연산자가 Boolean 값을 비교할 수 없으므로 에러"],"syntax":"swift"},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Swift 표준 라이브러리는 7개 미만의 요소를 가진 튜플에 대한 비교 연산자를 포함한다. 7개 이상의 요소를 가진 튜플을 비교하려면 직접 비교 연산자를 구현해야 한다."}]}],"type":"aside","style":"note","name":"참고"},{"type":"heading","text":"삼항 조건 연산자","anchor":"%EC%82%BC%ED%95%AD-%EC%A1%B0%EA%B1%B4-%EC%97%B0%EC%82%B0%EC%9E%90","level":2},{"inlineContent":[{"inlineContent":[{"text":"삼항 조건 연산자","type":"text"}],"type":"emphasis"},{"type":"text","text":"는 세 부분으로 이루어진 특별한 연산자로, "},{"code":"question ? answer1 : answer2","type":"codeVoice"},{"type":"text","text":" 형태를 가진다. 이 연산자는 "},{"code":"question","type":"codeVoice"},{"type":"text","text":"이 참인지 거짓인지에 따라 두 표현식 중 하나를 평가하는 간단한 방법을 제공한다. "},{"type":"codeVoice","code":"question"},{"type":"text","text":"이 참이면 "},{"type":"codeVoice","code":"answer1"},{"type":"text","text":"을 평가하고 그 값을 반환하며, 거짓이면 "},{"type":"codeVoice","code":"answer2"},{"text":"를 평가하고 그 값을 반환한다.","type":"text"}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"text":"삼항 조건 연산자는 아래 코드를 간략하게 표현한 것이다:","type":"text"}]},{"type":"codeListing","syntax":"swift","code":["if question {","    answer1","} else {","    answer2","}"]},{"type":"paragraph","inlineContent":[{"text":"다음은 테이블 행의 높이를 계산하는 예제이다. 행에 헤더가 있다면 콘텐츠 높이보다 50 포인트 더 높게 설정하고, 헤더가 없다면 20 포인트 더 높게 설정한다:","type":"text"}]},{"syntax":"swift","code":["let contentHeight = 40","let hasHeader = true","let rowHeight = contentHeight + (hasHeader ? 50 : 20)","\/\/ rowHeight is equal to 90"],"type":"codeListing"},{"type":"paragraph","inlineContent":[{"text":"위 예제는 아래 코드를 간략하게 표현한 것이다:","type":"text"}]},{"type":"codeListing","syntax":"swift","code":["let contentHeight = 40","let hasHeader = true","let rowHeight: Int","if hasHeader {","    rowHeight = contentHeight + 50","} else {","    rowHeight = contentHeight + 20","}","\/\/ rowHeight is equal to 90"]},{"type":"paragraph","inlineContent":[{"text":"첫 번째 예제에서 삼항 조건 연산자를 사용하면 ","type":"text"},{"code":"rowHeight","type":"codeVoice"},{"type":"text","text":"를 한 줄의 코드로 올바른 값으로 설정할 수 있다. 이는 두 번째 예제에서 사용된 코드보다 더 간결하다."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"삼항 조건 연산자는 두 표현식 중 어느 것을 고를지 결정하는 효율적인 방법을 제공한다. 하지만 삼항 조건 연산자를 사용할 때는 주의가 필요하다. 과도하게 사용하면 코드를 이해하기 어려워질 수 있다. 여러 삼항 조건 연산자를 하나의 복합문으로 결합하는 것은 피하는 것이 좋다."}]},{"text":"Nil-Coalescing 연산자","level":2,"type":"heading","anchor":"Nil-Coalescing-%EC%97%B0%EC%82%B0%EC%9E%90"},{"type":"paragraph","inlineContent":[{"inlineContent":[{"text":"nil-coalescing 연산자","type":"text"}],"type":"emphasis"},{"type":"text","text":" ("},{"code":"a ?? b","type":"codeVoice"},{"text":")는 옵셔널 ","type":"text"},{"code":"a","type":"codeVoice"},{"text":"에 값이 있으면 그 값을 언래핑하고, ","type":"text"},{"code":"a","type":"codeVoice"},{"type":"text","text":"가 "},{"code":"nil","type":"codeVoice"},{"type":"text","text":"이면 기본값 "},{"code":"b","type":"codeVoice"},{"type":"text","text":"를 반환한다. 표현식 "},{"type":"codeVoice","code":"a"},{"text":"는 항상 옵셔널 타입이어야 하며, 표현식 ","type":"text"},{"type":"codeVoice","code":"b"},{"text":"는 ","type":"text"},{"type":"codeVoice","code":"a"},{"type":"text","text":"에 저장된 타입과 일치해야 한다."}]},{"inlineContent":[{"type":"text","text":"nil-coalescing 연산자는 아래 코드를 간결하게 표현한 것이다:"}],"type":"paragraph"},{"code":["a != nil ? a! : b"],"type":"codeListing","syntax":"swift"},{"inlineContent":[{"type":"text","text":"위 코드는 삼항 조건 연산자와 강제 언래핑("},{"type":"codeVoice","code":"a!"},{"text":")을 사용해 ","type":"text"},{"type":"codeVoice","code":"a"},{"type":"text","text":"가 "},{"type":"codeVoice","code":"nil"},{"text":"이 아닐 때 내부에 감싸진 값을 접근하고, 그렇지 않으면 ","type":"text"},{"code":"b","type":"codeVoice"},{"text":"를 반환한다. nil-coalescing 연산자는 이러한 조건 검사와 언래핑을 간결하고 가독성 좋은 형태로 캡슐화한다.","type":"text"}],"type":"paragraph"},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":""},{"code":"a","type":"codeVoice"},{"type":"text","text":"의 값이 "},{"code":"nil","type":"codeVoice"},{"type":"text","text":"이 아닌 경우, "},{"type":"codeVoice","code":"b"},{"type":"text","text":"는 평가되지 않는다. 이를 *단락 평가(short-circuit evaluation)*라고 한다."}]}],"style":"note","type":"aside","name":"참고"},{"inlineContent":[{"text":"아래 예제는 nil-coalescing 연산자를 사용해 기본 색상 이름과 옵셔널 사용자 정의 색상 이름 중 하나를 선택한다:","type":"text"}],"type":"paragraph"},{"code":["let defaultColorName = \"red\"","var userDefinedColorName: String?   \/\/ 기본값은 nil","","var colorNameToUse = userDefinedColorName ?? defaultColorName","\/\/ userDefinedColorName이 nil이므로 colorNameToUse는 기본값 \"red\"로 설정된다"],"type":"codeListing","syntax":"swift"},{"inlineContent":[{"code":"userDefinedColorName","type":"codeVoice"},{"type":"text","text":" 변수는 옵셔널 "},{"type":"codeVoice","code":"String"},{"text":"으로 정의되며, 기본값은 ","type":"text"},{"type":"codeVoice","code":"nil"},{"type":"text","text":"이다. "},{"type":"codeVoice","code":"userDefinedColorName"},{"type":"text","text":"이 옵셔널 타입이므로 nil-coalescing 연산자를 사용해 그 값을 확인할 수 있다. 위 예제에서 이 연산자는 "},{"type":"codeVoice","code":"colorNameToUse"},{"text":"라는 ","type":"text"},{"type":"codeVoice","code":"String"},{"text":" 변수의 초기값을 결정하는 데 사용된다. ","type":"text"},{"code":"userDefinedColorName","type":"codeVoice"},{"type":"text","text":"이 "},{"code":"nil","type":"codeVoice"},{"text":"이므로 ","type":"text"},{"code":"userDefinedColorName ?? defaultColorName","type":"codeVoice"},{"type":"text","text":" 표현식은 "},{"type":"codeVoice","code":"defaultColorName"},{"type":"text","text":"의 값인 "},{"type":"codeVoice","code":"\"red\""},{"type":"text","text":"를 반환한다."}],"type":"paragraph"},{"inlineContent":[{"code":"userDefinedColorName","type":"codeVoice"},{"type":"text","text":"에 "},{"type":"codeVoice","code":"nil"},{"type":"text","text":"이 아닌 값을 할당하고 nil-coalescing 연산자 검사를 다시 수행하면, 기본값 대신 "},{"type":"codeVoice","code":"userDefinedColorName"},{"text":"에 감싸진 값이 사용된다:","type":"text"}],"type":"paragraph"},{"code":["userDefinedColorName = \"green\"","colorNameToUse = userDefinedColorName ?? defaultColorName","\/\/ userDefinedColorName이 nil이 아니므로 colorNameToUse는 \"green\"으로 설정된다"],"type":"codeListing","syntax":"swift"},{"anchor":"%EB%B2%94%EC%9C%84-%EC%97%B0%EC%82%B0%EC%9E%90","type":"heading","text":"범위 연산자","level":2},{"type":"paragraph","inlineContent":[{"type":"text","text":"Swift는 여러 가지 "},{"type":"emphasis","inlineContent":[{"type":"text","text":"범위 연산자"}]},{"type":"text","text":"를 제공한다. 이 연산자들은 값의 범위를 간결하게 표현할 수 있는 편의 기능이다."}]},{"level":3,"anchor":"%EB%8B%AB%ED%9E%8C-%EB%B2%94%EC%9C%84-%EC%97%B0%EC%82%B0%EC%9E%90","text":"닫힌 범위 연산자","type":"heading"},{"type":"paragraph","inlineContent":[{"type":"emphasis","inlineContent":[{"text":"닫힌 범위 연산자","type":"text"}]},{"type":"text","text":"("},{"code":"a...b","type":"codeVoice"},{"text":")는 ","type":"text"},{"code":"a","type":"codeVoice"},{"text":"부터 ","type":"text"},{"type":"codeVoice","code":"b"},{"type":"text","text":"까지의 범위를 정의하며, "},{"code":"a","type":"codeVoice"},{"type":"text","text":"와 "},{"type":"codeVoice","code":"b"},{"text":" 값을 모두 포함한다. ","type":"text"},{"type":"codeVoice","code":"a"},{"type":"text","text":" 값은 "},{"type":"codeVoice","code":"b"},{"type":"text","text":"보다 크지 않아야 한다."}]},{"type":"paragraph","inlineContent":[{"text":"닫힌 범위 연산자는 ","type":"text"},{"code":"for","type":"codeVoice"},{"type":"text","text":"-"},{"code":"in","type":"codeVoice"},{"text":" 루프와 같이 모든 값을 사용하고자 할 때 유용하다.","type":"text"}]},{"type":"codeListing","syntax":"swift","code":["for index in 1...5 {","    print(\"\\(index) times 5 is \\(index * 5)\")","}","\/\/ 1 times 5 is 5","\/\/ 2 times 5 is 10","\/\/ 3 times 5 is 15","\/\/ 4 times 5 is 20","\/\/ 5 times 5 is 25"]},{"type":"paragraph","inlineContent":[{"code":"for","type":"codeVoice"},{"type":"text","text":"-"},{"code":"in","type":"codeVoice"},{"type":"text","text":" 루프에 대한 자세한 내용은 "},{"type":"reference","isActive":true,"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/ControlFlow"},{"text":"를 참고한다.","type":"text"}]},{"level":3,"text":"반개방 범위 연산자","type":"heading","anchor":"%EB%B0%98%EA%B0%9C%EB%B0%A9-%EB%B2%94%EC%9C%84-%EC%97%B0%EC%82%B0%EC%9E%90"},{"type":"paragraph","inlineContent":[{"inlineContent":[{"text":"반개방 범위 연산자","type":"text"}],"type":"emphasis"},{"text":"(","type":"text"},{"type":"codeVoice","code":"a..<b"},{"text":")는 ","type":"text"},{"code":"a","type":"codeVoice"},{"text":"부터 ","type":"text"},{"code":"b","type":"codeVoice"},{"text":"까지의 범위를 정의하지만, ","type":"text"},{"code":"b","type":"codeVoice"},{"type":"text","text":"는 포함하지 않는다. 이 연산자는 첫 번째 값은 포함하지만 마지막 값은 포함하지 않기 때문에 "},{"type":"emphasis","inlineContent":[{"type":"text","text":"반개방"}]},{"type":"text","text":"이라고 부른다. 닫힌 범위 연산자와 마찬가지로, "},{"type":"codeVoice","code":"a"},{"type":"text","text":"의 값은 "},{"type":"codeVoice","code":"b"},{"text":"보다 크지 않아야 한다. 만약 ","type":"text"},{"type":"codeVoice","code":"a"},{"type":"text","text":"와 "},{"type":"codeVoice","code":"b"},{"text":"의 값이 같다면, 결과 범위는 비어 있게 된다.","type":"text"}]},{"inlineContent":[{"text":"반개방 범위는 배열과 같이 0부터 시작하는 리스트를 다룰 때 특히 유용하다. 리스트의 길이까지 (하지만 포함하지 않고) 세는 데 적합하다:","type":"text"}],"type":"paragraph"},{"syntax":"swift","type":"codeListing","code":["let names = [\"Anna\", \"Alex\", \"Brian\", \"Jack\"]","let count = names.count","for i in 0..<count {","    print(\"Person \\(i + 1) is called \\(names[i])\")","}","\/\/ Person 1 is called Anna","\/\/ Person 2 is called Alex","\/\/ Person 3 is called Brian","\/\/ Person 4 is called Jack"]},{"type":"paragraph","inlineContent":[{"text":"배열에는 네 개의 항목이 있지만, ","type":"text"},{"code":"0..<count","type":"codeVoice"},{"type":"text","text":"는 마지막 항목의 인덱스인 "},{"code":"3","type":"codeVoice"},{"type":"text","text":"까지만 세는 것을 주목하자. 이는 반개방 범위이기 때문이다. 배열에 대한 더 자세한 내용은 "},{"type":"text","text":"doc:CollectionTypes#Arrays"},{"text":"를 참고하자.","type":"text"}]},{"type":"heading","text":"단방향 범위","anchor":"%EB%8B%A8%EB%B0%A9%ED%96%A5-%EB%B2%94%EC%9C%84","level":3},{"type":"paragraph","inlineContent":[{"text":"닫힌 범위 연산자는 한쪽 방향으로 끝까지 계속되는 범위를 표현하는 대체 형태를 제공한다. 예를 들어, 배열의 인덱스 2부터 배열의 끝까지 모든 요소를 포함하는 범위를 들 수 있다. 이런 경우 범위 연산자의 한쪽 값을 생략할 수 있다. 이렇게 한쪽에만 값이 있는 범위를 ","type":"text"},{"type":"emphasis","inlineContent":[{"type":"text","text":"단방향 범위"}]},{"type":"text","text":"라고 부른다. 예를 들어:"}]},{"type":"codeListing","syntax":"swift","code":["for name in names[2...] {","    print(name)","}","\/\/ Brian","\/\/ Jack","","for name in names[...2] {","    print(name)","}","\/\/ Anna","\/\/ Alex","\/\/ Brian"]},{"inlineContent":[{"type":"text","text":"반열린 범위 연산자도 마지막 값만 지정하는 단방향 형태가 있다. 양쪽에 값을 포함할 때와 마찬가지로, 마지막 값은 범위에 포함되지 않는다. 예를 들어:"}],"type":"paragraph"},{"type":"codeListing","syntax":"swift","code":["for name in names[..<2] {","    print(name)","}","\/\/ Anna","\/\/ Alex"]},{"inlineContent":[{"text":"단방향 범위는 서브스크립트 외의 다른 상황에서도 사용할 수 있다. 시작 값을 생략한 단방향 범위는 반복을 시작할 위치가 명확하지 않기 때문에 반복할 수 없다. 하지만 마지막 값을 생략한 단방향 범위는 반복할 수 있다. 다만, 범위가 무한히 계속되므로 반드시 루프에 명시적인 종료 조건을 추가해야 한다. 또한 특정 값이 단방향 범위에 포함되는지 확인할 수도 있다. 아래 코드에서 이를 확인할 수 있다.","type":"text"}],"type":"paragraph"},{"syntax":"swift","code":["let range = ...5","range.contains(7)   \/\/ false","range.contains(4)   \/\/ true","range.contains(-1)  \/\/ true"],"type":"codeListing"},{"anchor":"%EB%85%BC%EB%A6%AC-%EC%97%B0%EC%82%B0%EC%9E%90","level":2,"type":"heading","text":"논리 연산자"},{"inlineContent":[{"inlineContent":[{"type":"text","text":"논리 연산자"}],"type":"emphasis"},{"text":"는 불리언(Boolean) 논리 값인 ","type":"text"},{"type":"codeVoice","code":"true"},{"text":"와 ","type":"text"},{"code":"false","type":"codeVoice"},{"type":"text","text":"를 수정하거나 결합한다. Swift는 C 기반 언어에서 사용하는 세 가지 표준 논리 연산자를 지원한다:"}],"type":"paragraph"},{"items":[{"content":[{"inlineContent":[{"type":"text","text":"논리 NOT ("},{"code":"!a","type":"codeVoice"},{"text":")","type":"text"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"논리 AND (","type":"text"},{"code":"a && b","type":"codeVoice"},{"text":")","type":"text"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"논리 OR ("},{"type":"codeVoice","code":"a || b"},{"type":"text","text":")"}]}]}],"type":"unorderedList"},{"type":"heading","text":"논리적 NOT 연산자","level":3,"anchor":"%EB%85%BC%EB%A6%AC%EC%A0%81-NOT-%EC%97%B0%EC%82%B0%EC%9E%90"},{"type":"paragraph","inlineContent":[{"inlineContent":[{"type":"text","text":"논리적 NOT 연산자"}],"type":"emphasis"},{"text":"(","type":"text"},{"code":"!a","type":"codeVoice"},{"text":")는 불리언 값을 반전시킨다. ","type":"text"},{"type":"codeVoice","code":"true"},{"type":"text","text":"는 "},{"code":"false","type":"codeVoice"},{"text":"가 되고, ","type":"text"},{"type":"codeVoice","code":"false"},{"type":"text","text":"는 "},{"code":"true","type":"codeVoice"},{"type":"text","text":"가 된다."}]},{"inlineContent":[{"type":"text","text":"논리적 NOT 연산자는 접두사 연산자로, 연산 대상 값 바로 앞에 공백 없이 위치한다. 이 연산자는 “"},{"type":"codeVoice","code":"a"},{"type":"text","text":"가 아니다”로 읽을 수 있으며, 다음 예제에서 확인할 수 있다:"}],"type":"paragraph"},{"type":"codeListing","syntax":"swift","code":["let allowedEntry = false","if !allowedEntry {","    print(\"ACCESS DENIED\")","}","\/\/ Prints \"ACCESS DENIED\""]},{"type":"paragraph","inlineContent":[{"type":"codeVoice","code":"if !allowedEntry"},{"type":"text","text":"라는 구문은 “만약 입장이 허용되지 않았다면”으로 해석할 수 있다. 이어지는 코드는 “입장이 허용되지 않았다”가 참일 때, 즉 "},{"type":"codeVoice","code":"allowedEntry"},{"type":"text","text":"가 "},{"type":"codeVoice","code":"false"},{"type":"text","text":"일 때만 실행된다."}]},{"inlineContent":[{"type":"text","text":"이 예제에서 볼 수 있듯이, 불리언 상수와 변수의 이름을 신중하게 선택하면 코드의 가독성과 간결성을 높일 수 있다. 또한 이중 부정이나 혼란스러운 논리문을 피하는 데도 도움이 된다."}],"type":"paragraph"},{"anchor":"%EB%85%BC%EB%A6%AC-AND-%EC%97%B0%EC%82%B0%EC%9E%90","type":"heading","level":3,"text":"논리 AND 연산자"},{"type":"paragraph","inlineContent":[{"inlineContent":[{"type":"text","text":"논리 AND 연산자"}],"type":"emphasis"},{"type":"text","text":" ("},{"code":"a && b","type":"codeVoice"},{"text":")는 두 값이 모두 ","type":"text"},{"type":"codeVoice","code":"true"},{"type":"text","text":"여야 전체 표현식도 "},{"code":"true","type":"codeVoice"},{"text":"가 되는 논리 표현식을 만든다.","type":"text"}]},{"type":"paragraph","inlineContent":[{"text":"두 값 중 하나라도 ","type":"text"},{"type":"codeVoice","code":"false"},{"text":"라면, 전체 표현식도 ","type":"text"},{"type":"codeVoice","code":"false"},{"type":"text","text":"가 된다. 사실, "},{"inlineContent":[{"type":"text","text":"첫 번째"}],"type":"emphasis"},{"type":"text","text":" 값이 "},{"type":"codeVoice","code":"false"},{"type":"text","text":"라면 두 번째 값은 평가조차 되지 않는다. 왜냐하면 두 번째 값이 무엇이든 전체 표현식을 "},{"type":"codeVoice","code":"true"},{"text":"로 만들 수 없기 때문이다. 이를 *단락 평가(short-circuit evaluation)*라고 한다.","type":"text"}]},{"inlineContent":[{"type":"text","text":"다음 예제는 두 개의 "},{"type":"codeVoice","code":"Bool"},{"type":"text","text":" 값을 확인하고, 두 값이 모두 "},{"type":"codeVoice","code":"true"},{"type":"text","text":"일 때만 접근을 허용한다:"}],"type":"paragraph"},{"syntax":"swift","type":"codeListing","code":["let enteredDoorCode = true","let passedRetinaScan = false","if enteredDoorCode && passedRetinaScan {","    print(\"Welcome!\")","} else {","    print(\"ACCESS DENIED\")","}","\/\/ Prints \"ACCESS DENIED\""]},{"level":3,"type":"heading","anchor":"%EB%85%BC%EB%A6%AC-OR-%EC%97%B0%EC%82%B0%EC%9E%90","text":"논리 OR 연산자"},{"inlineContent":[{"type":"emphasis","inlineContent":[{"type":"text","text":"논리 OR 연산자"}]},{"text":" (","type":"text"},{"type":"codeVoice","code":"a || b"},{"text":")는 두 개의 파이프 문자를 연속해서 사용하는 중위 연산자이다. 이 연산자를 사용하면 두 값 중 ","type":"text"},{"inlineContent":[{"text":"하나","type":"text"}],"type":"emphasis"},{"type":"text","text":"만 "},{"type":"codeVoice","code":"true"},{"text":"여도 전체 표현식이 ","type":"text"},{"code":"true","type":"codeVoice"},{"text":"가 되는 논리 표현식을 만들 수 있다.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"앞서 설명한 논리 AND 연산자와 마찬가지로, 논리 OR 연산자도 단락 평가(short-circuit evaluation)를 사용해 표현식을 평가한다. 논리 OR 표현식의 왼쪽이 "},{"type":"codeVoice","code":"true"},{"type":"text","text":"라면 오른쪽은 평가하지 않는다. 왜냐하면 오른쪽을 평가해도 전체 표현식의 결과가 바뀌지 않기 때문이다."}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"text":"아래 예제에서 첫 번째 ","type":"text"},{"type":"codeVoice","code":"Bool"},{"text":" 값 (","type":"text"},{"type":"codeVoice","code":"hasDoorKey"},{"text":")은 ","type":"text"},{"type":"codeVoice","code":"false"},{"type":"text","text":"지만, 두 번째 값 ("},{"type":"codeVoice","code":"knowsOverridePassword"},{"type":"text","text":")은 "},{"code":"true","type":"codeVoice"},{"text":"이다. 두 값 중 하나가 ","type":"text"},{"type":"codeVoice","code":"true"},{"text":"이므로 전체 표현식도 ","type":"text"},{"code":"true","type":"codeVoice"},{"type":"text","text":"로 평가되며, 접근이 허용된다:"}]},{"type":"codeListing","code":["let hasDoorKey = false","let knowsOverridePassword = true","if hasDoorKey || knowsOverridePassword {","    print(\"Welcome!\")","} else {","    print(\"ACCESS DENIED\")","}","\/\/ Prints \"Welcome!\""],"syntax":"swift"},{"anchor":"%EB%85%BC%EB%A6%AC-%EC%97%B0%EC%82%B0%EC%9E%90-%EA%B2%B0%ED%95%A9%ED%95%98%EA%B8%B0","type":"heading","level":3,"text":"논리 연산자 결합하기"},{"inlineContent":[{"text":"여러 논리 연산자를 결합해 더 긴 복합 표현식을 만들 수 있다:","type":"text"}],"type":"paragraph"},{"code":["if enteredDoorCode && passedRetinaScan || hasDoorKey || knowsOverridePassword {","    print(\"Welcome!\")","} else {","    print(\"ACCESS DENIED\")","}","\/\/ Prints \"Welcome!\""],"syntax":"swift","type":"codeListing"},{"type":"paragraph","inlineContent":[{"text":"이 예제는 여러 ","type":"text"},{"type":"codeVoice","code":"&&"},{"text":"와 ","type":"text"},{"type":"codeVoice","code":"||"},{"type":"text","text":" 연산자를 사용해 더 긴 복합 표현식을 만든다. 하지만 "},{"type":"codeVoice","code":"&&"},{"text":"와 ","type":"text"},{"code":"||","type":"codeVoice"},{"type":"text","text":" 연산자는 여전히 두 개의 값에 대해 작동하므로, 이 예제는 사실 세 개의 작은 표현식이 연결된 것이다. 이 예제를 다음과 같이 해석할 수 있다:"}]},{"inlineContent":[{"type":"text","text":"만약 올바른 도어 코드를 입력하고 망막 스캔을 통과했거나, 유효한 도어 키를 가지고 있거나, 긴급 재정 비밀번호를 알고 있다면 접근을 허용한다."}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"type":"codeVoice","code":"enteredDoorCode"},{"text":", ","type":"text"},{"type":"codeVoice","code":"passedRetinaScan"},{"text":", ","type":"text"},{"type":"codeVoice","code":"hasDoorKey"},{"type":"text","text":"의 값에 따라 처음 두 하위 표현식은 "},{"type":"codeVoice","code":"false"},{"type":"text","text":"다. 하지만 긴급 재정 비밀번호를 알고 있으므로 전체 복합 표현식은 여전히 "},{"code":"true","type":"codeVoice"},{"type":"text","text":"로 평가된다."}]},{"type":"aside","name":"참고","style":"note","content":[{"inlineContent":[{"type":"text","text":"Swift의 논리 연산자 "},{"code":"&&","type":"codeVoice"},{"type":"text","text":"와 "},{"code":"||","type":"codeVoice"},{"type":"text","text":"는 왼쪽 결합성을 가진다. 즉, 여러 논리 연산자가 포함된 복합 표현식은 가장 왼쪽의 하위 표현식부터 먼저 평가한다."}],"type":"paragraph"}]},{"anchor":"%EB%AA%85%EC%8B%9C%EC%A0%81-%EA%B4%84%ED%98%B8-%EC%82%AC%EC%9A%A9","level":3,"text":"명시적 괄호 사용","type":"heading"},{"inlineContent":[{"type":"text","text":"복잡한 표현식의 의도를 더 명확히 전달하기 위해 괄호를 사용하는 것이 유용할 때가 있다. 괄호가 반드시 필요하지 않더라도, 코드의 가독성을 높이는 데 도움이 된다. 위의 문 접근 예제에서, 복합 표현식의 첫 부분에 괄호를 추가하면 의도가 더 명확해진다:"}],"type":"paragraph"},{"syntax":"swift","type":"codeListing","code":["if (enteredDoorCode && passedRetinaScan) || hasDoorKey || knowsOverridePassword {","    print(\"Welcome!\")","} else {","    print(\"ACCESS DENIED\")","}","\/\/ Prints \"Welcome!\""]},{"type":"paragraph","inlineContent":[{"type":"text","text":"괄호를 사용하면 처음 두 값이 전체 논리에서 별도의 가능한 상태로 간주된다는 점을 명확히 할 수 있다. 복합 표현식의 결과는 변하지 않지만, 전체 의도가 독자에게 더 명확해진다. 간결함보다는 가독성을 우선시하라. 의도를 명확히 하는 데 도움이 된다면 괄호를 사용한다."}]}]}],"references":{"doc://org.swift.tspl/documentation/The-Swift-Programming-Language":{"title":"The Swift Programming Language (6.1)","abstract":[],"kind":"article","role":"collection","type":"topic","url":"\/documentation\/the-swift-programming-language","identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language"},"remainderInteger":{"type":"image","identifier":"remainderInteger","variants":[{"traits":["2x","light"],"url":"\/images\/org.swift.tspl\/remainderInteger@2x.png"},{"url":"\/images\/org.swift.tspl\/remainderInteger~dark@2x.png","traits":["2x","dark"]}],"alt":null},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/ControlFlow":{"title":"제어 흐름","url":"\/documentation\/the-swift-programming-language\/controlflow","abstract":[{"text":"Swift는 다양한 제어 흐름 문법을 제공한다. 이를 통해 코드를 분기, 반복, 조기 종료 등의 방식으로 구조화할 수 있다.","type":"text"}],"type":"topic","role":"article","kind":"article","identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/ControlFlow"},"https://developer.apple.com/documentation/swift/operator_declarations":{"title":"Operator Declarations","identifier":"https:\/\/developer.apple.com\/documentation\/swift\/operator_declarations","type":"link","titleInlineContent":[{"type":"text","text":"Operator Declarations"}],"url":"https:\/\/developer.apple.com\/documentation\/swift\/operator_declarations"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/AdvancedOperators":{"title":"고급 연산자","url":"\/documentation\/the-swift-programming-language\/advancedoperators","abstract":[{"text":"커스텀 연산자를 정의하고, 비트 연산을 수행하며, 빌더 구문을 사용하는 방법을 알아본다.","type":"text"}],"type":"topic","role":"article","kind":"article","identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/AdvancedOperators"}}}