{"sections":[],"abstract":[{"type":"text","text":"옵셔널 값의 멤버에 접근할 때 언래핑 없이 사용할 수 있다."}],"kind":"article","schemaVersion":{"major":0,"minor":3,"patch":0},"metadata":{"title":"옵셔널 체이닝"},"identifier":{"interfaceLanguage":"swift","url":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/OptionalChaining"},"hierarchy":{"paths":[["doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language"]]},"primaryContentSections":[{"content":[{"type":"paragraph","inlineContent":[{"type":"emphasis","inlineContent":[{"text":"옵셔널 체이닝","type":"text"}]},{"type":"text","text":"은 현재 "},{"code":"nil","type":"codeVoice"},{"type":"text","text":"일 수 있는 옵셔널 값의 프로퍼티, 메서드, 서브스크립트를 조회하거나 호출하는 과정이다. 옵셔널에 값이 있으면 프로퍼티, 메서드, 서브스크립트 호출이 성공한다. 옵셔널이 "},{"type":"codeVoice","code":"nil"},{"type":"text","text":"이면 호출 결과로 "},{"type":"codeVoice","code":"nil"},{"type":"text","text":"을 반환한다. 여러 조회를 체인으로 연결할 수 있으며, 체인 중 어느 하나라도 "},{"type":"codeVoice","code":"nil"},{"text":"이면 전체 체인이 실패한다.","type":"text"}]},{"content":[{"inlineContent":[{"type":"text","text":"Swift의 옵셔널 체이닝은 Objective-C에서 "},{"code":"nil","type":"codeVoice"},{"text":"에 메시지를 보내는 방식과 유사하지만, 모든 타입에 적용할 수 있고 성공 또는 실패를 확인할 수 있다는 점에서 차이가 있다.","type":"text"}],"type":"paragraph"}],"type":"aside","name":"참고","style":"note"},{"level":2,"text":"강제 언래핑 대신 옵셔널 체이닝 사용하기","type":"heading","anchor":"%EA%B0%95%EC%A0%9C-%EC%96%B8%EB%9E%98%ED%95%91-%EB%8C%80%EC%8B%A0-%EC%98%B5%EC%85%94%EB%84%90-%EC%B2%B4%EC%9D%B4%EB%8B%9D-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0"},{"type":"paragraph","inlineContent":[{"type":"text","text":"옵셔널 체이닝은 옵셔널 값 뒤에 물음표("},{"code":"?","type":"codeVoice"},{"text":")를 붙여 사용한다. 이는 옵셔널 값이 ","type":"text"},{"code":"nil","type":"codeVoice"},{"type":"text","text":"이 아닐 때 프로퍼티, 메서드, 서브스크립트를 호출할 수 있게 해준다. 이는 옵셔널 값 뒤에 느낌표("},{"code":"!","type":"codeVoice"},{"type":"text","text":")를 붙여 강제 언래핑하는 것과 유사하지만, 중요한 차이점이 있다. 옵셔널 체이닝은 옵셔널이 "},{"type":"codeVoice","code":"nil"},{"text":"일 때 실패하지만, 강제 언래핑은 옵셔널이 ","type":"text"},{"type":"codeVoice","code":"nil"},{"text":"일 때 런타임 오류를 발생시킨다.","type":"text"}]},{"inlineContent":[{"text":"옵셔널 체이닝은 ","type":"text"},{"type":"codeVoice","code":"nil"},{"text":" 값에서도 호출될 수 있다는 사실을 반영하기 위해, 옵셔널 체이닝 호출의 결과는 항상 옵셔널 값이다. 이는 조회하는 프로퍼티, 메서드, 서브스크립트가 비옵셔널 값을 반환하더라도 마찬가지다. 이 옵셔널 반환 값을 통해 옵셔널 체이닝 호출이 성공했는지(반환된 옵셔널에 값이 있음), 체인 내에 ","type":"text"},{"type":"codeVoice","code":"nil"},{"type":"text","text":" 값이 있어 실패했는지(반환된 옵셔널 값이 "},{"code":"nil","type":"codeVoice"},{"text":") 확인할 수 있다.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"text":"구체적으로, 옵셔널 체이닝 호출의 결과는 예상된 반환 값과 동일한 타입이지만 옵셔널로 감싸져 있다. 예를 들어, 일반적으로 ","type":"text"},{"type":"codeVoice","code":"Int"},{"text":"를 반환하는 프로퍼티는 옵셔널 체이닝을 통해 접근할 때 ","type":"text"},{"type":"codeVoice","code":"Int?"},{"text":"를 반환한다.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"다음 코드 스니펫들은 옵셔널 체이닝이 강제 언래핑과 어떻게 다른지, 그리고 성공 여부를 확인하는 방법을 보여준다."}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"type":"text","text":"먼저, "},{"type":"codeVoice","code":"Person"},{"type":"text","text":"과 "},{"type":"codeVoice","code":"Residence"},{"type":"text","text":"라는 두 클래스를 정의한다:"}]},{"code":["class Person {","    var residence: Residence?","}","","class Residence {","    var numberOfRooms = 1","}"],"type":"codeListing","syntax":"swift"},{"type":"paragraph","inlineContent":[{"code":"Residence","type":"codeVoice"},{"type":"text","text":" 인스턴스는 기본값이 "},{"type":"codeVoice","code":"1"},{"text":"인 ","type":"text"},{"type":"codeVoice","code":"numberOfRooms"},{"type":"text","text":"라는 단일 "},{"type":"codeVoice","code":"Int"},{"text":" 프로퍼티를 가진다. ","type":"text"},{"type":"codeVoice","code":"Person"},{"text":" 인스턴스는 ","type":"text"},{"type":"codeVoice","code":"Residence?"},{"text":" 타입의 옵셔널 ","type":"text"},{"type":"codeVoice","code":"residence"},{"type":"text","text":" 프로퍼티를 가진다."}]},{"inlineContent":[{"type":"text","text":"새로운 "},{"type":"codeVoice","code":"Person"},{"type":"text","text":" 인스턴스를 생성하면, "},{"type":"codeVoice","code":"residence"},{"type":"text","text":" 프로퍼티는 옵셔널이기 때문에 기본적으로 "},{"type":"codeVoice","code":"nil"},{"text":"로 초기화된다. 아래 코드에서 ","type":"text"},{"type":"codeVoice","code":"john"},{"type":"text","text":"의 "},{"type":"codeVoice","code":"residence"},{"type":"text","text":" 프로퍼티 값은 "},{"type":"codeVoice","code":"nil"},{"type":"text","text":"이다:"}],"type":"paragraph"},{"type":"codeListing","code":["let john = Person()"],"syntax":"swift"},{"type":"paragraph","inlineContent":[{"type":"text","text":"이 사람의 "},{"type":"codeVoice","code":"residence"},{"type":"text","text":"의 "},{"type":"codeVoice","code":"numberOfRooms"},{"text":" 프로퍼티에 접근하려고 할 때, ","type":"text"},{"type":"codeVoice","code":"residence"},{"type":"text","text":" 뒤에 느낌표를 붙여 강제 언래핑을 시도하면, 언래핑할 "},{"code":"residence","type":"codeVoice"},{"text":" 값이 없기 때문에 런타임 오류가 발생한다:","type":"text"}]},{"syntax":"swift","type":"codeListing","code":["let roomCount = john.residence!.numberOfRooms","\/\/ 이 코드는 런타임 오류를 발생시킨다"]},{"type":"paragraph","inlineContent":[{"text":"위 코드는 ","type":"text"},{"code":"john.residence","type":"codeVoice"},{"text":"가 ","type":"text"},{"type":"codeVoice","code":"nil"},{"type":"text","text":"이 아닌 값을 가질 때 성공하고, "},{"type":"codeVoice","code":"roomCount"},{"text":"를 적절한 방의 수를 포함한 ","type":"text"},{"code":"Int","type":"codeVoice"},{"text":" 값으로 설정한다. 그러나 ","type":"text"},{"type":"codeVoice","code":"residence"},{"text":"가 ","type":"text"},{"code":"nil","type":"codeVoice"},{"text":"일 때는 항상 런타임 오류를 발생시킨다.","type":"text"}]},{"type":"paragraph","inlineContent":[{"text":"옵셔널 체이닝은 ","type":"text"},{"code":"numberOfRooms","type":"codeVoice"},{"text":"의 값에 접근하는 대안을 제공한다. 옵셔널 체이닝을 사용하려면 느낌표 대신 물음표를 사용한다:","type":"text"}]},{"syntax":"swift","code":["if let roomCount = john.residence?.numberOfRooms {","    print(\"John's residence has \\(roomCount) room(s).\")","} else {","    print(\"Unable to retrieve the number of rooms.\")","}","\/\/ \"Unable to retrieve the number of rooms.\"를 출력한다"],"type":"codeListing"},{"inlineContent":[{"type":"text","text":"이 코드는 Swift에게 옵셔널 "},{"type":"codeVoice","code":"residence"},{"type":"text","text":" 프로퍼티를 “체인”하고, "},{"code":"residence","type":"codeVoice"},{"type":"text","text":"가 존재할 경우 "},{"type":"codeVoice","code":"numberOfRooms"},{"type":"text","text":"의 값을 가져오라고 지시한다."}],"type":"paragraph"},{"inlineContent":[{"type":"codeVoice","code":"numberOfRooms"},{"type":"text","text":"에 접근하려는 시도가 실패할 가능성이 있기 때문에, 옵셔널 체이닝 시도는 "},{"type":"codeVoice","code":"Int?"},{"type":"text","text":" 타입의 값을 반환한다. 위 예제에서처럼 "},{"type":"codeVoice","code":"residence"},{"type":"text","text":"가 "},{"code":"nil","type":"codeVoice"},{"text":"일 때, 이 옵셔널 ","type":"text"},{"type":"codeVoice","code":"Int"},{"text":"도 ","type":"text"},{"code":"nil","type":"codeVoice"},{"text":"이 되며, 이는 ","type":"text"},{"type":"codeVoice","code":"numberOfRooms"},{"text":"에 접근할 수 없었음을 반영한다. 옵셔널 ","type":"text"},{"code":"Int","type":"codeVoice"},{"type":"text","text":"는 옵셔널 바인딩을 통해 접근되어 정수 값을 언래핑하고, 비옵셔널 값을 "},{"code":"roomCount","type":"codeVoice"},{"type":"text","text":" 상수에 할당한다."}],"type":"paragraph"},{"inlineContent":[{"code":"numberOfRooms","type":"codeVoice"},{"text":"가 비옵셔널 ","type":"text"},{"type":"codeVoice","code":"Int"},{"type":"text","text":"임에도 불구하고, 옵셔널 체인을 통해 조회되었다는 사실은 "},{"code":"numberOfRooms","type":"codeVoice"},{"text":"에 대한 호출이 항상 ","type":"text"},{"type":"codeVoice","code":"Int"},{"text":" 대신 ","type":"text"},{"type":"codeVoice","code":"Int?"},{"type":"text","text":"를 반환한다는 것을 의미한다."}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"type":"codeVoice","code":"john.residence"},{"type":"text","text":"에 "},{"code":"Residence","type":"codeVoice"},{"text":" 인스턴스를 할당하여 더 이상 ","type":"text"},{"code":"nil","type":"codeVoice"},{"type":"text","text":" 값을 갖지 않도록 할 수 있다:"}]},{"type":"codeListing","code":["john.residence = Residence()"],"syntax":"swift"},{"inlineContent":[{"text":"이제 ","type":"text"},{"type":"codeVoice","code":"john.residence"},{"text":"는 ","type":"text"},{"code":"nil","type":"codeVoice"},{"type":"text","text":"이 아닌 실제 "},{"type":"codeVoice","code":"Residence"},{"type":"text","text":" 인스턴스를 포함한다. 이전과 동일한 옵셔널 체이닝을 사용하여 "},{"type":"codeVoice","code":"numberOfRooms"},{"type":"text","text":"에 접근하면, 이제 기본 "},{"type":"codeVoice","code":"numberOfRooms"},{"text":" 값인 ","type":"text"},{"code":"1","type":"codeVoice"},{"type":"text","text":"을 포함한 "},{"code":"Int?","type":"codeVoice"},{"type":"text","text":"를 반환한다:"}],"type":"paragraph"},{"type":"codeListing","syntax":"swift","code":["if let roomCount = john.residence?.numberOfRooms {","    print(\"John's residence has \\(roomCount) room(s).\")","} else {","    print(\"Unable to retrieve the number of rooms.\")","}","\/\/ \"John's residence has 1 room(s).\"를 출력한다"]},{"level":2,"type":"heading","text":"옵셔널 체이닝을 위한 모델 클래스 정의","anchor":"%EC%98%B5%EC%85%94%EB%84%90-%EC%B2%B4%EC%9D%B4%EB%8B%9D%EC%9D%84-%EC%9C%84%ED%95%9C-%EB%AA%A8%EB%8D%B8-%ED%81%B4%EB%9E%98%EC%8A%A4-%EC%A0%95%EC%9D%98"},{"inlineContent":[{"text":"옵셔널 체이닝을 사용하면 프로퍼티, 메서드, 서브스크립트를 여러 단계로 호출할 수 있다. 이를 통해 서로 연관된 타입으로 구성된 복잡한 모델의 하위 프로퍼티를 탐색하고, 해당 하위 프로퍼티에 접근이 가능한지 확인할 수 있다.","type":"text"}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"type":"text","text":"아래 코드 스니펫은 여러 예제에서 사용할 네 개의 모델 클래스를 정의한다. 이 클래스들은 앞서 다룬 "},{"type":"codeVoice","code":"Person"},{"type":"text","text":"과 "},{"type":"codeVoice","code":"Residence"},{"type":"text","text":" 모델을 확장하여 "},{"code":"Room","type":"codeVoice"},{"text":"과 ","type":"text"},{"code":"Address","type":"codeVoice"},{"type":"text","text":" 클래스를 추가하고, 관련 프로퍼티, 메서드, 서브스크립트를 포함한다."}]},{"inlineContent":[{"type":"codeVoice","code":"Person"},{"type":"text","text":" 클래스는 이전과 동일한 방식으로 정의한다:"}],"type":"paragraph"},{"code":["class Person {","    var residence: Residence?","}"],"type":"codeListing","syntax":"swift"},{"inlineContent":[{"type":"codeVoice","code":"Residence"},{"type":"text","text":" 클래스는 이전보다 더 복잡하다. 이번에는 "},{"code":"Residence","type":"codeVoice"},{"type":"text","text":" 클래스가 "},{"code":"rooms","type":"codeVoice"},{"text":"라는 변수 프로퍼티를 정의하며, 이 프로퍼티는 ","type":"text"},{"type":"codeVoice","code":"[Room]"},{"type":"text","text":" 타입의 빈 배열로 초기화된다:"}],"type":"paragraph"},{"syntax":"swift","code":["class Residence {","    var rooms: [Room] = []","    var numberOfRooms: Int {","        return rooms.count","    }","    subscript(i: Int) -> Room {","        get {","            return rooms[i]","        }","        set {","            rooms[i] = newValue","        }","    }","    func printNumberOfRooms() {","        print(\"The number of rooms is \\(numberOfRooms)\")","    }","    var address: Address?","}"],"type":"codeListing"},{"inlineContent":[{"text":"이 버전의 ","type":"text"},{"code":"Residence","type":"codeVoice"},{"type":"text","text":"는 "},{"type":"codeVoice","code":"Room"},{"type":"text","text":" 인스턴스의 배열을 저장하므로, "},{"type":"codeVoice","code":"numberOfRooms"},{"type":"text","text":" 프로퍼티는 저장 프로퍼티가 아닌 계산 프로퍼티로 구현된다. 계산 프로퍼티인 "},{"code":"numberOfRooms","type":"codeVoice"},{"type":"text","text":"는 단순히 "},{"code":"rooms","type":"codeVoice"},{"type":"text","text":" 배열의 "},{"type":"codeVoice","code":"count"},{"type":"text","text":" 프로퍼티 값을 반환한다."}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"code":"rooms","type":"codeVoice"},{"type":"text","text":" 배열에 접근하기 위한 단축키로, 이 버전의 "},{"code":"Residence","type":"codeVoice"},{"text":"는 ","type":"text"},{"code":"rooms","type":"codeVoice"},{"type":"text","text":" 배열의 특정 인덱스에 있는 방에 접근할 수 있는 읽기-쓰기 서브스크립트를 제공한다."}]},{"type":"paragraph","inlineContent":[{"text":"이 버전의 ","type":"text"},{"type":"codeVoice","code":"Residence"},{"text":"는 또한 ","type":"text"},{"type":"codeVoice","code":"printNumberOfRooms"},{"text":"라는 메서드를 제공하며, 이 메서드는 거주지의 방 개수를 출력한다.","type":"text"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"마지막으로, "},{"type":"codeVoice","code":"Residence"},{"type":"text","text":"는 "},{"type":"codeVoice","code":"Address?"},{"text":" 타입의 옵셔널 프로퍼티인 ","type":"text"},{"code":"address","type":"codeVoice"},{"text":"를 정의한다. 이 프로퍼티의 타입인 ","type":"text"},{"code":"Address","type":"codeVoice"},{"text":" 클래스는 아래에서 정의된다.","type":"text"}]},{"inlineContent":[{"type":"codeVoice","code":"rooms"},{"type":"text","text":" 배열에 사용되는 "},{"type":"codeVoice","code":"Room"},{"type":"text","text":" 클래스는 "},{"code":"name","type":"codeVoice"},{"type":"text","text":"이라는 하나의 프로퍼티와 해당 프로퍼티를 적절한 방 이름으로 설정하는 초기화 메서드를 가진 간단한 클래스다:"}],"type":"paragraph"},{"syntax":"swift","type":"codeListing","code":["class Room {","    let name: String","    init(name: String) { self.name = name }","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"이 모델의 마지막 클래스는 "},{"type":"codeVoice","code":"Address"},{"type":"text","text":"다. 이 클래스는 "},{"code":"String?","type":"codeVoice"},{"type":"text","text":" 타입의 세 가지 옵셔널 프로퍼티를 가진다. 첫 두 프로퍼티인 "},{"code":"buildingName","type":"codeVoice"},{"type":"text","text":"과 "},{"type":"codeVoice","code":"buildingNumber"},{"text":"는 주소의 일부로 특정 건물을 식별하는 대체 방법이다. 세 번째 프로퍼티인 ","type":"text"},{"type":"codeVoice","code":"street"},{"type":"text","text":"는 해당 주소의 거리 이름을 지정하는 데 사용된다:"}]},{"syntax":"swift","type":"codeListing","code":["class Address {","    var buildingName: String?","    var buildingNumber: String?","    var street: String?","    func buildingIdentifier() -> String? {","        if let buildingNumber = buildingNumber, let street = street {","            return \"\\(buildingNumber) \\(street)\"","        } else if buildingName != nil {","            return buildingName","        } else {","            return nil","        }","    }","}"]},{"inlineContent":[{"code":"Address","type":"codeVoice"},{"type":"text","text":" 클래스는 또한 "},{"type":"codeVoice","code":"buildingIdentifier()"},{"type":"text","text":"라는 메서드를 제공하며, 이 메서드의 반환 타입은 "},{"type":"codeVoice","code":"String?"},{"type":"text","text":"이다. 이 메서드는 주소의 프로퍼티를 확인하고, "},{"code":"buildingName","type":"codeVoice"},{"type":"text","text":"에 값이 있으면 이를 반환하거나, "},{"code":"buildingNumber","type":"codeVoice"},{"type":"text","text":"와 "},{"type":"codeVoice","code":"street"},{"text":" 모두 값이 있으면 이를 연결하여 반환한다. 그렇지 않으면 ","type":"text"},{"code":"nil","type":"codeVoice"},{"text":"을 반환한다.","type":"text"}],"type":"paragraph"},{"anchor":"%EC%98%B5%EC%85%94%EB%84%90-%EC%B2%B4%EC%9D%B4%EB%8B%9D%EC%9D%84-%ED%86%B5%ED%95%9C-%ED%94%84%EB%A1%9C%ED%8D%BC%ED%8B%B0-%EC%A0%91%EA%B7%BC","type":"heading","text":"옵셔널 체이닝을 통한 프로퍼티 접근","level":2},{"type":"paragraph","inlineContent":[{"type":"text","text":"doc:OptionalChaining#Optional-Chaining-as-an-Alternative-to-Forced-Unwrapping"},{"text":"에서 보여준 것처럼,","type":"text"},{"type":"text","text":" "},{"type":"text","text":"옵셔널 체이닝을 사용해 옵셔널 값의 프로퍼티에 접근하고,"},{"text":" ","type":"text"},{"text":"그 접근이 성공했는지 확인할 수 있다.","type":"text"}]},{"inlineContent":[{"text":"앞서 정의한 클래스를 사용해 새로운 ","type":"text"},{"code":"Person","type":"codeVoice"},{"text":" 인스턴스를 생성하고,","type":"text"},{"text":" ","type":"text"},{"text":"이전과 같이 ","type":"text"},{"code":"numberOfRooms","type":"codeVoice"},{"type":"text","text":" 프로퍼티에 접근해 보자:"}],"type":"paragraph"},{"type":"codeListing","syntax":"swift","code":["let john = Person()","if let roomCount = john.residence?.numberOfRooms {","    print(\"John's residence has \\(roomCount) room(s).\")","} else {","    print(\"Unable to retrieve the number of rooms.\")","}","\/\/ Prints \"Unable to retrieve the number of rooms.\""]},{"type":"paragraph","inlineContent":[{"type":"codeVoice","code":"john.residence"},{"type":"text","text":"가 "},{"type":"codeVoice","code":"nil"},{"text":"이기 때문에,","type":"text"},{"type":"text","text":" "},{"type":"text","text":"이 옵셔널 체이닝 호출은 이전과 동일하게 실패한다."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"옵셔널 체이닝을 통해 프로퍼티 값을 설정하려는 시도도 할 수 있다:"}]},{"code":["let someAddress = Address()","someAddress.buildingNumber = \"29\"","someAddress.street = \"Acacia Road\"","john.residence?.address = someAddress"],"type":"codeListing","syntax":"swift"},{"inlineContent":[{"type":"text","text":"이 예제에서 "},{"type":"codeVoice","code":"john.residence"},{"text":"의 ","type":"text"},{"code":"address","type":"codeVoice"},{"type":"text","text":" 프로퍼티를 설정하려는 시도는 실패한다."},{"text":" ","type":"text"},{"text":"현재 ","type":"text"},{"type":"codeVoice","code":"john.residence"},{"type":"text","text":"가 "},{"type":"codeVoice","code":"nil"},{"type":"text","text":"이기 때문이다."}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"type":"text","text":"할당은 옵셔널 체이닝의 일부로 이루어지며,"},{"type":"text","text":" "},{"type":"text","text":"이는 "},{"code":"=","type":"codeVoice"},{"text":" 연산자의 오른쪽에 있는 코드가 평가되지 않음을 의미한다.","type":"text"},{"type":"text","text":" "},{"type":"text","text":"이전 예제에서는 "},{"type":"codeVoice","code":"someAddress"},{"type":"text","text":"가 평가되지 않았는지 쉽게 확인하기 어렵다."},{"text":" ","type":"text"},{"text":"상수에 접근하는 것은 어떤 부작용도 없기 때문이다.","type":"text"},{"type":"text","text":" "},{"type":"text","text":"아래 목록은 동일한 할당을 수행하지만,"},{"type":"text","text":" "},{"text":"주소를 생성하기 위해 함수를 사용한다.","type":"text"},{"type":"text","text":" "},{"type":"text","text":"함수는 값을 반환하기 전에 “Function was called”를 출력하므로,"},{"type":"text","text":" "},{"code":"=","type":"codeVoice"},{"text":" 연산자의 오른쪽이 평가되었는지 확인할 수 있다.","type":"text"}]},{"type":"codeListing","code":["func createAddress() -> Address {","    print(\"Function was called.\")","","    let someAddress = Address()","    someAddress.buildingNumber = \"29\"","    someAddress.street = \"Acacia Road\"","","    return someAddress","}","john.residence?.address = createAddress()"],"syntax":"swift"},{"type":"paragraph","inlineContent":[{"code":"createAddress()","type":"codeVoice"},{"type":"text","text":" 함수가 호출되지 않았음을 알 수 있다."},{"type":"text","text":" "},{"text":"아무것도 출력되지 않았기 때문이다.","type":"text"}]},{"anchor":"%EC%98%B5%EC%85%94%EB%84%90-%EC%B2%B4%EC%9D%B4%EB%8B%9D%EC%9D%84-%ED%86%B5%ED%95%B4-%EB%A9%94%EC%84%9C%EB%93%9C-%ED%98%B8%EC%B6%9C%ED%95%98%EA%B8%B0","text":"옵셔널 체이닝을 통해 메서드 호출하기","level":2,"type":"heading"},{"type":"paragraph","inlineContent":[{"text":"옵셔널 체이닝을 사용하면 옵셔널 값에 대해 메서드를 호출하고, 그 호출이 성공했는지 확인할 수 있다. 이 방법은 메서드가 반환 값을 정의하지 않은 경우에도 사용할 수 있다.","type":"text"}]},{"type":"paragraph","inlineContent":[{"code":"Residence","type":"codeVoice"},{"type":"text","text":" 클래스의 "},{"code":"printNumberOfRooms()","type":"codeVoice"},{"type":"text","text":" 메서드는 "},{"type":"codeVoice","code":"numberOfRooms"},{"type":"text","text":"의 현재 값을 출력한다. 이 메서드는 다음과 같이 정의된다:"}]},{"type":"codeListing","syntax":"swift","code":["func printNumberOfRooms() {","    print(\"The number of rooms is \\(numberOfRooms)\")","}"]},{"inlineContent":[{"type":"text","text":"이 메서드는 반환 타입을 명시하지 않는다. 하지만 반환 타입이 없는 함수와 메서드는 암시적으로 "},{"type":"codeVoice","code":"Void"},{"type":"text","text":" 타입을 반환한다. 이는 "},{"type":"text","text":"doc:Functions#Functions-Without-Return-Values"},{"text":"에서 설명한 바와 같다. 즉, ","type":"text"},{"code":"()","type":"codeVoice"},{"type":"text","text":" 또는 빈 튜플을 반환한다는 의미이다."}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"옵셔널 체이닝을 통해 이 메서드를 호출하면, 반환 타입은 "},{"code":"Void","type":"codeVoice"},{"text":"가 아니라 ","type":"text"},{"type":"codeVoice","code":"Void?"},{"text":"가 된다. 옵셔널 체이닝을 통해 호출된 경우 반환 값은 항상 옵셔널 타입이기 때문이다. 이를 통해 ","type":"text"},{"type":"codeVoice","code":"printNumberOfRooms()"},{"type":"text","text":" 메서드 호출이 가능했는지 확인할 수 있다. 메서드 자체가 반환 값을 정의하지 않더라도 "},{"type":"codeVoice","code":"printNumberOfRooms"},{"text":" 호출의 반환 값을 ","type":"text"},{"type":"codeVoice","code":"nil"},{"type":"text","text":"과 비교하여 호출이 성공했는지 확인할 수 있다:"}],"type":"paragraph"},{"syntax":"swift","code":["if john.residence?.printNumberOfRooms() != nil {","    print(\"It was possible to print the number of rooms.\")","} else {","    print(\"It was not possible to print the number of rooms.\")","}","\/\/ Prints \"It was not possible to print the number of rooms.\""],"type":"codeListing"},{"type":"paragraph","inlineContent":[{"text":"옵셔널 체이닝을 통해 프로퍼티를 설정하려는 경우에도 동일한 원리가 적용된다. 앞서 ","type":"text"},{"type":"text","text":"doc:OptionalChaining#Accessing-Properties-Through-Optional-Chaining"},{"text":"에서 다룬 예제는 ","type":"text"},{"type":"codeVoice","code":"john.residence"},{"type":"text","text":"가 "},{"code":"nil","type":"codeVoice"},{"text":"임에도 불구하고 ","type":"text"},{"type":"codeVoice","code":"address"},{"type":"text","text":" 값을 설정하려고 시도한다. 옵셔널 체이닝을 통해 프로퍼티를 설정하려는 모든 시도는 "},{"code":"Void?","type":"codeVoice"},{"text":" 타입의 값을 반환한다. 이를 통해 ","type":"text"},{"code":"nil","type":"codeVoice"},{"text":"과 비교하여 프로퍼티가 성공적으로 설정되었는지 확인할 수 있다:","type":"text"}]},{"code":["if (john.residence?.address = someAddress) != nil {","    print(\"It was possible to set the address.\")","} else {","    print(\"It was not possible to set the address.\")","}","\/\/ Prints \"It was not possible to set the address.\""],"syntax":"swift","type":"codeListing"},{"level":2,"type":"heading","anchor":"%EC%98%B5%EC%85%94%EB%84%90-%EC%B2%B4%EC%9D%B4%EB%8B%9D%EC%9D%84-%ED%86%B5%ED%95%B4-%EC%84%9C%EB%B8%8C%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8-%EC%A0%91%EA%B7%BC%ED%95%98%EA%B8%B0","text":"옵셔널 체이닝을 통해 서브스크립트 접근하기"},{"inlineContent":[{"type":"text","text":"옵셔널 체이닝을 사용하면 옵셔널 값의 서브스크립트에서 값을 가져오거나 설정할 수 있으며, 서브스크립트 호출이 성공했는지 확인할 수 있다."}],"type":"paragraph"},{"content":[{"type":"paragraph","inlineContent":[{"text":"옵셔널 체이닝을 통해 옵셔널 값의 서브스크립트에 접근할 때, 물음표는 서브스크립트의 대괄호 ","type":"text"},{"type":"emphasis","inlineContent":[{"text":"앞","type":"text"}]},{"text":"에 위치한다. 옵셔널 체이닝의 물음표는 항상 옵셔널인 표현식 부분 바로 뒤에 온다.","type":"text"}]}],"style":"note","name":"참고","type":"aside"},{"inlineContent":[{"text":"아래 예제는 ","type":"text"},{"code":"Residence","type":"codeVoice"},{"type":"text","text":" 클래스에 정의된 서브스크립트를 사용해 "},{"type":"codeVoice","code":"john.residence"},{"type":"text","text":" 프로퍼티의 "},{"type":"codeVoice","code":"rooms"},{"type":"text","text":" 배열에서 첫 번째 방의 이름을 가져오려고 시도한다. 현재 "},{"type":"codeVoice","code":"john.residence"},{"type":"text","text":"가 "},{"type":"codeVoice","code":"nil"},{"type":"text","text":"이기 때문에 서브스크립트 호출은 실패한다:"}],"type":"paragraph"},{"type":"codeListing","code":["if let firstRoomName = john.residence?[0].name {","    print(\"The first room name is \\(firstRoomName).\")","} else {","    print(\"Unable to retrieve the first room name.\")","}","\/\/ Prints \"Unable to retrieve the first room name.\""],"syntax":"swift"},{"inlineContent":[{"type":"text","text":"이 서브스크립트 호출에서 옵셔널 체이닝 물음표는 "},{"code":"john.residence","type":"codeVoice"},{"type":"text","text":" 바로 뒤, 서브스크립트 대괄호 앞에 위치한다. 왜냐하면 "},{"code":"john.residence","type":"codeVoice"},{"type":"text","text":"가 옵셔널 체이닝을 시도하는 옵셔널 값이기 때문이다."}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"text":"마찬가지로, 옵셔널 체이닝을 통해 서브스크립트에 새로운 값을 설정하려고 시도할 수도 있다:","type":"text"}]},{"type":"codeListing","code":["john.residence?[0] = Room(name: \"Bathroom\")"],"syntax":"swift"},{"type":"paragraph","inlineContent":[{"type":"text","text":"이 서브스크립트 설정 시도도 "},{"code":"residence","type":"codeVoice"},{"text":"가 현재 ","type":"text"},{"type":"codeVoice","code":"nil"},{"type":"text","text":"이기 때문에 실패한다."}]},{"inlineContent":[{"type":"text","text":"만약 실제 "},{"type":"codeVoice","code":"Residence"},{"type":"text","text":" 인스턴스를 생성하고 "},{"code":"john.residence","type":"codeVoice"},{"type":"text","text":"에 할당한 후, "},{"code":"rooms","type":"codeVoice"},{"type":"text","text":" 배열에 하나 이상의 "},{"code":"Room","type":"codeVoice"},{"text":" 인스턴스를 추가한다면, 옵셔널 체이닝을 통해 ","type":"text"},{"type":"codeVoice","code":"Residence"},{"text":" 서브스크립트를 사용해 ","type":"text"},{"type":"codeVoice","code":"rooms"},{"type":"text","text":" 배열의 실제 항목에 접근할 수 있다:"}],"type":"paragraph"},{"syntax":"swift","type":"codeListing","code":["let johnsHouse = Residence()","johnsHouse.rooms.append(Room(name: \"Living Room\"))","johnsHouse.rooms.append(Room(name: \"Kitchen\"))","john.residence = johnsHouse","","if let firstRoomName = john.residence?[0].name {","    print(\"The first room name is \\(firstRoomName).\")","} else {","    print(\"Unable to retrieve the first room name.\")","}","\/\/ Prints \"The first room name is Living Room.\""]},{"level":3,"text":"옵셔널 타입의 서브스크립트 접근","type":"heading","anchor":"%EC%98%B5%EC%85%94%EB%84%90-%ED%83%80%EC%9E%85%EC%9D%98-%EC%84%9C%EB%B8%8C%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8-%EC%A0%91%EA%B7%BC"},{"type":"paragraph","inlineContent":[{"text":"서브스크립트가 옵셔널 타입의 값을 반환하는 경우 —","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"예를 들어 Swift의 "},{"type":"codeVoice","code":"Dictionary"},{"type":"text","text":" 타입의 키 서브스크립트와 같은 경우 —"},{"text":" ","type":"text"},{"type":"text","text":"옵셔널 반환 값에 대해 체이닝을 하려면 서브스크립트의 닫는 대괄호 "},{"inlineContent":[{"type":"text","text":"뒤에"}],"type":"emphasis"},{"type":"text","text":" 물음표를 붙인다:"}]},{"type":"codeListing","syntax":"swift","code":["var testScores = [\"Dave\": [86, 82, 84], \"Bev\": [79, 94, 81]]","testScores[\"Dave\"]?[0] = 91","testScores[\"Bev\"]?[0] += 1","testScores[\"Brian\"]?[0] = 72","\/\/ \"Dave\" 배열은 이제 [91, 82, 84]이고, \"Bev\" 배열은 [80, 94, 81]이다."]},{"type":"paragraph","inlineContent":[{"text":"위 예제는 ","type":"text"},{"type":"codeVoice","code":"testScores"},{"type":"text","text":"라는 딕셔너리를 정의한다. 이 딕셔너리는 "},{"type":"codeVoice","code":"String"},{"text":" 키를 ","type":"text"},{"type":"codeVoice","code":"Int"},{"type":"text","text":" 값 배열에 매핑하는 두 개의 키-값 쌍을 포함한다. 예제는 옵셔널 체이닝을 사용해 "},{"code":"\"Dave\"","type":"codeVoice"},{"type":"text","text":" 배열의 첫 번째 항목을 "},{"type":"codeVoice","code":"91"},{"type":"text","text":"로 설정하고, "},{"type":"codeVoice","code":"\"Bev\""},{"type":"text","text":" 배열의 첫 번째 항목을 "},{"type":"codeVoice","code":"1"},{"type":"text","text":"만큼 증가시키며, "},{"code":"\"Brian\"","type":"codeVoice"},{"type":"text","text":" 키에 대한 배열의 첫 번째 항목을 설정하려고 시도한다. 첫 두 호출은 "},{"type":"codeVoice","code":"testScores"},{"text":" 딕셔너리에 ","type":"text"},{"type":"codeVoice","code":"\"Dave\""},{"type":"text","text":"와 "},{"type":"codeVoice","code":"\"Bev\""},{"text":" 키가 존재하기 때문에 성공한다. 세 번째 호출은 ","type":"text"},{"code":"testScores","type":"codeVoice"},{"text":" 딕셔너리에 ","type":"text"},{"type":"codeVoice","code":"\"Brian\""},{"text":" 키가 없기 때문에 실패한다.","type":"text"}]},{"type":"heading","text":"다단계 옵셔널 체이닝 연결하기","level":2,"anchor":"%EB%8B%A4%EB%8B%A8%EA%B3%84-%EC%98%B5%EC%85%94%EB%84%90-%EC%B2%B4%EC%9D%B4%EB%8B%9D-%EC%97%B0%EA%B2%B0%ED%95%98%EA%B8%B0"},{"type":"paragraph","inlineContent":[{"text":"여러 단계의 옵셔널 체이닝을 연결해 모델 내부의 프로퍼티, 메서드, 서브스크립트에 접근할 수 있다. 하지만 여러 단계의 옵셔널 체이닝을 사용하더라도 반환값의 옵셔널 여부는 달라지지 않는다.","type":"text"}]},{"inlineContent":[{"type":"text","text":"다시 말해:"}],"type":"paragraph"},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"text":"접근하려는 타입이 옵셔널이 아니라면, 옵셔널 체이닝으로 인해 옵셔널 타입이 된다.","type":"text"}]}]},{"content":[{"inlineContent":[{"text":"접근하려는 타입이 이미 옵셔널이라면, 체이닝을 통해 더 옵셔널해지지는 않는다.","type":"text"}],"type":"paragraph"}]}]},{"inlineContent":[{"type":"text","text":"따라서:"}],"type":"paragraph"},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"codeVoice","code":"Int"},{"text":" 값을 옵셔널 체이닝으로 접근하면, 체이닝 단계와 상관없이 항상 ","type":"text"},{"type":"codeVoice","code":"Int?"},{"text":"가 반환된다.","type":"text"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"마찬가지로 ","type":"text"},{"type":"codeVoice","code":"Int?"},{"type":"text","text":" 값을 옵셔널 체이닝으로 접근하면, 체이닝 단계와 상관없이 항상 "},{"type":"codeVoice","code":"Int?"},{"text":"가 반환된다.","type":"text"}]}]}]},{"inlineContent":[{"type":"text","text":"아래 예제는 "},{"code":"john","type":"codeVoice"},{"type":"text","text":"의 "},{"type":"codeVoice","code":"residence"},{"type":"text","text":" 프로퍼티의 "},{"code":"address","type":"codeVoice"},{"text":" 프로퍼티의 ","type":"text"},{"type":"codeVoice","code":"street"},{"type":"text","text":" 프로퍼티에 접근한다. 여기서는 옵셔널 타입인 "},{"code":"residence","type":"codeVoice"},{"type":"text","text":"와 "},{"type":"codeVoice","code":"address"},{"type":"text","text":" 프로퍼티를 거치는 두 단계의 옵셔널 체이닝이 사용된다:"}],"type":"paragraph"},{"syntax":"swift","type":"codeListing","code":["if let johnsStreet = john.residence?.address?.street {","    print(\"John's street name is \\(johnsStreet).\")","} else {","    print(\"Unable to retrieve the address.\")","}","\/\/ Prints \"Unable to retrieve the address.\""]},{"type":"paragraph","inlineContent":[{"type":"text","text":"현재 "},{"type":"codeVoice","code":"john.residence"},{"type":"text","text":"는 유효한 "},{"type":"codeVoice","code":"Residence"},{"text":" 인스턴스를 가지고 있다. 하지만 ","type":"text"},{"code":"john.residence.address","type":"codeVoice"},{"type":"text","text":"의 값은 현재 "},{"code":"nil","type":"codeVoice"},{"type":"text","text":"이다. 이 때문에 "},{"code":"john.residence?.address?.street","type":"codeVoice"},{"text":" 호출은 실패한다.","type":"text"}]},{"type":"paragraph","inlineContent":[{"text":"위 예제에서 ","type":"text"},{"type":"codeVoice","code":"street"},{"text":" 프로퍼티의 값을 가져오려고 한다. 이 프로퍼티의 타입은 ","type":"text"},{"type":"codeVoice","code":"String?"},{"text":"이다. 따라서 ","type":"text"},{"type":"codeVoice","code":"john.residence?.address?.street"},{"type":"text","text":"의 반환값도 "},{"type":"codeVoice","code":"String?"},{"type":"text","text":"이다. 두 단계의 옵셔널 체이닝이 적용되었지만, 프로퍼티 자체의 옵셔널 타입에 영향을 미치지 않는다."}]},{"type":"paragraph","inlineContent":[{"code":"john.residence.address","type":"codeVoice"},{"type":"text","text":"에 실제 "},{"code":"Address","type":"codeVoice"},{"text":" 인스턴스를 할당하고, ","type":"text"},{"type":"codeVoice","code":"street"},{"type":"text","text":" 프로퍼티에 실제 값을 설정하면, 다단계 옵셔널 체이닝을 통해 "},{"code":"street","type":"codeVoice"},{"type":"text","text":" 프로퍼티의 값에 접근할 수 있다:"}]},{"syntax":"swift","code":["let johnsAddress = Address()","johnsAddress.buildingName = \"The Larches\"","johnsAddress.street = \"Laurel Street\"","john.residence?.address = johnsAddress","","if let johnsStreet = john.residence?.address?.street {","    print(\"John's street name is \\(johnsStreet).\")","} else {","    print(\"Unable to retrieve the address.\")","}","\/\/ Prints \"John's street name is Laurel Street.\""],"type":"codeListing"},{"type":"paragraph","inlineContent":[{"type":"text","text":"이 예제에서 "},{"code":"john.residence","type":"codeVoice"},{"text":"의 ","type":"text"},{"code":"address","type":"codeVoice"},{"text":" 프로퍼티를 설정하는 시도는 성공한다. 현재 ","type":"text"},{"type":"codeVoice","code":"john.residence"},{"type":"text","text":"는 유효한 "},{"code":"Residence","type":"codeVoice"},{"type":"text","text":" 인스턴스를 가지고 있기 때문이다."}]},{"text":"옵셔널 반환 값을 가진 메서드 체이닝","level":2,"anchor":"%EC%98%B5%EC%85%94%EB%84%90-%EB%B0%98%ED%99%98-%EA%B0%92%EC%9D%84-%EA%B0%80%EC%A7%84-%EB%A9%94%EC%84%9C%EB%93%9C-%EC%B2%B4%EC%9D%B4%EB%8B%9D","type":"heading"},{"type":"paragraph","inlineContent":[{"type":"text","text":"이전 예제에서는 옵셔널 체이닝을 통해 옵셔널 타입의 프로퍼티 값을 가져오는 방법을 보여주었다. 또한 옵셔널 체이닝을 사용해 옵셔널 타입의 값을 반환하는 메서드를 호출하고, 필요한 경우 그 메서드의 반환 값에 대해 추가로 체이닝을 할 수도 있다."}]},{"type":"paragraph","inlineContent":[{"text":"아래 예제는 ","type":"text"},{"type":"codeVoice","code":"Address"},{"text":" 클래스의 ","type":"text"},{"type":"codeVoice","code":"buildingIdentifier()"},{"text":" 메서드를 옵셔널 체이닝을 통해 호출한다. 이 메서드는 ","type":"text"},{"type":"codeVoice","code":"String?"},{"type":"text","text":" 타입의 값을 반환한다. 앞서 설명한 것처럼, 옵셔널 체이닝을 거친 이 메서드 호출의 최종 반환 타입 역시 "},{"type":"codeVoice","code":"String?"},{"type":"text","text":"이다:"}]},{"type":"codeListing","code":["if let buildingIdentifier = john.residence?.address?.buildingIdentifier() {","    print(\"John's building identifier is \\(buildingIdentifier).\")","}","\/\/ Prints \"John's building identifier is The Larches.\""],"syntax":"swift"},{"type":"paragraph","inlineContent":[{"text":"만약 이 메서드의 반환 값에 대해 추가로 옵셔널 체이닝을 수행하고 싶다면, 옵셔널 체이닝 물음표를 메서드의 괄호 ","type":"text"},{"inlineContent":[{"type":"text","text":"뒤에"}],"type":"emphasis"},{"type":"text","text":" 위치시킨다:"}]},{"type":"codeListing","syntax":"swift","code":["if let beginsWithThe =","    john.residence?.address?.buildingIdentifier()?.hasPrefix(\"The\") {","    if beginsWithThe {","        print(\"John's building identifier begins with \\\"The\\\".\")","    } else {","        print(\"John's building identifier doesn't begin with \\\"The\\\".\")","    }","}","\/\/ Prints \"John's building identifier begins with \"The\".\""]},{"content":[{"inlineContent":[{"type":"text","text":"위 예제에서 옵셔널 체이닝 물음표를 괄호 "},{"type":"emphasis","inlineContent":[{"text":"뒤에","type":"text"}]},{"type":"text","text":" 위치시킨 이유는, 체이닝을 수행하는 대상이 "},{"type":"codeVoice","code":"buildingIdentifier()"},{"type":"text","text":" 메서드 자체가 아니라 해당 메서드의 반환 값이기 때문이다."}],"type":"paragraph"}],"name":"주의","style":"note","type":"aside"}],"kind":"content"}],"references":{"doc://org.swift.tspl/documentation/The-Swift-Programming-Language":{"title":"The Swift Programming Language (6.1)","abstract":[],"kind":"article","role":"collection","type":"topic","url":"\/documentation\/the-swift-programming-language","identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language"}}}