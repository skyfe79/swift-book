{"kind":"article","identifier":{"interfaceLanguage":"swift","url":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/ControlFlow"},"schemaVersion":{"major":0,"minor":3,"patch":0},"sections":[],"abstract":[{"type":"text","text":"Swift는 다양한 제어 흐름 문법을 제공한다. 이를 통해 코드를 분기, 반복, 조기 종료 등의 방식으로 구조화할 수 있다."}],"metadata":{"title":"제어 흐름"},"primaryContentSections":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Swift에서 제공하는 주요 제어 흐름 문법은 다음과 같다:"}]},{"items":[{"content":[{"inlineContent":[{"type":"codeVoice","code":"while"},{"text":" 반복문: 특정 작업을 여러 번 수행한다.","type":"text"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"codeVoice","code":"if"},{"text":", ","type":"text"},{"type":"codeVoice","code":"guard"},{"text":", ","type":"text"},{"type":"codeVoice","code":"switch"},{"text":" 문: 특정 조건에 따라 다른 코드 분기를 실행한다.","type":"text"}]}]},{"content":[{"inlineContent":[{"code":"break","type":"codeVoice"},{"type":"text","text":"와 "},{"type":"codeVoice","code":"continue"},{"text":": 코드 실행 흐름을 다른 지점으로 이동시킨다.","type":"text"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"type":"codeVoice","code":"for"},{"type":"text","text":"-"},{"type":"codeVoice","code":"in"},{"type":"text","text":" 반복문: 배열, 딕셔너리, 범위, 문자열 등의 시퀀스를 쉽게 순회할 수 있다."}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"type":"codeVoice","code":"defer"},{"type":"text","text":" 문: 현재 스코프를 벗어날 때 실행될 코드를 정의한다."}],"type":"paragraph"}]}],"type":"unorderedList"},{"type":"paragraph","inlineContent":[{"text":"Swift의 ","type":"text"},{"type":"codeVoice","code":"switch"},{"text":" 문은 C 계열 언어의 ","type":"text"},{"type":"codeVoice","code":"switch"},{"type":"text","text":" 문보다 훨씬 강력하다. 각 "},{"type":"codeVoice","code":"case"},{"type":"text","text":"는 다양한 패턴과 매칭될 수 있으며, 구간 매칭, 튜플, 특정 타입으로의 캐스팅 등을 지원한다. "},{"type":"codeVoice","code":"switch"},{"type":"text","text":" 문의 "},{"type":"codeVoice","code":"case"},{"type":"text","text":"에서 매칭된 값은 임시 상수나 변수로 바인딩되어 해당 "},{"type":"codeVoice","code":"case"},{"type":"text","text":" 내에서 사용할 수 있다. 또한, 각 "},{"type":"codeVoice","code":"case"},{"type":"text","text":"에 "},{"type":"codeVoice","code":"where"},{"type":"text","text":" 절을 추가해 복잡한 매칭 조건을 표현할 수 있다."}]},{"inlineContent":[{"type":"text","text":"이러한 제어 흐름 문법을 활용하면 코드를 더 명확하고 효율적으로 작성할 수 있다. Swift는 특히 "},{"type":"codeVoice","code":"switch"},{"type":"text","text":" 문을 통해 다양한 상황에 유연하게 대응할 수 있는 강력한 도구를 제공한다."}],"type":"paragraph"},{"type":"heading","anchor":"For-In-%EB%A3%A8%ED%94%84","level":2,"text":"For-In 루프"},{"type":"paragraph","inlineContent":[{"type":"codeVoice","code":"for"},{"text":"-","type":"text"},{"type":"codeVoice","code":"in"},{"type":"text","text":" 루프는 배열의 항목, 숫자 범위, 문자열의 문자와 같은 시퀀스를 순회할 때 사용한다."}]},{"inlineContent":[{"text":"다음은 배열의 항목을 순회하는 ","type":"text"},{"type":"codeVoice","code":"for"},{"text":"-","type":"text"},{"type":"codeVoice","code":"in"},{"type":"text","text":" 루프 예제이다:"}],"type":"paragraph"},{"code":["let names = [\"Anna\", \"Alex\", \"Brian\", \"Jack\"]","for name in names {","    print(\"Hello, \\(name)!\")","}","\/\/ Hello, Anna!","\/\/ Hello, Alex!","\/\/ Hello, Brian!","\/\/ Hello, Jack!"],"syntax":"swift","type":"codeListing"},{"type":"paragraph","inlineContent":[{"text":"딕셔너리를 순회하며 키-값 쌍에 접근할 수도 있다. 딕셔너리를 순회할 때 각 항목은 ","type":"text"},{"type":"codeVoice","code":"(key, value)"},{"type":"text","text":" 튜플로 반환되며, 이 튜플의 멤버를 명시적으로 이름을 붙인 상수로 분해하여 "},{"type":"codeVoice","code":"for"},{"type":"text","text":"-"},{"code":"in","type":"codeVoice"},{"text":" 루프 내부에서 사용할 수 있다. 아래 코드 예제에서 딕셔너리의 키는 ","type":"text"},{"type":"codeVoice","code":"animalName"},{"type":"text","text":" 상수로, 값은 "},{"type":"codeVoice","code":"legCount"},{"type":"text","text":" 상수로 분해된다."}]},{"code":["let numberOfLegs = [\"spider\": 8, \"ant\": 6, \"cat\": 4]","for (animalName, legCount) in numberOfLegs {","    print(\"\\(animalName)s have \\(legCount) legs\")","}","\/\/ cats have 4 legs","\/\/ ants have 6 legs","\/\/ spiders have 8 legs"],"syntax":"swift","type":"codeListing"},{"type":"paragraph","inlineContent":[{"type":"text","text":"딕셔너리의 내용은 본질적으로 순서가 없으며, 순회할 때 항목이 어떤 순서로 반환될지 보장되지 않는다. 특히, 딕셔너리에 항목을 추가한 순서가 순회 순서를 정의하지 않는다. 배열과 딕셔너리에 대한 자세한 내용은 "},{"isActive":true,"type":"reference","identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/CollectionTypes"},{"text":"를 참고한다.","type":"text"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"숫자 범위와 함께 "},{"type":"codeVoice","code":"for"},{"text":"-","type":"text"},{"type":"codeVoice","code":"in"},{"type":"text","text":" 루프를 사용할 수도 있다. 다음은 5의 배수표의 처음 몇 항목을 출력하는 예제이다:"}]},{"syntax":"swift","type":"codeListing","code":["for index in 1...5 {","    print(\"\\(index) times 5 is \\(index * 5)\")","}","\/\/ 1 times 5 is 5","\/\/ 2 times 5 is 10","\/\/ 3 times 5 is 15","\/\/ 4 times 5 is 20","\/\/ 5 times 5 is 25"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"순회되는 시퀀스는 닫힌 범위 연산자("},{"type":"codeVoice","code":"..."},{"text":")를 사용해 ","type":"text"},{"type":"codeVoice","code":"1"},{"text":"부터 ","type":"text"},{"type":"codeVoice","code":"5"},{"text":"까지의 숫자 범위이다. ","type":"text"},{"code":"index","type":"codeVoice"},{"type":"text","text":"의 값은 범위의 첫 번째 숫자("},{"type":"codeVoice","code":"1"},{"type":"text","text":")로 설정되고, 루프 내부의 문장이 실행된다. 이 경우 루프는 단 하나의 문장만 포함하며, 현재 "},{"type":"codeVoice","code":"index"},{"text":" 값에 대한 5의 배수표 항목을 출력한다. 문장이 실행된 후, ","type":"text"},{"code":"index","type":"codeVoice"},{"type":"text","text":"의 값은 범위의 두 번째 값("},{"type":"codeVoice","code":"2"},{"text":")으로 업데이트되고, ","type":"text"},{"code":"print(_:separator:terminator:)","type":"codeVoice"},{"text":" 함수가 다시 호출된다. 이 과정은 범위의 끝에 도달할 때까지 계속된다.","type":"text"}]},{"type":"paragraph","inlineContent":[{"text":"위 예제에서 ","type":"text"},{"type":"codeVoice","code":"index"},{"text":"는 루프의 각 반복이 시작될 때 자동으로 설정되는 상수이다. 따라서 ","type":"text"},{"type":"codeVoice","code":"index"},{"type":"text","text":"는 사용 전에 선언할 필요가 없다. 루프 선언에 포함되는 것만으로 암시적으로 선언되며, "},{"code":"let","type":"codeVoice"},{"type":"text","text":" 선언 키워드가 필요하지 않다."}]},{"type":"paragraph","inlineContent":[{"text":"시퀀스의 각 값이 필요하지 않다면, 변수 이름 대신 언더스코어(","type":"text"},{"code":"_","type":"codeVoice"},{"type":"text","text":")를 사용해 값을 무시할 수 있다."}]},{"syntax":"swift","code":["let base = 3","let power = 10","var answer = 1","for _ in 1...power {","    answer *= base","}","print(\"\\(base) to the power of \\(power) is \\(answer)\")","\/\/ Prints \"3 to the power of 10 is 59049\""],"type":"codeListing"},{"type":"paragraph","inlineContent":[{"text":"위 예제는 한 숫자를 다른 숫자의 거듭제곱으로 계산한다(이 경우 ","type":"text"},{"code":"3","type":"codeVoice"},{"text":"의 ","type":"text"},{"type":"codeVoice","code":"10"},{"type":"text","text":"제곱). 시작 값 "},{"type":"codeVoice","code":"1"},{"type":"text","text":"(즉, "},{"type":"codeVoice","code":"3"},{"type":"text","text":"의 "},{"type":"codeVoice","code":"0"},{"type":"text","text":"제곱)에 "},{"type":"codeVoice","code":"3"},{"type":"text","text":"을 10번 곱하며, "},{"code":"1","type":"codeVoice"},{"type":"text","text":"부터 "},{"code":"10","type":"codeVoice"},{"type":"text","text":"까지의 닫힌 범위를 사용한다. 이 계산에서는 루프를 돌 때마다 개별 카운터 값이 필요하지 않다. 코드는 단순히 루프를 정확한 횟수만큼 실행한다. 루프 변수 대신 사용된 언더스코어("},{"code":"_","type":"codeVoice"},{"type":"text","text":")는 개별 값을 무시하며, 루프의 각 반복에서 현재 값에 접근하지 않는다."}]},{"type":"paragraph","inlineContent":[{"text":"경우에 따라 양쪽 끝점을 모두 포함하는 닫힌 범위를 사용하고 싶지 않을 수 있다. 시계의 분침 눈금을 그리는 경우를 생각해보자. ","type":"text"},{"type":"codeVoice","code":"0"},{"type":"text","text":"분부터 시작해 "},{"code":"60","type":"codeVoice"},{"type":"text","text":"개의 눈금을 그려야 한다. 하한은 포함하지만 상한은 포함하지 않는 반열린 범위 연산자("},{"type":"codeVoice","code":"..<"},{"type":"text","text":")를 사용한다. 범위에 대한 자세한 내용은 "},{"text":"doc:BasicOperators#Range-Operators","type":"text"},{"type":"text","text":"를 참고한다."}]},{"type":"codeListing","code":["let minutes = 60","for tickMark in 0..<minutes {","    \/\/ 분마다 눈금을 그린다 (60번)","}"],"syntax":"swift"},{"type":"paragraph","inlineContent":[{"text":"일부 사용자는 UI에 더 적은 눈금을 원할 수 있다. 예를 들어, 매 ","type":"text"},{"type":"codeVoice","code":"5"},{"text":"분마다 하나의 눈금을 그리는 것을 선호할 수 있다. 원하지 않는 눈금을 건너뛰기 위해 ","type":"text"},{"type":"codeVoice","code":"stride(from:to:by:)"},{"type":"text","text":" 함수를 사용한다."}]},{"type":"codeListing","syntax":"swift","code":["let minuteInterval = 5","for tickMark in stride(from: 0, to: minutes, by: minuteInterval) {","    \/\/ 5분마다 눈금을 그린다 (0, 5, 10, 15 ... 45, 50, 55)","}"]},{"type":"paragraph","inlineContent":[{"text":"닫힌 범위도 사용할 수 있으며, ","type":"text"},{"code":"stride(from:through:by:)","type":"codeVoice"},{"text":"를 대신 사용한다:","type":"text"}]},{"code":["let hours = 12","let hourInterval = 3","for tickMark in stride(from: 3, through: hours, by: hourInterval) {","    \/\/ 3시간마다 눈금을 그린다 (3, 6, 9, 12)","}"],"type":"codeListing","syntax":"swift"},{"inlineContent":[{"text":"위 예제들은 ","type":"text"},{"type":"codeVoice","code":"for"},{"type":"text","text":"-"},{"type":"codeVoice","code":"in"},{"type":"text","text":" 루프를 사용해 범위, 배열, 딕셔너리, 문자열을 순회하는 방법을 보여준다. 그러나 이 문법은 "},{"isActive":true,"type":"reference","identifier":"https:\/\/developer.apple.com\/documentation\/swift\/sequence"},{"text":" 프로토콜을 준수하는 모든 컬렉션을 순회할 수 있으며, 사용자 정의 클래스와 컬렉션 타입도 포함된다.","type":"text"}],"type":"paragraph"},{"anchor":"While-%EB%A3%A8%ED%94%84","text":"While 루프","level":2,"type":"heading"},{"inlineContent":[{"type":"codeVoice","code":"while"},{"type":"text","text":" 루프는 특정 조건이 "},{"code":"false","type":"codeVoice"},{"type":"text","text":"가 될 때까지 일련의 명령문을 반복한다."},{"text":" ","type":"text"},{"type":"text","text":"이러한 루프는 반복 횟수를 처음 시작하기 전에 알 수 없는 경우에 가장 적합하다."},{"type":"text","text":" "},{"type":"text","text":"Swift는 두 가지 종류의 "},{"code":"while","type":"codeVoice"},{"text":" 루프를 제공한다:","type":"text"}],"type":"paragraph"},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"code":"while","type":"codeVoice"},{"text":"은 각 루프를 시작할 때 조건을 평가한다.","type":"text"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"code":"repeat","type":"codeVoice"},{"type":"text","text":"-"},{"type":"codeVoice","code":"while"},{"type":"text","text":"은 각 루프를 끝낼 때 조건을 평가한다."}]}]}]},{"type":"heading","text":"While 반복문","level":3,"anchor":"While-%EB%B0%98%EB%B3%B5%EB%AC%B8"},{"inlineContent":[{"type":"codeVoice","code":"while"},{"type":"text","text":" 반복문은 단일 조건을 평가하는 것으로 시작한다. 조건이 "},{"code":"true","type":"codeVoice"},{"type":"text","text":"일 경우, 조건이 "},{"code":"false","type":"codeVoice"},{"text":"가 될 때까지 일련의 문장을 반복 실행한다.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"type":"codeVoice","code":"while"},{"text":" 반복문의 일반적인 형태는 다음과 같다:","type":"text"}],"type":"paragraph"},{"syntax":"swift","code":["while <#조건#> {","   <#문장#>","}"],"type":"codeListing"},{"type":"paragraph","inlineContent":[{"text":"다음 예제는 ","type":"text"},{"type":"emphasis","inlineContent":[{"type":"text","text":"뱀과 사다리"}]},{"type":"text","text":" 게임(또는 "},{"type":"emphasis","inlineContent":[{"type":"text","text":"미끄럼틀과 사다리"}]},{"text":"로도 알려진)을 간단히 구현한 것이다:","type":"text"}]},{"inlineContent":[{"type":"image","identifier":"snakesAndLadders"}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"type":"text","text":"게임의 규칙은 다음과 같다:"}]},{"items":[{"content":[{"inlineContent":[{"type":"text","text":"게임판은 25개의 칸으로 이루어져 있으며, 목표는 25번 칸에 도달하거나 이를 넘어서는 것이다."}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"text":"플레이어의 시작 칸은 “0번 칸”으로, 게임판의 왼쪽 아래 모서리 바로 바깥에 위치한다.","type":"text"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"각 턴마다 6면체 주사위를 굴려 나온 숫자만큼 칸을 이동한다. 이동 경로는 위의 점선 화살표로 표시된 수평 경로를 따른다."}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"턴이 끝난 위치가 사다리의 하단이면, 해당 사다리를 타고 올라간다."}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"턴이 끝난 위치가 뱀의 머리면, 해당 뱀을 타고 내려간다."}]}]}],"type":"unorderedList"},{"inlineContent":[{"text":"게임판은 ","type":"text"},{"type":"codeVoice","code":"Int"},{"type":"text","text":" 값의 배열로 표현된다. 배열의 크기는 "},{"code":"finalSquare","type":"codeVoice"},{"type":"text","text":"라는 상수를 기반으로 하며, 이 상수는 배열을 초기화하고 나중에 승리 조건을 확인하는 데 사용된다. 플레이어가 게임판 바깥의 “0번 칸”에서 시작하기 때문에, 배열은 25가 아닌 26개의 "},{"type":"codeVoice","code":"0"},{"text":"으로 초기화된다.","type":"text"}],"type":"paragraph"},{"type":"codeListing","code":["let finalSquare = 25","var board = [Int](repeating: 0, count: finalSquare + 1)"],"syntax":"swift"},{"type":"paragraph","inlineContent":[{"type":"text","text":"일부 칸은 뱀과 사다리에 대해 더 구체적인 값을 갖도록 설정된다. 사다리의 하단에 해당하는 칸은 양수 값을 가지며, 이를 통해 게임판 위로 이동한다. 반면, 뱀의 머리에 해당하는 칸은 음수 값을 가지며, 이를 통해 게임판 아래로 이동한다."}]},{"type":"codeListing","code":["board[03] = +08; board[06] = +11; board[09] = +09; board[10] = +02","board[14] = -10; board[19] = -11; board[22] = -02; board[24] = -08"],"syntax":"swift"},{"inlineContent":[{"type":"text","text":"3번 칸은 사다리의 하단으로, 이를 통해 11번 칸으로 이동한다. 이를 표현하기 위해 "},{"type":"codeVoice","code":"board[03]"},{"text":"은 ","type":"text"},{"code":"+08","type":"codeVoice"},{"text":"로 설정되며, 이는 ","type":"text"},{"code":"8","type":"codeVoice"},{"text":"의 정수 값(","type":"text"},{"code":"3","type":"codeVoice"},{"type":"text","text":"과 "},{"code":"11","type":"codeVoice"},{"text":"의 차이)과 동일하다. 값과 문장을 정렬하기 위해, 단항 플러스 연산자(","type":"text"},{"type":"codeVoice","code":"+i"},{"text":")가 명시적으로 단항 마이너스 연산자(","type":"text"},{"type":"codeVoice","code":"-i"},{"text":")와 함께 사용되며, ","type":"text"},{"type":"codeVoice","code":"10"},{"type":"text","text":"보다 작은 숫자는 0으로 패딩된다. (이러한 스타일 기법은 엄격히 필요하지 않지만, 코드를 더 깔끔하게 만든다.)"}],"type":"paragraph"},{"code":["var square = 0","var diceRoll = 0","while square < finalSquare {","    \/\/ 주사위를 굴린다","    diceRoll += 1","    if diceRoll == 7 { diceRoll = 1 }","    \/\/ 주사위 값만큼 이동한다","    square += diceRoll","    if square < board.count {","        \/\/ 아직 게임판 위에 있다면, 뱀이나 사다리를 통해 이동한다","        square += board[square]","    }","}","print(\"Game over!\")"],"syntax":"swift","type":"codeListing"},{"type":"paragraph","inlineContent":[{"text":"위 예제는 주사위 굴리기를 매우 간단한 방식으로 처리한다. 랜덤 숫자를 생성하는 대신, ","type":"text"},{"type":"codeVoice","code":"diceRoll"},{"type":"text","text":" 값을 "},{"type":"codeVoice","code":"0"},{"text":"으로 시작한다. ","type":"text"},{"type":"codeVoice","code":"while"},{"text":" 반복문이 실행될 때마다 ","type":"text"},{"type":"codeVoice","code":"diceRoll"},{"type":"text","text":"은 1씩 증가하며, 너무 큰 값이 되었는지 확인한다. 이 반환 값이 "},{"type":"codeVoice","code":"7"},{"text":"이 될 때마다, 주사위 값이 너무 커졌으므로 ","type":"text"},{"type":"codeVoice","code":"1"},{"text":"로 재설정된다. 결과적으로 ","type":"text"},{"type":"codeVoice","code":"diceRoll"},{"type":"text","text":" 값은 항상 "},{"type":"codeVoice","code":"1"},{"type":"text","text":", "},{"type":"codeVoice","code":"2"},{"text":", ","type":"text"},{"type":"codeVoice","code":"3"},{"type":"text","text":", "},{"type":"codeVoice","code":"4"},{"text":", ","type":"text"},{"type":"codeVoice","code":"5"},{"type":"text","text":", "},{"code":"6","type":"codeVoice"},{"type":"text","text":", "},{"code":"1","type":"codeVoice"},{"type":"text","text":", "},{"type":"codeVoice","code":"2"},{"type":"text","text":"와 같은 순서로 반복된다."}]},{"type":"paragraph","inlineContent":[{"text":"주사위를 굴린 후, 플레이어는 ","type":"text"},{"type":"codeVoice","code":"diceRoll"},{"type":"text","text":" 값만큼 앞으로 이동한다. 주사위 값이 플레이어를 25번 칸을 넘어서 이동시킬 수도 있으며, 이 경우 게임이 종료된다. 이 시나리오를 처리하기 위해, 코드는 "},{"code":"square","type":"codeVoice"},{"type":"text","text":"가 "},{"type":"codeVoice","code":"board"},{"text":" 배열의 ","type":"text"},{"code":"count","type":"codeVoice"},{"text":" 속성보다 작은지 확인한다. ","type":"text"},{"code":"square","type":"codeVoice"},{"type":"text","text":"가 유효하다면, "},{"code":"board[square]","type":"codeVoice"},{"text":"에 저장된 값이 현재 ","type":"text"},{"type":"codeVoice","code":"square"},{"text":" 값에 더해져 플레이어가 사다리나 뱀을 통해 이동한다.","type":"text"}]},{"style":"note","name":"참고","type":"aside","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"이 확인을 수행하지 않으면, "},{"code":"board[square]","type":"codeVoice"},{"type":"text","text":"가 "},{"type":"codeVoice","code":"board"},{"text":" 배열의 범위를 벗어난 값을 접근하려 할 수 있으며, 이는 런타임 오류를 발생시킬 수 있다.","type":"text"}]}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"현재 "},{"code":"while","type":"codeVoice"},{"type":"text","text":" 반복문의 실행이 끝나면, 반복문의 조건이 다시 확인되어 반복문을 계속 실행할지 결정한다. 플레이어가 25번 칸에 도달하거나 이를 넘어서면, 반복문의 조건이 "},{"type":"codeVoice","code":"false"},{"type":"text","text":"로 평가되어 게임이 종료된다."}]},{"inlineContent":[{"type":"text","text":"이 경우 "},{"type":"codeVoice","code":"while"},{"type":"text","text":" 반복문이 적합하다. 왜냐하면 게임의 길이가 "},{"type":"codeVoice","code":"while"},{"text":" 반복문 시작 시점에 명확하지 않기 때문이다. 대신, 특정 조건이 충족될 때까지 반복문이 실행된다.","type":"text"}],"type":"paragraph"},{"level":3,"anchor":"Repeat-While","text":"Repeat-While","type":"heading"},{"inlineContent":[{"code":"while","type":"codeVoice"},{"text":" 루프의 다른 형태인 ","type":"text"},{"code":"repeat","type":"codeVoice"},{"text":"-","type":"text"},{"type":"codeVoice","code":"while"},{"type":"text","text":" 루프는"},{"type":"text","text":"\n"},{"type":"text","text":"루프 블록을 먼저 한 번 실행한 후에"},{"text":"\n","type":"text"},{"text":"조건을 평가한다.","type":"text"},{"text":"\n","type":"text"},{"type":"text","text":"그런 다음 조건이 "},{"code":"false","type":"codeVoice"},{"type":"text","text":"가 될 때까지 루프를 반복한다."}],"type":"paragraph"},{"style":"note","type":"aside","name":"참고","content":[{"inlineContent":[{"text":"Swift의 ","type":"text"},{"type":"codeVoice","code":"repeat"},{"text":"-","type":"text"},{"type":"codeVoice","code":"while"},{"type":"text","text":" 루프는"},{"type":"text","text":"\n"},{"text":"다른 언어의 ","type":"text"},{"code":"do","type":"codeVoice"},{"text":"-","type":"text"},{"type":"codeVoice","code":"while"},{"text":" 루프와 유사하다.","type":"text"}],"type":"paragraph"}]},{"type":"paragraph","inlineContent":[{"code":"repeat","type":"codeVoice"},{"type":"text","text":"-"},{"code":"while","type":"codeVoice"},{"text":" 루프의 일반적인 형태는 다음과 같다:","type":"text"}]},{"code":["repeat {","   <#statements#>","} while <#condition#>"],"type":"codeListing","syntax":"swift"},{"type":"paragraph","inlineContent":[{"type":"text","text":"다음은 "},{"inlineContent":[{"type":"text","text":"Snakes and Ladders"}],"type":"emphasis"},{"text":" 예제를 ","type":"text"},{"type":"codeVoice","code":"while"},{"type":"text","text":" 루프 대신"},{"type":"text","text":"\n"},{"type":"codeVoice","code":"repeat"},{"text":"-","type":"text"},{"type":"codeVoice","code":"while"},{"type":"text","text":" 루프로 작성한 것이다."},{"text":"\n","type":"text"},{"code":"finalSquare","type":"codeVoice"},{"type":"text","text":", "},{"type":"codeVoice","code":"board"},{"type":"text","text":", "},{"code":"square","type":"codeVoice"},{"type":"text","text":", "},{"type":"codeVoice","code":"diceRoll"},{"type":"text","text":"의 값은"},{"text":"\n","type":"text"},{"code":"while","type":"codeVoice"},{"type":"text","text":" 루프와 동일한 방식으로 초기화된다."}]},{"type":"codeListing","syntax":"swift","code":["let finalSquare = 25","var board = [Int](repeating: 0, count: finalSquare + 1)","board[03] = +08; board[06] = +11; board[09] = +09; board[10] = +02","board[14] = -10; board[19] = -11; board[22] = -02; board[24] = -08","var square = 0","var diceRoll = 0"]},{"type":"paragraph","inlineContent":[{"text":"이 버전의 게임에서는 루프의 첫 번째 동작으로","type":"text"},{"type":"text","text":"\n"},{"type":"text","text":"사다리나 뱀을 확인한다."},{"type":"text","text":"\n"},{"type":"text","text":"보드에서 사다리를 타고 바로 25칸으로 이동할 수 없기 때문에"},{"text":"\n","type":"text"},{"text":"사다리를 타고 게임에서 이길 수 없다.","type":"text"},{"type":"text","text":"\n"},{"text":"따라서 루프의 첫 번째 동작으로 뱀이나 사다리를 확인해도 안전하다.","type":"text"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"게임 시작 시 플레이어는 “0번 칸”에 위치한다."},{"type":"text","text":"\n"},{"code":"board[0]","type":"codeVoice"},{"text":"은 항상 ","type":"text"},{"code":"0","type":"codeVoice"},{"type":"text","text":"이며 아무런 영향을 미치지 않는다."}]},{"code":["repeat {","    \/\/ 뱀이나 사다리를 확인해 이동","    square += board[square]","    \/\/ 주사위를 굴림","    diceRoll += 1","    if diceRoll == 7 { diceRoll = 1 }","    \/\/ 주사위 결과만큼 이동","    square += diceRoll","} while square < finalSquare","print(\"Game over!\")"],"type":"codeListing","syntax":"swift"},{"inlineContent":[{"type":"text","text":"뱀과 사다리를 확인한 후,"},{"type":"text","text":"\n"},{"type":"text","text":"주사위를 굴리고 플레이어를 "},{"code":"diceRoll","type":"codeVoice"},{"type":"text","text":"만큼 이동시킨다."},{"type":"text","text":"\n"},{"type":"text","text":"그런 다음 현재 루프 실행이 종료된다."}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"type":"text","text":"루프의 조건("},{"code":"while square < finalSquare","type":"codeVoice"},{"type":"text","text":")은 이전과 동일하지만,"},{"text":"\n","type":"text"},{"text":"이번에는 첫 번째 루프 실행이 끝난 후에 평가된다.","type":"text"},{"text":"\n","type":"text"},{"type":"codeVoice","code":"repeat"},{"text":"-","type":"text"},{"code":"while","type":"codeVoice"},{"text":" 루프의 구조는 이 게임에 더 적합하다.","type":"text"},{"type":"text","text":"\n"},{"type":"text","text":"위의 "},{"type":"codeVoice","code":"repeat"},{"text":"-","type":"text"},{"type":"codeVoice","code":"while"},{"type":"text","text":" 루프에서"},{"text":"\n","type":"text"},{"type":"codeVoice","code":"square += board[square]"},{"text":"는 루프의 ","type":"text"},{"type":"codeVoice","code":"while"},{"text":" 조건이","type":"text"},{"text":"\n","type":"text"},{"type":"codeVoice","code":"square"},{"text":"가 여전히 보드 위에 있음을 확인한 후에 항상 즉시 실행된다.","type":"text"},{"text":"\n","type":"text"},{"text":"이 동작은 이전에 설명한 ","type":"text"},{"code":"while","type":"codeVoice"},{"type":"text","text":" 루프 버전에서 필요한"},{"text":"\n","type":"text"},{"type":"text","text":"배열 경계 확인을 제거한다."}]},{"text":"조건문","level":2,"type":"heading","anchor":"%EC%A1%B0%EA%B1%B4%EB%AC%B8"},{"inlineContent":[{"type":"text","text":"특정 조건에 따라 서로 다른 코드를 실행하는 기능은 매우 유용하다. 오류 발생 시 추가 코드를 실행하거나, 값이 너무 높거나 낮을 때 메시지를 표시하는 등의 작업이 필요할 수 있다. 이를 위해 코드의 일부를 "},{"type":"emphasis","inlineContent":[{"text":"조건부","type":"text"}]},{"type":"text","text":"로 작성한다."}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"text":"Swift는 조건 분기를 추가하기 위해 두 가지 방법을 제공한다: ","type":"text"},{"code":"if","type":"codeVoice"},{"text":" 문과 ","type":"text"},{"type":"codeVoice","code":"switch"},{"type":"text","text":" 문이다. 일반적으로 "},{"code":"if","type":"codeVoice"},{"type":"text","text":" 문은 가능한 결과가 몇 가지뿐인 간단한 조건을 평가할 때 사용한다. "},{"code":"switch","type":"codeVoice"},{"type":"text","text":" 문은 여러 가능성과 복잡한 조건에 더 적합하며, 패턴 매칭을 통해 실행할 적절한 코드 분기를 선택할 때 유용하다."}]},{"type":"heading","anchor":"If","level":3,"text":"If"},{"inlineContent":[{"text":"가장 간단한 형태의 ","type":"text"},{"code":"if","type":"codeVoice"},{"text":" 문은 단일 조건을 가진다. 이 조건이 ","type":"text"},{"code":"true","type":"codeVoice"},{"type":"text","text":"일 때만 특정 문장을 실행한다."}],"type":"paragraph"},{"code":["var temperatureInFahrenheit = 30","if temperatureInFahrenheit <= 32 {","    print(\"It's very cold. Consider wearing a scarf.\")","}","\/\/ Prints \"It's very cold. Consider wearing a scarf.\""],"type":"codeListing","syntax":"swift"},{"inlineContent":[{"type":"text","text":"위 예제는 온도가 32도 화씨(물의 어는점) 이하인지 확인한다. 만약 그렇다면 메시지를 출력한다. 그렇지 않으면 메시지를 출력하지 않고 "},{"type":"codeVoice","code":"if"},{"text":" 문의 닫는 중괄호 이후로 코드 실행이 계속된다.","type":"text"}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"code":"if","type":"codeVoice"},{"text":" 문은 ","type":"text"},{"type":"codeVoice","code":"if"},{"type":"text","text":" 조건이 "},{"type":"codeVoice","code":"false"},{"text":"일 때 실행할 대체 문장을 제공할 수 있다. 이를 ","type":"text"},{"type":"emphasis","inlineContent":[{"type":"text","text":"else 절"}]},{"text":"이라고 하며, ","type":"text"},{"type":"codeVoice","code":"else"},{"type":"text","text":" 키워드로 표시한다."}]},{"syntax":"swift","code":["temperatureInFahrenheit = 40","if temperatureInFahrenheit <= 32 {","    print(\"It's very cold. Consider wearing a scarf.\")","} else {","    print(\"It's not that cold. Wear a T-shirt.\")","}","\/\/ Prints \"It's not that cold. Wear a T-shirt.\""],"type":"codeListing"},{"type":"paragraph","inlineContent":[{"type":"text","text":"이 두 가지 중 하나는 항상 실행된다. 온도가 40도 화씨로 올라가면 스카프를 권장할 만큼 춥지 않으므로 "},{"type":"codeVoice","code":"else"},{"text":" 절이 실행된다.","type":"text"}]},{"inlineContent":[{"type":"text","text":"여러 "},{"type":"codeVoice","code":"if"},{"type":"text","text":" 문을 연결하여 추가 조건을 고려할 수 있다."}],"type":"paragraph"},{"code":["temperatureInFahrenheit = 90","if temperatureInFahrenheit <= 32 {","    print(\"It's very cold. Consider wearing a scarf.\")","} else if temperatureInFahrenheit >= 86 {","    print(\"It's really warm. Don't forget to wear sunscreen.\")","} else {","    print(\"It's not that cold. Wear a T-shirt.\")","}","\/\/ Prints \"It's really warm. Don't forget to wear sunscreen.\""],"type":"codeListing","syntax":"swift"},{"type":"paragraph","inlineContent":[{"type":"text","text":"여기서는 특히 따뜻한 온도에 대응하기 위해 추가 "},{"type":"codeVoice","code":"if"},{"type":"text","text":" 문을 넣었다. 마지막 "},{"code":"else","type":"codeVoice"},{"type":"text","text":" 절은 남아 있으며, 너무 춥거나 덥지 않은 온도에 대한 응답을 출력한다."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"그러나 마지막 "},{"code":"else","type":"codeVoice"},{"type":"text","text":" 절은 선택 사항이며, 조건 집합이 완전할 필요가 없는 경우 생략할 수 있다."}]},{"type":"codeListing","syntax":"swift","code":["temperatureInFahrenheit = 72","if temperatureInFahrenheit <= 32 {","    print(\"It's very cold. Consider wearing a scarf.\")","} else if temperatureInFahrenheit >= 86 {","    print(\"It's really warm. Don't forget to wear sunscreen.\")","}"]},{"inlineContent":[{"type":"text","text":"온도가 "},{"type":"codeVoice","code":"if"},{"type":"text","text":" 조건을 트리거할 만큼 춥지도 않고 "},{"code":"else if","type":"codeVoice"},{"text":" 조건을 트리거할 만큼 따뜻하지도 않으므로 메시지가 출력되지 않는다.","type":"text"}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Swift는 값을 설정할 때 사용할 수 있는 "},{"type":"codeVoice","code":"if"},{"type":"text","text":"의 간단한 표현을 제공한다. 예를 들어, 다음 코드를 살펴보자:"}]},{"syntax":"swift","type":"codeListing","code":["let temperatureInCelsius = 25","let weatherAdvice: String","","if temperatureInCelsius <= 0 {","    weatherAdvice = \"It's very cold. Consider wearing a scarf.\"","} else if temperatureInCelsius >= 30 {","    weatherAdvice = \"It's really warm. Don't forget to wear sunscreen.\"","} else {","    weatherAdvice = \"It's not that cold. Wear a T-shirt.\"","}","","print(weatherAdvice)","\/\/ Prints \"It's not that cold. Wear a T-shirt.\""]},{"inlineContent":[{"text":"여기서 각 분기는 ","type":"text"},{"code":"weatherAdvice","type":"codeVoice"},{"text":" 상수에 값을 설정하며, ","type":"text"},{"code":"if","type":"codeVoice"},{"type":"text","text":" 문 이후에 이를 출력한다."}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"type":"codeVoice","code":"if"},{"type":"text","text":" 표현식이라고 하는 대체 구문을 사용하면 이 코드를 더 간결하게 작성할 수 있다:"}]},{"code":["let weatherAdvice = if temperatureInCelsius <= 0 {","    \"It's very cold. Consider wearing a scarf.\"","} else if temperatureInCelsius >= 30 {","    \"It's really warm. Don't forget to wear sunscreen.\"","} else {","    \"It's not that cold. Wear a T-shirt.\"","}","","print(weatherAdvice)","\/\/ Prints \"It's not that cold. Wear a T-shirt.\""],"type":"codeListing","syntax":"swift"},{"inlineContent":[{"text":"이 ","type":"text"},{"code":"if","type":"codeVoice"},{"type":"text","text":" 표현식 버전에서 각 분기는 단일 값을 포함한다. 분기의 조건이 "},{"type":"codeVoice","code":"true"},{"type":"text","text":"이면 해당 분기의 값이 "},{"code":"weatherAdvice","type":"codeVoice"},{"type":"text","text":" 할당을 위한 전체 "},{"code":"if","type":"codeVoice"},{"type":"text","text":" 표현식의 값으로 사용된다. 모든 "},{"type":"codeVoice","code":"if"},{"text":" 분기에는 해당하는 ","type":"text"},{"type":"codeVoice","code":"else if"},{"type":"text","text":" 분기나 "},{"type":"codeVoice","code":"else"},{"text":" 분기가 있어, 항상 하나의 분기가 일치하도록 보장하며, ","type":"text"},{"type":"codeVoice","code":"if"},{"text":" 표현식이 항상 값을 생성하도록 한다.","type":"text"}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"text":"할당 구문이 ","type":"text"},{"type":"codeVoice","code":"if"},{"type":"text","text":" 표현식 외부에서 시작하기 때문에 각 분기 내부에서 "},{"type":"codeVoice","code":"weatherAdvice ="},{"type":"text","text":"를 반복할 필요가 없다. 대신, "},{"code":"if","type":"codeVoice"},{"type":"text","text":" 표현식의 각 분기가 "},{"code":"weatherAdvice","type":"codeVoice"},{"type":"text","text":"의 세 가지 가능한 값 중 하나를 생성하며, 할당은 그 값을 사용한다."}]},{"inlineContent":[{"type":"codeVoice","code":"if"},{"type":"text","text":" 표현식의 모든 분기는 동일한 타입의 값을 포함해야 한다. Swift는 각 분기의 타입을 개별적으로 확인하므로, "},{"type":"codeVoice","code":"nil"},{"text":"과 같이 여러 타입과 함께 사용할 수 있는 값은 Swift가 ","type":"text"},{"type":"codeVoice","code":"if"},{"text":" 표현식의 타입을 자동으로 결정하는 것을 방해한다. 대신, 타입을 명시적으로 지정해야 한다. 예를 들면:","type":"text"}],"type":"paragraph"},{"syntax":"swift","type":"codeListing","code":["let freezeWarning: String? = if temperatureInCelsius <= 0 {","    \"It's below freezing. Watch for ice!\"","} else {","    nil","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"위 코드에서 "},{"type":"codeVoice","code":"if"},{"text":" 표현식의 한 분기는 문자열 값을 가지고 다른 분기는 ","type":"text"},{"code":"nil","type":"codeVoice"},{"type":"text","text":" 값을 가진다. "},{"code":"nil","type":"codeVoice"},{"text":" 값은 모든 옵셔널 타입의 값으로 사용할 수 있으므로, ","type":"text"},{"code":"freezeWarning","type":"codeVoice"},{"type":"text","text":"이 옵셔널 문자열임을 명시적으로 작성해야 한다. 이는 "},{"type":"text","text":"doc:TheBasics#Type-Annotations"},{"type":"text","text":"에서 설명한 바와 같다."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"이 타입 정보를 제공하는 또 다른 방법은 "},{"type":"codeVoice","code":"freezeWarning"},{"text":"에 명시적 타입을 제공하는 대신, ","type":"text"},{"type":"codeVoice","code":"nil"},{"type":"text","text":"에 명시적 타입을 제공하는 것이다:"}]},{"syntax":"swift","code":["let freezeWarning = if temperatureInCelsius <= 0 {","    \"It's below freezing. Watch for ice!\"","} else {","    nil as String?","}"],"type":"codeListing"},{"inlineContent":[{"type":"codeVoice","code":"if"},{"type":"text","text":" 표현식은 예기치 않은 실패에 대해 에러를 던지거나 "},{"type":"codeVoice","code":"fatalError(_:file:line:)"},{"type":"text","text":"과 같이 절대 반환하지 않는 함수를 호출함으로써 대응할 수 있다. 예를 들어:"}],"type":"paragraph"},{"type":"codeListing","code":["let weatherAdvice = if temperatureInCelsius > 100 {","    throw TemperatureError.boiling","} else {","    \"It's a reasonable temperature.\"","}"],"syntax":"swift"},{"type":"paragraph","inlineContent":[{"type":"text","text":"이 예제에서 "},{"code":"if","type":"codeVoice"},{"text":" 표현식은 예측된 온도가 100°C(물의 끓는점)보다 높은지 확인한다. 이렇게 뜨거운 온도는 텍스트 요약을 반환하는 대신 ","type":"text"},{"code":".boiling","type":"codeVoice"},{"type":"text","text":" 에러를 던지도록 한다. 이 "},{"type":"codeVoice","code":"if"},{"text":" 표현식이 에러를 던질 수 있음에도 불구하고, 앞에 ","type":"text"},{"code":"try","type":"codeVoice"},{"type":"text","text":"를 작성할 필요는 없다. 에러 처리에 대한 자세한 내용은 "},{"isActive":true,"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/ErrorHandling","type":"reference"},{"type":"text","text":"을 참조하라."}]},{"inlineContent":[{"text":"위 예제에서 보여준 것처럼 할당의 오른쪽에서 ","type":"text"},{"code":"if","type":"codeVoice"},{"text":" 표현식을 사용하는 것 외에도, 함수나 클로저가 반환하는 값으로도 사용할 수 있다.","type":"text"}],"type":"paragraph"},{"type":"heading","text":"Switch","anchor":"Switch","level":3},{"type":"paragraph","inlineContent":[{"type":"codeVoice","code":"switch"},{"type":"text","text":" 문은 특정 값을 고려하여 여러 가능한 패턴과 비교한다. 그리고 첫 번째로 일치하는 패턴에 따라 적절한 코드 블록을 실행한다. "},{"type":"codeVoice","code":"switch"},{"type":"text","text":" 문은 여러 잠재적 상태에 대응하기 위해 "},{"code":"if","type":"codeVoice"},{"type":"text","text":" 문의 대안으로 사용할 수 있다."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"가장 간단한 형태의 "},{"code":"switch","type":"codeVoice"},{"type":"text","text":" 문은 하나의 값을 동일한 타입의 하나 이상의 값과 비교한다."}]},{"code":["switch <#고려할 값#> {","case <#값 1#>:","    <#값 1에 대응하는 코드#>","case <#값 2#>,","    <#값 3#>:","    <#값 2 또는 3에 대응하는 코드#>","default:","    <#그 외의 경우 실행할 코드#>","}"],"syntax":"swift","type":"codeListing"},{"type":"paragraph","inlineContent":[{"type":"text","text":"모든 "},{"type":"codeVoice","code":"switch"},{"text":" 문은 여러 개의 가능한 ","type":"text"},{"type":"emphasis","inlineContent":[{"type":"text","text":"케이스"}]},{"type":"text","text":"로 구성되며, 각 케이스는 "},{"code":"case","type":"codeVoice"},{"type":"text","text":" 키워드로 시작한다. Swift는 특정 값과 비교하는 것 외에도, 각 케이스에서 더 복잡한 매칭 패턴을 지정할 수 있는 여러 방법을 제공한다. 이러한 옵션은 이 장의 후반부에서 설명한다."}]},{"type":"paragraph","inlineContent":[{"type":"codeVoice","code":"if"},{"text":" 문의 본문과 마찬가지로, 각 ","type":"text"},{"type":"codeVoice","code":"case"},{"type":"text","text":"는 별도의 코드 실행 분기이다. "},{"type":"codeVoice","code":"switch"},{"text":" 문은 어떤 분기를 선택할지 결정한다. 이 과정은 고려 중인 값에 대해 ","type":"text"},{"type":"emphasis","inlineContent":[{"type":"text","text":"스위칭"}]},{"text":"한다고 표현한다.","type":"text"}]},{"inlineContent":[{"type":"text","text":"모든 "},{"type":"codeVoice","code":"switch"},{"type":"text","text":" 문은 "},{"inlineContent":[{"text":"완전해야 한다","type":"text"}],"type":"emphasis"},{"type":"text","text":". 즉, 고려 중인 타입의 모든 가능한 값이 "},{"type":"codeVoice","code":"switch"},{"type":"text","text":"의 케이스 중 하나와 일치해야 한다. 모든 가능한 값에 대해 케이스를 제공하는 것이 적절하지 않은 경우, 명시적으로 처리되지 않은 모든 값을 다루기 위해 기본 케이스를 정의할 수 있다. 이 기본 케이스는 "},{"code":"default","type":"codeVoice"},{"type":"text","text":" 키워드로 표시되며, 항상 마지막에 위치해야 한다."}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"다음 예제는 "},{"code":"someCharacter","type":"codeVoice"},{"type":"text","text":"라는 단일 소문자 문자를 고려하기 위해 "},{"type":"codeVoice","code":"switch"},{"type":"text","text":" 문을 사용한다:"}],"type":"paragraph"},{"syntax":"swift","code":["let someCharacter: Character = \"z\"","switch someCharacter {","case \"a\":","    print(\"라틴 알파벳의 첫 번째 문자\")","case \"z\":","    print(\"라틴 알파벳의 마지막 문자\")","default:","    print(\"다른 문자\")","}","\/\/ \"라틴 알파벳의 마지막 문자\"를 출력"],"type":"codeListing"},{"type":"paragraph","inlineContent":[{"type":"codeVoice","code":"switch"},{"type":"text","text":" 문의 첫 번째 케이스는 영어 알파벳의 첫 번째 문자인 "},{"type":"codeVoice","code":"a"},{"type":"text","text":"와 일치하고, 두 번째 케이스는 마지막 문자인 "},{"type":"codeVoice","code":"z"},{"type":"text","text":"와 일치한다. "},{"type":"codeVoice","code":"switch"},{"type":"text","text":"는 모든 알파벳 문자뿐만 아니라 모든 가능한 문자에 대해 케이스가 있어야 하므로, 이 "},{"code":"switch","type":"codeVoice"},{"text":" 문은 ","type":"text"},{"type":"codeVoice","code":"a"},{"text":"와 ","type":"text"},{"code":"z","type":"codeVoice"},{"type":"text","text":"를 제외한 모든 문자와 일치시키기 위해 "},{"code":"default","type":"codeVoice"},{"type":"text","text":" 케이스를 사용한다. 이 조치는 "},{"type":"codeVoice","code":"switch"},{"text":" 문이 완전하도록 보장한다.","type":"text"}]},{"type":"paragraph","inlineContent":[{"code":"if","type":"codeVoice"},{"type":"text","text":" 문과 마찬가지로, "},{"code":"switch","type":"codeVoice"},{"type":"text","text":" 문도 표현식 형태를 가질 수 있다:"}]},{"type":"codeListing","syntax":"swift","code":["let anotherCharacter: Character = \"a\"","let message = switch anotherCharacter {","case \"a\":","    \"라틴 알파벳의 첫 번째 문자\"","case \"z\":","    \"라틴 알파벳의 마지막 문자\"","default:","    \"다른 문자\"","}","","print(message)","\/\/ \"라틴 알파벳의 첫 번째 문자\"를 출력"]},{"type":"paragraph","inlineContent":[{"text":"이 예제에서, ","type":"text"},{"code":"switch","type":"codeVoice"},{"type":"text","text":" 표현식의 각 케이스는 "},{"type":"codeVoice","code":"anotherCharacter"},{"type":"text","text":"와 일치할 때 사용할 "},{"type":"codeVoice","code":"message"},{"text":"의 값을 포함한다. ","type":"text"},{"code":"switch","type":"codeVoice"},{"text":"는 항상 완전해야 하므로, 항상 할당할 값이 존재한다.","type":"text"}]},{"type":"paragraph","inlineContent":[{"type":"codeVoice","code":"if"},{"text":" 표현식과 마찬가지로, 특정 케이스에 대한 값을 제공하는 대신 오류를 던지거나 ","type":"text"},{"type":"codeVoice","code":"fatalError(_:file:line:)"},{"text":"와 같이 반환하지 않는 함수를 호출할 수 있다. ","type":"text"},{"code":"switch","type":"codeVoice"},{"type":"text","text":" 표현식은 위 예제와 같이 할당의 오른쪽에 사용할 수 있으며, 함수나 클로저가 반환하는 값으로도 사용할 수 있다."}]},{"anchor":"%EC%95%94%EC%8B%9C%EC%A0%81-%ED%8F%B4%EC%8A%A4%EB%A3%A8-%EC%97%86%EC%9D%8C","type":"heading","text":"암시적 폴스루 없음","level":4},{"type":"paragraph","inlineContent":[{"type":"text","text":"C와 Objective-C의 "},{"type":"codeVoice","code":"switch"},{"text":" 문과 달리,","type":"text"},{"text":"\n","type":"text"},{"type":"text","text":"Swift의 "},{"code":"switch","type":"codeVoice"},{"text":" 문은 기본적으로 한 케이스에서 다음 케이스로 넘어가지 않는다.","type":"text"},{"text":"\n","type":"text"},{"text":"대신, 첫 번째로 일치하는 ","type":"text"},{"type":"codeVoice","code":"switch"},{"text":" 케이스가 실행된 후 전체 ","type":"text"},{"code":"switch","type":"codeVoice"},{"text":" 문이 종료된다.","type":"text"},{"type":"text","text":"\n"},{"type":"text","text":"이때 명시적인 "},{"type":"codeVoice","code":"break"},{"type":"text","text":" 문이 필요하지 않다."},{"type":"text","text":"\n"},{"type":"text","text":"이러한 방식은 C의 "},{"type":"codeVoice","code":"switch"},{"type":"text","text":" 문보다 더 안전하고 사용하기 쉬우며,"},{"text":"\n","type":"text"},{"type":"text","text":"실수로 여러 케이스가 실행되는 것을 방지한다."}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Swift에서는 "},{"type":"codeVoice","code":"break"},{"text":" 문이 필수는 아니지만,","type":"text"},{"text":"\n","type":"text"},{"text":"특정 케이스를 일치시킨 후 무시하거나,","type":"text"},{"type":"text","text":"\n"},{"text":"케이스 실행이 완료되기 전에 빠져나오기 위해 ","type":"text"},{"code":"break","type":"codeVoice"},{"type":"text","text":" 문을 사용할 수 있다."},{"text":"\n","type":"text"},{"type":"text","text":"자세한 내용은 "},{"text":"doc:ControlFlow#Break-in-a-Switch-Statement","type":"text"},{"text":"를 참고하라.","type":"text"}]}],"name":"참고","style":"note","type":"aside"},{"inlineContent":[{"text":"각 케이스의 본문에는 반드시 최소 하나의 실행 가능한 문장이 포함되어야 한다.","type":"text"},{"text":"\n","type":"text"},{"type":"text","text":"다음 코드는 첫 번째 케이스가 비어 있기 때문에 유효하지 않다:"}],"type":"paragraph"},{"type":"codeListing","syntax":"swift","code":["let anotherCharacter: Character = \"a\"","switch anotherCharacter {","case \"a\": \/\/ 유효하지 않음, 케이스 본문이 비어 있음","case \"A\":","    print(\"The letter A\")","default:","    print(\"Not the letter A\")","}","\/\/ 이 코드는 컴파일 타임 오류를 발생시킨다."]},{"inlineContent":[{"text":"C의 ","type":"text"},{"code":"switch","type":"codeVoice"},{"type":"text","text":" 문과 달리,"},{"type":"text","text":"\n"},{"type":"text","text":"이 "},{"type":"codeVoice","code":"switch"},{"type":"text","text":" 문은 "},{"code":"\"a\"","type":"codeVoice"},{"type":"text","text":"와 "},{"code":"\"A\"","type":"codeVoice"},{"type":"text","text":"를 동시에 일치시키지 않는다."},{"type":"text","text":"\n"},{"text":"대신, ","type":"text"},{"type":"codeVoice","code":"case \"a\":"},{"text":"에 실행 가능한 문장이 없다는 컴파일 타임 오류를 발생시킨다.","type":"text"},{"text":"\n","type":"text"},{"text":"이러한 접근 방식은 한 케이스에서 다른 케이스로의 의도치 않은 폴스루를 방지하고,","type":"text"},{"text":"\n","type":"text"},{"text":"코드의 의도를 더 명확하게 만든다.","type":"text"}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"type":"codeVoice","code":"\"a\""},{"type":"text","text":"와 "},{"code":"\"A\"","type":"codeVoice"},{"type":"text","text":"를 모두 일치시키는 단일 케이스를 만들려면,"},{"type":"text","text":"\n"},{"type":"text","text":"두 값을 콤마로 구분하여 복합 케이스로 결합하면 된다."}]},{"type":"codeListing","syntax":"swift","code":["let anotherCharacter: Character = \"a\"","switch anotherCharacter {","case \"a\", \"A\":","    print(\"The letter A\")","default:","    print(\"Not the letter A\")","}","\/\/ \"The letter A\"를 출력한다."]},{"type":"paragraph","inlineContent":[{"type":"text","text":"가독성을 위해 복합 케이스를 여러 줄에 걸쳐 작성할 수도 있다."},{"type":"text","text":"\n"},{"text":"복합 케이스에 대한 자세한 내용은 ","type":"text"},{"type":"text","text":"doc:ControlFlow#Compound-Cases"},{"type":"text","text":"를 참고하라."}]},{"style":"note","content":[{"inlineContent":[{"text":"특정 ","type":"text"},{"code":"switch","type":"codeVoice"},{"type":"text","text":" 케이스의 끝에서 명시적으로 폴스루를 하려면,"},{"type":"text","text":"\n"},{"type":"codeVoice","code":"fallthrough"},{"text":" 키워드를 사용하면 된다.","type":"text"},{"text":"\n","type":"text"},{"text":"자세한 내용은 ","type":"text"},{"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/ControlFlow#Fallthrough","type":"reference","isActive":true},{"type":"text","text":"를 참고하라."}],"type":"paragraph"}],"type":"aside","name":"참고"},{"text":"구간 매칭","type":"heading","anchor":"%EA%B5%AC%EA%B0%84-%EB%A7%A4%EC%B9%AD","level":4},{"type":"paragraph","inlineContent":[{"code":"switch","type":"codeVoice"},{"text":" 문의 각 ","type":"text"},{"code":"case","type":"codeVoice"},{"text":"에서 값이 특정 구간에 포함되는지 확인할 수 있다. 다음 예제는 숫자 구간을 사용해 크기에 상관없이 숫자를 자연어로 표현하는 방법을 보여준다:","type":"text"}]},{"syntax":"swift","type":"codeListing","code":["let approximateCount = 62","let countedThings = \"moons orbiting Saturn\"","let naturalCount: String","switch approximateCount {","case 0:","    naturalCount = \"no\"","case 1..<5:","    naturalCount = \"a few\"","case 5..<12:","    naturalCount = \"several\"","case 12..<100:","    naturalCount = \"dozens of\"","case 100..<1000:","    naturalCount = \"hundreds of\"","default:","    naturalCount = \"many\"","}","print(\"There are \\(naturalCount) \\(countedThings).\")","\/\/ Prints \"There are dozens of moons orbiting Saturn.\""]},{"type":"paragraph","inlineContent":[{"text":"위 예제에서 ","type":"text"},{"code":"approximateCount","type":"codeVoice"},{"text":"는 ","type":"text"},{"code":"switch","type":"codeVoice"},{"type":"text","text":" 문에서 평가된다. 각 "},{"code":"case","type":"codeVoice"},{"type":"text","text":"는 이 값을 숫자나 구간과 비교한다. "},{"type":"codeVoice","code":"approximateCount"},{"type":"text","text":"의 값이 12에서 100 사이에 속하기 때문에 "},{"type":"codeVoice","code":"naturalCount"},{"text":"에는 ","type":"text"},{"code":"\"dozens of\"","type":"codeVoice"},{"type":"text","text":"가 할당되고, "},{"type":"codeVoice","code":"switch"},{"type":"text","text":" 문의 실행이 종료된다."}]},{"type":"heading","anchor":"%ED%8A%9C%ED%94%8C","text":"튜플","level":4},{"inlineContent":[{"text":"튜플을 사용하면 하나의 ","type":"text"},{"code":"switch","type":"codeVoice"},{"text":" 문에서 여러 값을 테스트할 수 있다. 튜플의 각 요소는 서로 다른 값이나 값의 범위와 비교할 수 있다. 또는 와일드카드 패턴으로 알려진 언더스코어 문자(","type":"text"},{"type":"codeVoice","code":"_"},{"text":")를 사용해 모든 가능한 값과 일치시킬 수도 있다.","type":"text"}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"type":"text","text":"아래 예제는 "},{"type":"codeVoice","code":"(Int, Int)"},{"text":" 타입의 간단한 튜플로 표현된 (x, y) 좌표를 받아 그래프 상에서 해당 점을 분류한다.","type":"text"}]},{"type":"codeListing","syntax":"swift","code":["let somePoint = (1, 1)","switch somePoint {","case (0, 0):","    print(\"\\(somePoint) is at the origin\")","case (_, 0):","    print(\"\\(somePoint) is on the x-axis\")","case (0, _):","    print(\"\\(somePoint) is on the y-axis\")","case (-2...2, -2...2):","    print(\"\\(somePoint) is inside the box\")","default:","    print(\"\\(somePoint) is outside of the box\")","}","\/\/ Prints \"(1, 1) is inside the box\""]},{"type":"paragraph","inlineContent":[{"type":"image","identifier":"coordinateGraphSimple"}]},{"inlineContent":[{"text":"이 ","type":"text"},{"type":"codeVoice","code":"switch"},{"type":"text","text":" 문은 해당 점이 원점 (0, 0)에 있는지, 빨간색 x축 위에 있는지, 초록색 y축 위에 있는지, 원점을 중심으로 한 파란색 4x4 박스 안에 있는지, 아니면 박스 밖에 있는지를 판단한다."}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"text":"C 언어와 달리 Swift는 여러 ","type":"text"},{"type":"codeVoice","code":"switch"},{"type":"text","text":" 케이스가 동일한 값을 고려하도록 허용한다. 사실 이 예제에서 점 (0, 0)은 네 가지 케이스 모두와 일치할 수 있다. 그러나 여러 케이스가 일치할 가능성이 있으면 항상 첫 번째로 일치하는 케이스가 사용된다. 따라서 점 (0, 0)은 "},{"code":"case (0, 0)","type":"codeVoice"},{"text":"와 먼저 일치하며, 나머지 일치하는 케이스는 무시된다.","type":"text"}]},{"anchor":"%EA%B0%92-%EB%B0%94%EC%9D%B8%EB%94%A9","level":4,"text":"값 바인딩","type":"heading"},{"type":"paragraph","inlineContent":[{"code":"switch","type":"codeVoice"},{"text":" 케이스는 매칭되는 값을 임시 상수나 변수에 할당할 수 있다. 이렇게 하면 케이스 본문에서 해당 값을 사용할 수 있다. 이 동작을 ","type":"text"},{"type":"emphasis","inlineContent":[{"text":"값 바인딩","type":"text"}]},{"type":"text","text":"이라고 부르며, 케이스 본문 내에서 임시 상수나 변수에 값이 바인딩된다."}]},{"inlineContent":[{"text":"아래 예제는 ","type":"text"},{"type":"codeVoice","code":"(Int, Int)"},{"type":"text","text":" 타입의 튜플로 표현된 (x, y) 좌표를 받아 그래프 상에서 분류한다:"}],"type":"paragraph"},{"syntax":"swift","type":"codeListing","code":["let anotherPoint = (2, 0)","switch anotherPoint {","case (let x, 0):","    print(\"x축 위에 있으며 x 값은 \\(x)입니다.\")","case (0, let y):","    print(\"y축 위에 있으며 y 값은 \\(y)입니다.\")","case let (x, y):","    print(\"다른 위치에 있으며 좌표는 (\\(x), \\(y))입니다.\")","}","\/\/ \"x축 위에 있으며 x 값은 2입니다.\" 출력"]},{"type":"paragraph","inlineContent":[{"type":"image","identifier":"coordinateGraphMedium"}]},{"type":"paragraph","inlineContent":[{"text":"이 ","type":"text"},{"type":"codeVoice","code":"switch"},{"text":" 문은 점이 빨간색 x축 위에 있는지, 초록색 y축 위에 있는지, 아니면 다른 위치에 있는지 판단한다.","type":"text"}]},{"inlineContent":[{"text":"세 ","type":"text"},{"type":"codeVoice","code":"switch"},{"type":"text","text":" 케이스는 플레이스홀더 상수 "},{"type":"codeVoice","code":"x"},{"text":"와 ","type":"text"},{"type":"codeVoice","code":"y"},{"text":"를 선언하며, 이 상수는 ","type":"text"},{"code":"anotherPoint","type":"codeVoice"},{"text":"의 튜플 값을 임시로 받는다. 첫 번째 케이스인 ","type":"text"},{"code":"case (let x, 0)","type":"codeVoice"},{"text":"는 ","type":"text"},{"code":"y","type":"codeVoice"},{"text":" 값이 ","type":"text"},{"code":"0","type":"codeVoice"},{"type":"text","text":"인 모든 점에 매칭되며, 점의 "},{"type":"codeVoice","code":"x"},{"text":" 값을 임시 상수 ","type":"text"},{"type":"codeVoice","code":"x"},{"type":"text","text":"에 할당한다. 마찬가지로 두 번째 케이스인 "},{"type":"codeVoice","code":"case (0, let y)"},{"text":"는 ","type":"text"},{"code":"x","type":"codeVoice"},{"type":"text","text":" 값이 "},{"code":"0","type":"codeVoice"},{"type":"text","text":"인 모든 점에 매칭되며, 점의 "},{"type":"codeVoice","code":"y"},{"text":" 값을 임시 상수 ","type":"text"},{"type":"codeVoice","code":"y"},{"type":"text","text":"에 할당한다."}],"type":"paragraph"},{"inlineContent":[{"text":"임시 상수가 선언되면, 해당 케이스의 코드 블록 내에서 사용할 수 있다. 여기서는 점의 위치를 분류해 출력하는 데 사용된다.","type":"text"}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"text":"이 ","type":"text"},{"code":"switch","type":"codeVoice"},{"type":"text","text":" 문에는 "},{"type":"codeVoice","code":"default"},{"type":"text","text":" 케이스가 없다. 마지막 케이스인 "},{"code":"case let (x, y)","type":"codeVoice"},{"type":"text","text":"는 모든 값에 매칭될 수 있는 두 개의 플레이스홀더 상수를 선언한다. "},{"type":"codeVoice","code":"anotherPoint"},{"type":"text","text":"는 항상 두 개의 값으로 이루어진 튜플이기 때문에, 이 케이스는 모든 가능한 나머지 값에 매칭된다. 따라서 "},{"type":"codeVoice","code":"switch"},{"type":"text","text":" 문이 모든 경우를 커버하기 위해 "},{"code":"default","type":"codeVoice"},{"text":" 케이스가 필요하지 않다.","type":"text"}]},{"text":"Where","type":"heading","level":4,"anchor":"Where"},{"inlineContent":[{"code":"switch","type":"codeVoice"},{"type":"text","text":" 케이스는 추가 조건을 확인하기 위해 "},{"type":"codeVoice","code":"where"},{"type":"text","text":" 절을 사용할 수 있다."}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"type":"text","text":"아래 예제는 (x, y) 점을 그래프 상에서 다음과 같이 분류한다:"}]},{"syntax":"swift","code":["let yetAnotherPoint = (1, -1)","switch yetAnotherPoint {","case let (x, y) where x == y:","    print(\"(\\(x), \\(y)) is on the line x == y\")","case let (x, y) where x == -y:","    print(\"(\\(x), \\(y)) is on the line x == -y\")","case let (x, y):","    print(\"(\\(x), \\(y)) is just some arbitrary point\")","}","\/\/ Prints \"(1, -1) is on the line x == -y\""],"type":"codeListing"},{"inlineContent":[{"type":"image","identifier":"coordinateGraphComplex"}],"type":"paragraph"},{"inlineContent":[{"code":"switch","type":"codeVoice"},{"type":"text","text":" 문은 점이 "},{"code":"x == y","type":"codeVoice"},{"type":"text","text":"인 초록색 대각선 위에 있는지, "},{"type":"codeVoice","code":"x == -y"},{"text":"인 보라색 대각선 위에 있는지, 아니면 둘 다 아닌지를 판단한다.","type":"text"}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"text":"세 개의 ","type":"text"},{"type":"codeVoice","code":"switch"},{"text":" 케이스는 ","type":"text"},{"code":"yetAnotherPoint","type":"codeVoice"},{"text":"의 두 튜플 값을 임시로 받는 ","type":"text"},{"code":"x","type":"codeVoice"},{"type":"text","text":"와 "},{"type":"codeVoice","code":"y"},{"type":"text","text":"라는 상수를 선언한다. 이 상수들은 동적 필터를 생성하기 위해 "},{"type":"codeVoice","code":"where"},{"type":"text","text":" 절의 일부로 사용된다. "},{"code":"switch","type":"codeVoice"},{"type":"text","text":" 케이스는 "},{"type":"codeVoice","code":"where"},{"type":"text","text":" 절의 조건이 해당 값에 대해 "},{"code":"true","type":"codeVoice"},{"type":"text","text":"로 평가될 때만 현재 "},{"code":"point","type":"codeVoice"},{"type":"text","text":" 값과 일치한다."}]},{"type":"paragraph","inlineContent":[{"text":"이전 예제와 마찬가지로, 마지막 케이스는 가능한 모든 나머지 값과 일치하므로 ","type":"text"},{"type":"codeVoice","code":"switch"},{"type":"text","text":" 문을 완전히 만들기 위해 "},{"type":"codeVoice","code":"default"},{"text":" 케이스가 필요하지 않다.","type":"text"}]},{"anchor":"%EB%B3%B5%ED%95%A9-%EC%BC%80%EC%9D%B4%EC%8A%A4","text":"복합 케이스","level":4,"type":"heading"},{"type":"paragraph","inlineContent":[{"type":"text","text":"동일한 본문을 공유하는 여러 "},{"code":"switch","type":"codeVoice"},{"type":"text","text":" 케이스는 "},{"code":"case","type":"codeVoice"},{"type":"text","text":" 뒤에 여러 패턴을 쉼표로 구분하여 결합할 수 있다. 패턴 중 하나라도 일치하면 해당 케이스가 일치한 것으로 간주한다. 패턴 목록이 길 경우 여러 줄에 걸쳐 작성할 수도 있다. 예를 들어:"}]},{"code":["let someCharacter: Character = \"e\"","switch someCharacter {","case \"a\", \"e\", \"i\", \"o\", \"u\":","    print(\"\\(someCharacter) is a vowel\")","case \"b\", \"c\", \"d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\",","    \"n\", \"p\", \"q\", \"r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\":","    print(\"\\(someCharacter) is a consonant\")","default:","    print(\"\\(someCharacter) isn't a vowel or a consonant\")","}","\/\/ Prints \"e is a vowel\""],"type":"codeListing","syntax":"swift"},{"type":"paragraph","inlineContent":[{"type":"text","text":"위 "},{"type":"codeVoice","code":"switch"},{"type":"text","text":" 문의 첫 번째 케이스는 영어의 다섯 개 소문자 모음을 모두 매칭한다. 마찬가지로 두 번째 케이스는 영어 소문자 자음을 모두 매칭한다. 마지막으로 "},{"code":"default","type":"codeVoice"},{"type":"text","text":" 케이스는 그 외의 문자를 매칭한다."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"복합 케이스는 값 바인딩도 포함할 수 있다. 복합 케이스의 모든 패턴은 동일한 값 바인딩 집합을 포함해야 하며, 각 바인딩은 복합 케이스의 모든 패턴에서 동일한 타입의 값을 가져와야 한다. 이를 통해 복합 케이스의 어느 부분이 일치하든 상관없이 케이스 본문의 코드가 항상 바인딩된 값에 접근할 수 있고, 그 값의 타입도 항상 동일하게 유지된다."}]},{"syntax":"swift","code":["let stillAnotherPoint = (9, 0)","switch stillAnotherPoint {","case (let distance, 0), (0, let distance):","    print(\"On an axis, \\(distance) from the origin\")","default:","    print(\"Not on an axis\")","}","\/\/ Prints \"On an axis, 9 from the origin\""],"type":"codeListing"},{"type":"paragraph","inlineContent":[{"text":"위 ","type":"text"},{"type":"codeVoice","code":"case"},{"type":"text","text":"는 두 가지 패턴을 가진다: "},{"type":"codeVoice","code":"(let distance, 0)"},{"text":"는 x축 상의 점을 매칭하고, ","type":"text"},{"code":"(0, let distance)","type":"codeVoice"},{"text":"는 y축 상의 점을 매칭한다. 두 패턴 모두 ","type":"text"},{"type":"codeVoice","code":"distance"},{"text":"에 대한 바인딩을 포함하며, ","type":"text"},{"code":"distance","type":"codeVoice"},{"type":"text","text":"는 두 패턴 모두 정수 타입이다. 따라서 "},{"code":"case","type":"codeVoice"},{"type":"text","text":" 본문의 코드는 항상 "},{"type":"codeVoice","code":"distance"},{"text":"의 값에 접근할 수 있다.","type":"text"}]},{"type":"heading","text":"제어 흐름 변경문","anchor":"%EC%A0%9C%EC%96%B4-%ED%9D%90%EB%A6%84-%EB%B3%80%EA%B2%BD%EB%AC%B8","level":2},{"type":"paragraph","inlineContent":[{"type":"emphasis","inlineContent":[{"type":"text","text":"제어 흐름 변경문"}]},{"type":"text","text":"은 코드의 실행 순서를 변경하며, 특정 코드에서 다른 코드로 제어를 넘기는 역할을 한다. Swift는 다섯 가지 제어 흐름 변경문을 제공한다:"}]},{"items":[{"content":[{"inlineContent":[{"type":"codeVoice","code":"continue"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"code":"break","type":"codeVoice"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"codeVoice","code":"fallthrough"}]}]},{"content":[{"inlineContent":[{"code":"return","type":"codeVoice"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"code":"throw","type":"codeVoice"}]}]}],"type":"unorderedList"},{"inlineContent":[{"type":"text","text":"이 중 "},{"type":"codeVoice","code":"continue"},{"text":", ","type":"text"},{"type":"codeVoice","code":"break"},{"text":", ","type":"text"},{"type":"codeVoice","code":"fallthrough"},{"type":"text","text":"는 아래에서 설명한다. "},{"type":"codeVoice","code":"return"},{"text":" 문은 ","type":"text"},{"isActive":true,"type":"reference","identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Functions"},{"type":"text","text":"에서, "},{"type":"codeVoice","code":"throw"},{"type":"text","text":" 문은 "},{"text":"doc:ErrorHandling#Propagating-Errors-Using-Throwing-Functions","type":"text"},{"type":"text","text":"에서 자세히 다룬다."}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"code":"continue","type":"codeVoice"},{"text":" 문은 루프가 현재 작업을 멈추고 다음 반복의 시작 부분으로 바로 이동하도록 지시한다. 이는 “현재 루프 반복을 마쳤다”는 의미를 전달하면서도 루프를 완전히 빠져나가지 않는다.","type":"text"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"다음 예제는 소문자 문자열에서 모든 모음과 공백을 제거하여 암호화된 퍼즐 문구를 만든다:"}]},{"type":"codeListing","syntax":"swift","code":["let puzzleInput = \"great minds think alike\"","var puzzleOutput = \"\"","let charactersToRemove: [Character] = [\"a\", \"e\", \"i\", \"o\", \"u\", \" \"]","for character in puzzleInput {","    if charactersToRemove.contains(character) {","        continue","    }","    puzzleOutput.append(character)","}","print(puzzleOutput)","\/\/ Prints \"grtmndsthnklk\""]},{"type":"paragraph","inlineContent":[{"text":"위 코드는 모음이나 공백이 발견될 때마다 ","type":"text"},{"type":"codeVoice","code":"continue"},{"type":"text","text":" 키워드를 호출한다. 이를 통해 현재 루프 반복을 즉시 종료하고 다음 반복의 시작 부분으로 바로 이동한다."}]},{"type":"heading","anchor":"break-%EB%AC%B8","text":"break 문","level":3},{"type":"paragraph","inlineContent":[{"type":"codeVoice","code":"break"},{"text":" 문은 현재 실행 중인 제어 흐름문의 실행을 즉시 종료한다.","type":"text"},{"type":"text","text":"\n"},{"code":"switch","type":"codeVoice"},{"type":"text","text":" 문이나 반복문 안에서 "},{"code":"break","type":"codeVoice"},{"text":" 문을 사용하면,","type":"text"},{"type":"text","text":"\n"},{"text":"해당 ","type":"text"},{"code":"switch","type":"codeVoice"},{"text":" 문이나 반복문의 실행을 원래보다 더 일찍 중단할 수 있다.","type":"text"}]},{"level":4,"type":"heading","anchor":"%EB%B0%98%EB%B3%B5%EB%AC%B8%EC%97%90%EC%84%9C%EC%9D%98-break-%EC%82%AC%EC%9A%A9","text":"반복문에서의 break 사용"},{"inlineContent":[{"text":"반복문 안에서 ","type":"text"},{"type":"codeVoice","code":"break"},{"type":"text","text":"를 사용하면, 반복문의 실행이 즉시 종료되고, 반복문을 닫는 중괄호("},{"code":"}","type":"codeVoice"},{"text":") 이후의 코드로 제어권이 넘어간다. 현재 반복 중인 코드는 더 이상 실행되지 않으며, 반복문의 다음 반복도 시작되지 않는다.","type":"text"}],"type":"paragraph"},{"type":"heading","anchor":"Switch-%EB%AC%B8%EC%97%90%EC%84%9C%EC%9D%98-Break-%EC%82%AC%EC%9A%A9","text":"Switch 문에서의 Break 사용","level":4},{"type":"paragraph","inlineContent":[{"type":"codeVoice","code":"switch"},{"text":" 문 내부에서 ","type":"text"},{"code":"break","type":"codeVoice"},{"type":"text","text":"를 사용하면, "},{"code":"switch","type":"codeVoice"},{"type":"text","text":" 문의 실행이 즉시 종료되고, "},{"type":"codeVoice","code":"switch"},{"text":" 문의 닫는 중괄호(","type":"text"},{"type":"codeVoice","code":"}"},{"type":"text","text":") 이후의 코드로 제어가 이동한다."}]},{"inlineContent":[{"text":"이 동작은 ","type":"text"},{"type":"codeVoice","code":"switch"},{"type":"text","text":" 문에서 하나 이상의 케이스를 일치시켜 무시할 때 유용하다. Swift의 "},{"type":"codeVoice","code":"switch"},{"text":" 문은 모든 가능성을 커버해야 하며, 빈 케이스를 허용하지 않기 때문에, 의도를 명확히 하기 위해 특정 케이스를 일치시켜 무시해야 할 때가 있다. 이때 해당 케이스의 본문 전체를 ","type":"text"},{"type":"codeVoice","code":"break"},{"type":"text","text":" 문으로 작성하면 된다. "},{"type":"codeVoice","code":"switch"},{"type":"text","text":" 문에서 해당 케이스가 일치하면, 케이스 내부의 "},{"type":"codeVoice","code":"break"},{"type":"text","text":" 문이 "},{"type":"codeVoice","code":"switch"},{"type":"text","text":" 문의 실행을 즉시 종료한다."}],"type":"paragraph"},{"style":"note","name":"참고","content":[{"inlineContent":[{"type":"text","text":"주석만 포함된 "},{"code":"switch","type":"codeVoice"},{"type":"text","text":" 케이스는 컴파일 시간 오류로 처리된다. 주석은 문장이 아니므로 "},{"code":"switch","type":"codeVoice"},{"type":"text","text":" 케이스를 무시하게 하지 않는다. "},{"code":"switch","type":"codeVoice"},{"text":" 케이스를 무시하려면 항상 ","type":"text"},{"code":"break","type":"codeVoice"},{"type":"text","text":" 문을 사용해야 한다."}],"type":"paragraph"}],"type":"aside"},{"inlineContent":[{"type":"text","text":"다음 예제는 "},{"type":"codeVoice","code":"Character"},{"type":"text","text":" 값에 대해 "},{"code":"switch","type":"codeVoice"},{"type":"text","text":" 문을 사용하여, 해당 문자가 네 가지 언어 중 하나의 숫자 기호인지 판단한다. 간결성을 위해 여러 값을 하나의 "},{"code":"switch","type":"codeVoice"},{"type":"text","text":" 케이스에서 처리한다."}],"type":"paragraph"},{"code":["let numberSymbol: Character = \"三\"  \/\/ 숫자 3을 나타내는 중국어 기호","var possibleIntegerValue: Int?","switch numberSymbol {","case \"1\", \"١\", \"一\", \"๑\":","    possibleIntegerValue = 1","case \"2\", \"٢\", \"二\", \"๒\":","    possibleIntegerValue = 2","case \"3\", \"٣\", \"三\", \"๓\":","    possibleIntegerValue = 3","case \"4\", \"٤\", \"四\", \"๔\":","    possibleIntegerValue = 4","default:","    break","}","if let integerValue = possibleIntegerValue {","    print(\"The integer value of \\(numberSymbol) is \\(integerValue).\")","} else {","    print(\"An integer value couldn't be found for \\(numberSymbol).\")","}","\/\/ Prints \"The integer value of 三 is 3.\""],"type":"codeListing","syntax":"swift"},{"type":"paragraph","inlineContent":[{"type":"text","text":"이 예제는 "},{"code":"numberSymbol","type":"codeVoice"},{"type":"text","text":"이 라틴어, 아랍어, 중국어, 태국어 중 하나의 숫자 "},{"code":"1","type":"codeVoice"},{"type":"text","text":"부터 "},{"type":"codeVoice","code":"4"},{"type":"text","text":"를 나타내는 기호인지 확인한다. 일치하는 경우, "},{"code":"switch","type":"codeVoice"},{"type":"text","text":" 문의 케이스 중 하나가 "},{"code":"possibleIntegerValue","type":"codeVoice"},{"text":"라는 옵셔널 ","type":"text"},{"code":"Int?","type":"codeVoice"},{"type":"text","text":" 변수에 적절한 정수 값을 할당한다."}]},{"type":"paragraph","inlineContent":[{"type":"codeVoice","code":"switch"},{"type":"text","text":" 문의 실행이 완료된 후, 이 예제는 옵셔널 바인딩을 사용하여 값이 발견되었는지 확인한다. "},{"type":"codeVoice","code":"possibleIntegerValue"},{"type":"text","text":" 변수는 옵셔널 타입이기 때문에 암시적으로 "},{"code":"nil","type":"codeVoice"},{"type":"text","text":"로 초기화되며, 따라서 옵셔널 바인딩은 "},{"code":"possibleIntegerValue","type":"codeVoice"},{"type":"text","text":"가 "},{"type":"codeVoice","code":"switch"},{"type":"text","text":" 문의 처음 네 케이스 중 하나에 의해 실제 값으로 설정된 경우에만 성공한다."}]},{"type":"paragraph","inlineContent":[{"text":"위 예제에서 모든 가능한 ","type":"text"},{"type":"codeVoice","code":"Character"},{"text":" 값을 나열하는 것은 실용적이지 않기 때문에, ","type":"text"},{"type":"codeVoice","code":"default"},{"type":"text","text":" 케이스는 일치하지 않는 모든 문자를 처리한다. 이 "},{"code":"default","type":"codeVoice"},{"text":" 케이스는 어떤 동작도 수행할 필요가 없으므로, 본문을 ","type":"text"},{"code":"break","type":"codeVoice"},{"text":" 문 하나로 작성한다. ","type":"text"},{"code":"default","type":"codeVoice"},{"text":" 케이스가 일치하면, ","type":"text"},{"type":"codeVoice","code":"break"},{"text":" 문이 ","type":"text"},{"code":"switch","type":"codeVoice"},{"type":"text","text":" 문의 실행을 즉시 종료하고, "},{"type":"codeVoice","code":"if let"},{"text":" 문 이후의 코드 실행이 계속된다.","type":"text"}]},{"type":"heading","text":"Fallthrough","anchor":"Fallthrough","level":3},{"inlineContent":[{"type":"text","text":"Swift에서 "},{"type":"codeVoice","code":"switch"},{"type":"text","text":" 문은 각 case의 끝에서 다음 case로 넘어가지 않는다. 즉, 첫 번째로 일치하는 case가 실행되면 전체 "},{"code":"switch","type":"codeVoice"},{"text":" 문의 실행이 완료된다. 반면 C에서는 ","type":"text"},{"type":"codeVoice","code":"switch"},{"text":" case의 끝에 명시적으로 ","type":"text"},{"type":"codeVoice","code":"break"},{"text":" 문을 추가해야 fallthrough를 방지할 수 있다. Swift는 기본적으로 fallthrough를 허용하지 않기 때문에 ","type":"text"},{"type":"codeVoice","code":"switch"},{"type":"text","text":" 문이 더 간결하고 예측 가능하며, 실수로 여러 case가 실행되는 것을 방지할 수 있다."}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"text":"C 스타일의 fallthrough 동작이 필요하다면, ","type":"text"},{"type":"codeVoice","code":"fallthrough"},{"type":"text","text":" 키워드를 사용해 case별로 이 동작을 선택할 수 있다. 아래 예제는 "},{"code":"fallthrough","type":"codeVoice"},{"type":"text","text":"를 사용해 숫자에 대한 설명을 생성한다."}]},{"syntax":"swift","code":["let integerToDescribe = 5","var description = \"The number \\(integerToDescribe) is\"","switch integerToDescribe {","case 2, 3, 5, 7, 11, 13, 17, 19:","    description += \" a prime number, and also\"","    fallthrough","default:","    description += \" an integer.\"","}","print(description)","\/\/ Prints \"The number 5 is a prime number, and also an integer.\""],"type":"codeListing"},{"type":"paragraph","inlineContent":[{"text":"이 예제는 ","type":"text"},{"type":"codeVoice","code":"description"},{"text":"이라는 새로운 ","type":"text"},{"type":"codeVoice","code":"String"},{"type":"text","text":" 변수를 선언하고 초기값을 할당한다. 그런 다음 "},{"type":"codeVoice","code":"switch"},{"type":"text","text":" 문을 사용해 "},{"code":"integerToDescribe","type":"codeVoice"},{"type":"text","text":"의 값을 확인한다. "},{"code":"integerToDescribe","type":"codeVoice"},{"text":"의 값이 리스트에 있는 소수 중 하나라면, ","type":"text"},{"code":"description","type":"codeVoice"},{"type":"text","text":"의 끝에 해당 숫자가 소수임을 나타내는 텍스트를 추가한다. 그리고 "},{"code":"fallthrough","type":"codeVoice"},{"type":"text","text":" 키워드를 사용해 "},{"type":"codeVoice","code":"default"},{"type":"text","text":" case로 넘어간다. "},{"type":"codeVoice","code":"default"},{"type":"text","text":" case는 설명의 끝에 추가 텍스트를 붙이고, "},{"type":"codeVoice","code":"switch"},{"type":"text","text":" 문의 실행을 완료한다."}]},{"inlineContent":[{"type":"codeVoice","code":"integerToDescribe"},{"type":"text","text":"의 값이 알려진 소수 리스트에 없다면, 첫 번째 "},{"code":"switch","type":"codeVoice"},{"type":"text","text":" case와 일치하지 않는다. 다른 특정 case가 없기 때문에 "},{"code":"integerToDescribe","type":"codeVoice"},{"text":"는 ","type":"text"},{"type":"codeVoice","code":"default"},{"type":"text","text":" case와 일치하게 된다."}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"type":"codeVoice","code":"switch"},{"type":"text","text":" 문의 실행이 끝나면, "},{"code":"print(_:separator:terminator:)","type":"codeVoice"},{"type":"text","text":" 함수를 사용해 숫자에 대한 설명을 출력한다. 이 예제에서는 숫자 "},{"code":"5","type":"codeVoice"},{"type":"text","text":"가 올바르게 소수로 식별된다."}]},{"type":"aside","name":"참고","style":"note","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":""},{"code":"fallthrough","type":"codeVoice"},{"text":" 키워드는 실행이 넘어가는 ","type":"text"},{"code":"switch","type":"codeVoice"},{"text":" case의 조건을 확인하지 않는다. ","type":"text"},{"type":"codeVoice","code":"fallthrough"},{"type":"text","text":" 키워드는 단순히 코드 실행을 다음 case(또는 "},{"code":"default","type":"codeVoice"},{"type":"text","text":" case) 블록 내부의 문장으로 이동시킨다. 이 동작은 C의 표준 "},{"code":"switch","type":"codeVoice"},{"type":"text","text":" 문과 동일하다."}]}]},{"anchor":"%EB%A0%88%EC%9D%B4%EB%B8%94%EC%9D%B4-%EB%B6%99%EC%9D%80-%EA%B5%AC%EB%AC%B8","type":"heading","level":3,"text":"레이블이 붙은 구문"},{"inlineContent":[{"type":"text","text":"Swift에서는 루프와 조건문을 다른 루프나 조건문 안에 중첩시켜 복잡한 제어 흐름 구조를 만들 수 있다. 하지만 루프와 조건문 모두 "},{"type":"codeVoice","code":"break"},{"text":" 구문을 사용해 실행을 조기에 종료할 수 있다. 따라서 어떤 루프나 조건문을 ","type":"text"},{"code":"break","type":"codeVoice"},{"text":" 구문으로 종료할지 명시적으로 지정하는 것이 유용할 때가 있다. 마찬가지로 여러 루프가 중첩된 경우, ","type":"text"},{"code":"continue","type":"codeVoice"},{"type":"text","text":" 구문이 어떤 루프에 영향을 미칠지 명확히 지정하는 것이 도움이 될 수 있다."}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"type":"text","text":"이러한 목적을 달성하기 위해 루프 구문이나 조건문에 "},{"inlineContent":[{"text":"구문 레이블","type":"text"}],"type":"emphasis"},{"text":"을 붙일 수 있다. 조건문의 경우, 레이블과 함께 ","type":"text"},{"type":"codeVoice","code":"break"},{"type":"text","text":" 구문을 사용해 레이블이 붙은 구문의 실행을 종료할 수 있다. 루프 구문의 경우, 레이블과 함께 "},{"type":"codeVoice","code":"break"},{"text":" 또는 ","type":"text"},{"code":"continue","type":"codeVoice"},{"type":"text","text":" 구문을 사용해 레이블이 붙은 구문의 실행을 종료하거나 다음 반복으로 넘어갈 수 있다."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"레이블이 붙은 구문은 구문의 시작 키워드와 같은 줄에 레이블을 붙이고 콜론을 추가해 표시한다. 다음은 "},{"type":"codeVoice","code":"while"},{"type":"text","text":" 루프에 이 구문을 적용한 예시다. 이 원칙은 모든 루프와 "},{"code":"switch","type":"codeVoice"},{"type":"text","text":" 구문에 동일하게 적용된다:"}]},{"syntax":"swift","code":["<#label name#>: while <#condition#> {","   <#statements#>","}"],"type":"codeListing"},{"type":"paragraph","inlineContent":[{"text":"다음 예제는 이 장 앞부분에서 본 ","type":"text"},{"inlineContent":[{"type":"text","text":"Snakes and Ladders"}],"type":"emphasis"},{"text":" 게임을 변형한 버전에서 레이블이 붙은 ","type":"text"},{"code":"while","type":"codeVoice"},{"type":"text","text":" 루프와 함께 "},{"type":"codeVoice","code":"break"},{"text":" 및 ","type":"text"},{"type":"codeVoice","code":"continue"},{"type":"text","text":" 구문을 사용한다. 이번 버전에서는 새로운 규칙이 추가되었다:"}]},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"text":"게임에서 이기려면 정확히 25번 칸에 도착해야 한다.","type":"text"}]}]}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"주사위를 굴려 25번 칸을 넘어가게 되면, 정확히 25번 칸에 도착할 수 있는 숫자가 나올 때까지 다시 주사위를 굴려야 한다."}]},{"type":"paragraph","inlineContent":[{"text":"게임 보드는 이전과 동일하다.","type":"text"}]},{"type":"paragraph","inlineContent":[{"type":"image","identifier":"snakesAndLadders"}]},{"type":"paragraph","inlineContent":[{"code":"finalSquare","type":"codeVoice"},{"text":", ","type":"text"},{"code":"board","type":"codeVoice"},{"text":", ","type":"text"},{"type":"codeVoice","code":"square"},{"text":", ","type":"text"},{"code":"diceRoll","type":"codeVoice"},{"type":"text","text":"의 값은 이전과 동일한 방식으로 초기화된다:"}]},{"type":"codeListing","syntax":"swift","code":["let finalSquare = 25","var board = [Int](repeating: 0, count: finalSquare + 1)","board[03] = +08; board[06] = +11; board[09] = +09; board[10] = +02","board[14] = -10; board[19] = -11; board[22] = -02; board[24] = -08","var square = 0","var diceRoll = 0"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"이 버전의 게임은 "},{"code":"while","type":"codeVoice"},{"type":"text","text":" 루프와 "},{"type":"codeVoice","code":"switch"},{"text":" 구문을 사용해 게임 로직을 구현한다. ","type":"text"},{"code":"while","type":"codeVoice"},{"type":"text","text":" 루프에는 "},{"type":"codeVoice","code":"gameLoop"},{"type":"text","text":"라는 구문 레이블이 붙어 있으며, 이는 Snakes and Ladders 게임의 메인 루프임을 나타낸다."}]},{"type":"paragraph","inlineContent":[{"code":"while","type":"codeVoice"},{"text":" 루프의 조건은 ","type":"text"},{"type":"codeVoice","code":"while square != finalSquare"},{"type":"text","text":"로, 정확히 25번 칸에 도착해야 함을 반영한다."}]},{"type":"codeListing","code":["gameLoop: while square != finalSquare {","    diceRoll += 1","    if diceRoll == 7 { diceRoll = 1 }","    switch square + diceRoll {","    case finalSquare:","        \/\/ 주사위를 굴려 정확히 25번 칸에 도착하면 게임 종료","        break gameLoop","    case let newSquare where newSquare > finalSquare:","        \/\/ 주사위를 굴려 25번 칸을 넘어가면 다시 굴림","        continue gameLoop","    default:","        \/\/ 유효한 이동이므로 이동 결과 확인","        square += diceRoll","        square += board[square]","    }","}","print(\"Game over!\")"],"syntax":"swift"},{"type":"paragraph","inlineContent":[{"type":"text","text":"각 루프가 시작될 때 주사위를 굴린다. 플레이어를 즉시 이동시키는 대신, "},{"type":"codeVoice","code":"switch"},{"text":" 구문을 사용해 이동 결과를 고려하고 이동이 허용되는지 결정한다:","type":"text"}]},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"주사위를 굴려 플레이어가 정확히 25번 칸에 도착하면 게임이 종료된다. "},{"code":"break gameLoop","type":"codeVoice"},{"type":"text","text":" 구문은 "},{"code":"while","type":"codeVoice"},{"type":"text","text":" 루프 외부의 첫 번째 코드 줄로 제어를 이동시켜 게임을 끝낸다."}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"주사위를 굴려 플레이어가 25번 칸을 넘어가면 이동이 무효화되고 플레이어는 다시 주사위를 굴려야 한다. "},{"code":"continue gameLoop","type":"codeVoice"},{"type":"text","text":" 구문은 현재 "},{"code":"while","type":"codeVoice"},{"type":"text","text":" 루프 반복을 종료하고 다음 반복을 시작한다."}]}]},{"content":[{"inlineContent":[{"type":"text","text":"다른 모든 경우에는 주사위 굴림이 유효한 이동이다. 플레이어는 "},{"code":"diceRoll","type":"codeVoice"},{"type":"text","text":" 만큼 앞으로 이동하고, 게임 로직은 뱀과 사다리를 확인한다. 그런 다음 루프가 종료되고, 제어는 "},{"code":"while","type":"codeVoice"},{"text":" 조건으로 돌아가 다음 턴이 필요한지 결정한다.","type":"text"}],"type":"paragraph"}]}]},{"style":"note","name":"참고","type":"aside","content":[{"inlineContent":[{"type":"text","text":"위의 "},{"code":"break","type":"codeVoice"},{"text":" 구문에서 ","type":"text"},{"type":"codeVoice","code":"gameLoop"},{"type":"text","text":" 레이블을 사용하지 않았다면, "},{"type":"codeVoice","code":"switch"},{"type":"text","text":" 구문을 종료하게 되고 "},{"type":"codeVoice","code":"while"},{"type":"text","text":" 구문을 종료하지 않는다. "},{"type":"codeVoice","code":"gameLoop"},{"type":"text","text":" 레이블을 사용하면 어떤 제어 구문을 종료할지 명확히 할 수 있다."}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"type":"codeVoice","code":"continue gameLoop"},{"type":"text","text":"를 사용해 루프의 다음 반복으로 넘어갈 때 "},{"code":"gameLoop","type":"codeVoice"},{"type":"text","text":" 레이블을 사용하는 것은 꼭 필요하지 않다. 게임에는 하나의 루프만 있으므로 "},{"type":"codeVoice","code":"continue"},{"type":"text","text":" 구문이 어떤 루프에 영향을 미칠지 모호하지 않다. 하지만 "},{"type":"codeVoice","code":"continue"},{"type":"text","text":" 구문에 "},{"code":"gameLoop","type":"codeVoice"},{"text":" 레이블을 사용해도 문제는 없다. 이렇게 하면 ","type":"text"},{"type":"codeVoice","code":"break"},{"text":" 구문과의 일관성을 유지할 수 있고, 게임 로직을 더 명확히 이해하는 데 도움이 된다.","type":"text"}]}]},{"text":"조기 종료","type":"heading","level":2,"anchor":"%EC%A1%B0%EA%B8%B0-%EC%A2%85%EB%A3%8C"},{"type":"paragraph","inlineContent":[{"type":"codeVoice","code":"guard"},{"text":" 문은 ","type":"text"},{"type":"codeVoice","code":"if"},{"type":"text","text":" 문과 마찬가지로 표현식의 불리언 값에 따라 코드를 실행한다. "},{"type":"codeVoice","code":"guard"},{"type":"text","text":" 문은 특정 조건이 참일 때만 "},{"type":"codeVoice","code":"guard"},{"type":"text","text":" 문 이후의 코드가 실행되도록 요구한다. "},{"type":"codeVoice","code":"if"},{"text":" 문과 달리, ","type":"text"},{"type":"codeVoice","code":"guard"},{"type":"text","text":" 문은 항상 "},{"type":"codeVoice","code":"else"},{"type":"text","text":" 절을 포함한다. 조건이 참이 아닐 경우 "},{"code":"else","type":"codeVoice"},{"type":"text","text":" 절 내부의 코드가 실행된다."}]},{"syntax":"swift","code":["func greet(person: [String: String]) {","    guard let name = person[\"name\"] else {","        return","    }","","    print(\"Hello \\(name)!\")","","    guard let location = person[\"location\"] else {","        print(\"I hope the weather is nice near you.\")","        return","    }","","    print(\"I hope the weather is nice in \\(location).\")","}","","greet(person: [\"name\": \"John\"])","\/\/ Prints \"Hello John!\"","\/\/ Prints \"I hope the weather is nice near you.\"","greet(person: [\"name\": \"Jane\", \"location\": \"Cupertino\"])","\/\/ Prints \"Hello Jane!\"","\/\/ Prints \"I hope the weather is nice in Cupertino.\""],"type":"codeListing"},{"inlineContent":[{"type":"codeVoice","code":"guard"},{"type":"text","text":" 문의 조건이 충족되면, "},{"type":"codeVoice","code":"guard"},{"text":" 문의 닫는 중괄호 이후부터 코드 실행이 계속된다. 조건의 일부로 옵셔널 바인딩을 통해 할당된 변수나 상수는 ","type":"text"},{"code":"guard","type":"codeVoice"},{"type":"text","text":" 문이 위치한 코드 블록의 나머지 부분에서 사용할 수 있다."}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"type":"text","text":"조건이 충족되지 않으면, "},{"code":"else","type":"codeVoice"},{"type":"text","text":" 분기 내부의 코드가 실행된다. 이 분기는 "},{"type":"codeVoice","code":"guard"},{"type":"text","text":" 문이 위치한 코드 블록을 종료하기 위해 제어를 전달해야 한다. 이를 위해 "},{"type":"codeVoice","code":"return"},{"type":"text","text":", "},{"type":"codeVoice","code":"break"},{"text":", ","type":"text"},{"type":"codeVoice","code":"continue"},{"type":"text","text":", "},{"type":"codeVoice","code":"throw"},{"text":"와 같은 제어 전달 문을 사용하거나, ","type":"text"},{"code":"fatalError(_:file:line:)","type":"codeVoice"},{"type":"text","text":"과 같이 반환하지 않는 함수나 메서드를 호출할 수 있다."}]},{"type":"paragraph","inlineContent":[{"type":"codeVoice","code":"guard"},{"text":" 문을 사용해 요구사항을 확인하면, ","type":"text"},{"code":"if","type":"codeVoice"},{"type":"text","text":" 문을 사용하는 것보다 코드의 가독성이 향상된다. 일반적으로 실행되는 코드를 "},{"type":"codeVoice","code":"else"},{"type":"text","text":" 블록으로 감싸지 않아도 되며, 요구사항이 위반되었을 때 처리하는 코드를 요구사항 바로 옆에 배치할 수 있다."}]},{"level":2,"anchor":"%EC%A7%80%EC%97%B0%EB%90%9C-%EB%8F%99%EC%9E%91","type":"heading","text":"지연된 동작"},{"type":"paragraph","inlineContent":[{"type":"codeVoice","code":"if"},{"type":"text","text":"나 "},{"type":"codeVoice","code":"while"},{"type":"text","text":" 같은 제어 흐름 구문은 코드의 일부가 실행될지 여부나 실행 횟수를 제어한다. 반면 "},{"code":"defer","type":"codeVoice"},{"text":"는 코드가 ","type":"text"},{"type":"emphasis","inlineContent":[{"type":"text","text":"언제"}]},{"text":" 실행될지를 제어한다. ","type":"text"},{"code":"defer","type":"codeVoice"},{"type":"text","text":" 블록을 사용하면 현재 스코프가 끝나는 시점에 실행될 코드를 작성할 수 있다. 예를 들어:"}]},{"syntax":"swift","code":["var score = 1","if score < 10 {","    defer {","        print(score)","    }","    score += 5","}","\/\/ \"6\" 출력"],"type":"codeListing"},{"inlineContent":[{"type":"text","text":"위 예제에서 "},{"code":"defer","type":"codeVoice"},{"type":"text","text":" 블록 안의 코드는 "},{"type":"codeVoice","code":"if"},{"type":"text","text":" 문의 본문을 벗어나기 직전에 실행된다. 먼저 "},{"type":"codeVoice","code":"if"},{"text":" 문 안의 코드가 실행되어 ","type":"text"},{"type":"codeVoice","code":"score"},{"type":"text","text":"에 5를 더한다. 그런 다음 "},{"code":"if","type":"codeVoice"},{"type":"text","text":" 문의 스코프를 벗어나기 직전에 지연된 코드가 실행되어 "},{"type":"codeVoice","code":"score"},{"type":"text","text":" 값을 출력한다."}],"type":"paragraph"},{"inlineContent":[{"type":"codeVoice","code":"defer"},{"text":" 블록 안의 코드는 프로그램이 해당 스코프를 어떻게 벗어나든 상관없이 항상 실행된다. 여기에는 함수에서 조기 반환하거나, ","type":"text"},{"type":"codeVoice","code":"for"},{"type":"text","text":" 루프를 중단하거나, 오류를 던지는 경우도 포함된다. 이러한 동작은 메모리 할당과 해제, 저수준 파일 디스크립터 열기와 닫기, 데이터베이스 트랜잭션 시작과 종료처럼 반드시 짝을 이루어야 하는 작업에 "},{"type":"codeVoice","code":"defer"},{"type":"text","text":"를 유용하게 만든다. 코드에서 두 작업을 나란히 작성할 수 있기 때문이다. 예를 들어, 다음 코드는 일시적으로 점수에 보너스를 주기 위해 100을 더하고 빼는 작업을 수행한다:"}],"type":"paragraph"},{"syntax":"swift","code":["var score = 3","if score < 100 {","    score += 100","    defer {","        score -= 100","    }","    \/\/ 보너스가 적용된 점수를 사용하는 다른 코드가 여기에 위치한다.","    print(score)","}","\/\/ \"103\" 출력"],"type":"codeListing"},{"type":"paragraph","inlineContent":[{"type":"text","text":"같은 스코프 안에 여러 개의 "},{"code":"defer","type":"codeVoice"},{"type":"text","text":" 블록을 작성하면, 처음 지정한 블록이 가장 나중에 실행된다."}]},{"type":"codeListing","code":["if score < 10 {","    defer {","        print(score)","    }","    defer {","        print(\"The score is:\")","    }","    score += 5","}","\/\/ \"The score is:\" 출력","\/\/ \"6\" 출력"],"syntax":"swift"},{"type":"paragraph","inlineContent":[{"type":"text","text":"프로그램이 실행을 중단하는 경우 — 예를 들어 런타임 오류나 충돌로 인해 — 지연된 코드는 실행되지 않는다. 하지만 오류가 발생한 후에는 지연된 코드가 실행된다. 오류 처리와 함께 "},{"type":"codeVoice","code":"defer"},{"text":"를 사용하는 방법에 대한 자세한 내용은 ","type":"text"},{"type":"text","text":"doc:ErrorHandling#Specifying-Cleanup-Actions"},{"type":"text","text":"를 참고한다."}]},{"text":"API 가용성 확인","level":2,"type":"heading","anchor":"API-%EA%B0%80%EC%9A%A9%EC%84%B1-%ED%99%95%EC%9D%B8"},{"inlineContent":[{"type":"text","text":"Swift는 API 가용성을 확인하는 기능을 기본으로 제공한다. 이를 통해 특정 배포 대상에서 사용할 수 없는 API를 실수로 사용하는 것을 방지할 수 있다."}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"type":"text","text":"컴파일러는 SDK에 포함된 가용성 정보를 활용해 코드에서 사용하는 모든 API가 프로젝트에서 지정한 배포 대상에서 사용 가능한지 확인한다. 만약 사용할 수 없는 API를 사용하려고 하면 컴파일 시점에 오류를 보고한다."}]},{"type":"paragraph","inlineContent":[{"code":"if","type":"codeVoice"},{"type":"text","text":"나 "},{"type":"codeVoice","code":"guard"},{"type":"text","text":" 문에서 "},{"type":"emphasis","inlineContent":[{"text":"가용성 조건","type":"text"}]},{"type":"text","text":"을 사용하면, 런타임에 사용하려는 API가 사용 가능한지에 따라 코드 블록을 조건부로 실행할 수 있다. 컴파일러는 이 가용성 조건의 정보를 활용해 해당 코드 블록 내의 API가 사용 가능한지 검증한다."}]},{"syntax":"swift","code":["if #available(iOS 10, macOS 10.12, *) {","    \/\/ iOS에서는 iOS 10 API를, macOS에서는 macOS 10.12 API를 사용","} else {","    \/\/ 이전 버전의 iOS와 macOS API로 대체","}"],"type":"codeListing"},{"type":"paragraph","inlineContent":[{"text":"위의 가용성 조건은 iOS에서는 ","type":"text"},{"type":"codeVoice","code":"if"},{"type":"text","text":" 문의 본문이 iOS 10 이상에서만 실행되고, macOS에서는 macOS 10.12 이상에서만 실행되도록 지정한다. 마지막 인자인 "},{"code":"*","type":"codeVoice"},{"text":"는 필수이며, 다른 플랫폼에서는 프로젝트에서 지정한 최소 배포 대상에서 ","type":"text"},{"code":"if","type":"codeVoice"},{"text":" 문의 본문이 실행된다.","type":"text"}]},{"inlineContent":[{"text":"일반적으로 가용성 조건은 플랫폼 이름과 버전 목록을 받는다. ","type":"text"},{"type":"codeVoice","code":"iOS"},{"text":", ","type":"text"},{"code":"macOS","type":"codeVoice"},{"text":", ","type":"text"},{"type":"codeVoice","code":"watchOS"},{"text":", ","type":"text"},{"type":"codeVoice","code":"tvOS"},{"type":"text","text":", "},{"type":"codeVoice","code":"visionOS"},{"type":"text","text":"와 같은 플랫폼 이름을 사용할 수 있다. 전체 목록은 "},{"text":"doc:Attributes#Declaration-Attributes","type":"text"},{"type":"text","text":"를 참고한다. iOS 8이나 macOS 10.10과 같은 주 버전뿐만 아니라 iOS 11.2.6이나 macOS 10.13.3과 같은 부 버전도 지정할 수 있다."}],"type":"paragraph"},{"code":["if #available(<#플랫폼 이름#> <#버전#>, <#...#>, *) {","    <#API가 사용 가능할 때 실행할 코드#>","} else {","    <#API가 사용 불가능할 때 실행할 대체 코드#>","}"],"type":"codeListing","syntax":"swift"},{"type":"paragraph","inlineContent":[{"code":"guard","type":"codeVoice"},{"text":" 문에서 가용성 조건을 사용하면, 해당 코드 블록의 나머지 부분에 사용할 가용성 정보를 구체화할 수 있다.","type":"text"}]},{"syntax":"swift","code":["@available(macOS 10.12, *)","struct ColorPreference {","    var bestColor = \"blue\"","}","","func chooseBestColor() -> String {","    guard #available(macOS 10.12, *) else {","       return \"gray\"","    }","    let colors = ColorPreference()","    return colors.bestColor","}"],"type":"codeListing"},{"type":"paragraph","inlineContent":[{"text":"위 예제에서 ","type":"text"},{"type":"codeVoice","code":"ColorPreference"},{"text":" 구조체는 macOS 10.12 이상이 필요하다. ","type":"text"},{"type":"codeVoice","code":"chooseBestColor()"},{"type":"text","text":" 함수는 가용성 가드를 시작으로, 플랫폼 버전이 "},{"code":"ColorPreference","type":"codeVoice"},{"type":"text","text":"를 사용하기에 너무 오래된 경우 항상 사용 가능한 동작으로 대체한다. "},{"code":"guard","type":"codeVoice"},{"type":"text","text":" 문 이후에는 macOS 10.12 이상이 필요한 API를 사용할 수 있다."}]},{"inlineContent":[{"code":"#available","type":"codeVoice"},{"type":"text","text":" 외에도 Swift는 "},{"type":"codeVoice","code":"#unavailable"},{"type":"text","text":" 조건을 사용해 반대의 검사를 지원한다. 예를 들어, 다음 두 검사는 동일한 작업을 수행한다."}],"type":"paragraph"},{"type":"codeListing","syntax":"swift","code":["if #available(iOS 10, *) {","} else {","    \/\/ 대체 코드","}","","if #unavailable(iOS 10) {","    \/\/ 대체 코드","}"]},{"type":"paragraph","inlineContent":[{"code":"#unavailable","type":"codeVoice"},{"type":"text","text":" 형식을 사용하면 대체 코드만 포함된 경우 코드의 가독성을 높일 수 있다."}]}],"kind":"content"}],"hierarchy":{"paths":[["doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language"]]},"references":{"coordinateGraphComplex":{"alt":null,"type":"image","identifier":"coordinateGraphComplex","variants":[{"url":"\/images\/org.swift.tspl\/coordinateGraphComplex@2x.png","traits":["2x","light"]},{"traits":["2x","dark"],"url":"\/images\/org.swift.tspl\/coordinateGraphComplex~dark@2x.png"}]},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/ErrorHandling":{"url":"\/documentation\/the-swift-programming-language\/errorhandling","abstract":[{"type":"text","text":"프로그램에서 발생하는 에러 상황에 대응하고 복구하는 방법을 알아본다."}],"kind":"article","identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/ErrorHandling","type":"topic","role":"article","title":"에러 처리"},"coordinateGraphSimple":{"alt":null,"type":"image","identifier":"coordinateGraphSimple","variants":[{"url":"\/images\/org.swift.tspl\/coordinateGraphSimple@2x.png","traits":["2x","light"]},{"traits":["2x","dark"],"url":"\/images\/org.swift.tspl\/coordinateGraphSimple~dark@2x.png"}]},"snakesAndLadders":{"alt":null,"type":"image","identifier":"snakesAndLadders","variants":[{"url":"\/images\/org.swift.tspl\/snakesAndLadders@2x.png","traits":["2x","light"]},{"traits":["2x","dark"],"url":"\/images\/org.swift.tspl\/snakesAndLadders~dark@2x.png"}]},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language":{"title":"The Swift Programming Language (6.1)","abstract":[],"kind":"article","role":"collection","type":"topic","url":"\/documentation\/the-swift-programming-language","identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/ControlFlow#Fallthrough":{"title":"Fallthrough","url":"\/documentation\/the-swift-programming-language\/controlflow#Fallthrough","abstract":[],"kind":"section","type":"topic","identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/ControlFlow#Fallthrough"},"https://developer.apple.com/documentation/swift/sequence":{"title":"Sequence","url":"https:\/\/developer.apple.com\/documentation\/swift\/sequence","type":"link","identifier":"https:\/\/developer.apple.com\/documentation\/swift\/sequence","titleInlineContent":[{"type":"codeVoice","code":"Sequence"}]},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/Functions":{"url":"\/documentation\/the-swift-programming-language\/functions","type":"topic","identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Functions","kind":"article","abstract":[{"text":"특정 작업을 수행하는 독립적인 코드 블록인 함수를 정의하고 호출한다. 또한 함수의 인자에 레이블을 붙이고 반환 값을 사용하는 방법을 알아본다.","type":"text"}],"role":"article","title":"함수"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/CollectionTypes":{"url":"\/documentation\/the-swift-programming-language\/collectiontypes","abstract":[{"text":"배열, 집합, 딕셔너리를 활용해 데이터를 구조화한다.","type":"text"}],"kind":"article","identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/CollectionTypes","type":"topic","role":"article","title":"컬렉션 타입"},"coordinateGraphMedium":{"alt":null,"type":"image","identifier":"coordinateGraphMedium","variants":[{"traits":["2x","light"],"url":"\/images\/org.swift.tspl\/coordinateGraphMedium@2x.png"},{"traits":["2x","dark"],"url":"\/images\/org.swift.tspl\/coordinateGraphMedium~dark@2x.png"}]}}}