{"schemaVersion":{"minor":3,"patch":0,"major":0},"abstract":[{"type":"text","text":"타입을 다른 타입의 스코프 안에 정의한다."}],"metadata":{"title":"중첩 타입"},"kind":"article","sections":[],"identifier":{"url":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/NestedTypes","interfaceLanguage":"swift"},"hierarchy":{"paths":[["doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language"]]},"primaryContentSections":[{"kind":"content","content":[{"type":"paragraph","inlineContent":[{"text":"열거형은 특정 클래스나 구조체의 기능을 지원하기 위해 자주 생성된다. 마찬가지로, 더 복잡한 타입의 컨텍스트 내에서만 사용하기 위한 유틸리티 구조체나 특정 타입과 함께 사용되는 프로토콜을 정의하는 것이 편리할 때가 있다. 이를 위해 Swift는 ","type":"text"},{"inlineContent":[{"type":"text","text":"중첩 타입"}],"type":"emphasis"},{"text":"을 정의할 수 있도록 지원한다. 중첩 타입은 열거형, 구조체, 프로토콜과 같은 지원 타입을 해당 타입의 정의 안에 중첩시키는 것을 의미한다.","type":"text"}]},{"inlineContent":[{"type":"text","text":"타입을 다른 타입 안에 중첩시키려면, 지원하는 타입의 외부 중괄호 안에 해당 타입의 정의를 작성한다. 타입은 필요한 만큼의 수준으로 중첩할 수 있다."}],"type":"paragraph"},{"type":"heading","level":2,"anchor":"%EC%A4%91%EC%B2%A9-%ED%83%80%EC%9E%85%EC%9D%98-%ED%99%9C%EC%9A%A9","text":"중첩 타입의 활용"},{"type":"paragraph","inlineContent":[{"type":"text","text":"아래 예제는 블랙잭 게임에서 사용하는 카드를 모델링한 "},{"code":"BlackjackCard","type":"codeVoice"},{"text":" 구조체를 정의한다. ","type":"text"},{"type":"codeVoice","code":"BlackjackCard"},{"type":"text","text":" 구조체는 "},{"code":"Suit","type":"codeVoice"},{"type":"text","text":"와 "},{"code":"Rank","type":"codeVoice"},{"type":"text","text":"라는 두 개의 중첩 열거형 타입을 포함한다."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"블랙잭에서 에이스 카드는 1 또는 11의 값을 가진다. 이 특징은 "},{"code":"Rank","type":"codeVoice"},{"type":"text","text":" 열거형 내부에 중첩된 "},{"type":"codeVoice","code":"Values"},{"text":" 구조체로 표현된다:","type":"text"}]},{"code":["struct BlackjackCard {","","    \/\/ 중첩 Suit 열거형","    enum Suit: Character {","        case spades = \"♠\", hearts = \"♡\", diamonds = \"♢\", clubs = \"♣\"","    }","","    \/\/ 중첩 Rank 열거형","    enum Rank: Int {","        case two = 2, three, four, five, six, seven, eight, nine, ten","        case jack, queen, king, ace","        struct Values {","            let first: Int, second: Int?","        }","        var values: Values {","            switch self {","            case .ace:","                return Values(first: 1, second: 11)","            case .jack, .queen, .king:","                return Values(first: 10, second: nil)","            default:","                return Values(first: self.rawValue, second: nil)","            }","        }","    }","","    \/\/ BlackjackCard 프로퍼티와 메서드","    let rank: Rank, suit: Suit","    var description: String {","        var output = \"suit is \\(suit.rawValue),\"","        output += \" value is \\(rank.values.first)\"","        if let second = rank.values.second {","            output += \" or \\(second)\"","        }","        return output","    }","}"],"type":"codeListing","syntax":"swift"},{"type":"paragraph","inlineContent":[{"type":"codeVoice","code":"Suit"},{"type":"text","text":" 열거형은 네 가지 카드 문양을 설명하며, 각 문양의 심볼을 나타내는 "},{"type":"codeVoice","code":"Character"},{"type":"text","text":" 원시 값을 가진다."}]},{"type":"paragraph","inlineContent":[{"type":"codeVoice","code":"Rank"},{"type":"text","text":" 열거형은 13가지 카드 랭크를 설명하며, 각 랭크의 숫자 값을 나타내는 "},{"code":"Int","type":"codeVoice"},{"type":"text","text":" 원시 값을 가진다. (잭, 퀸, 킹, 에이스 카드에는 이 원시 값을 사용하지 않는다.)"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"위에서 언급한 대로, "},{"type":"codeVoice","code":"Rank"},{"text":" 열거형은 ","type":"text"},{"code":"Values","type":"codeVoice"},{"type":"text","text":"라는 중첩 구조체를 추가로 정의한다. 이 구조체는 대부분의 카드가 하나의 값을 가지지만, 에이스 카드는 두 개의 값을 가진다는 사실을 캡슐화한다. "},{"type":"codeVoice","code":"Values"},{"type":"text","text":" 구조체는 이를 나타내기 위해 두 가지 프로퍼티를 정의한다:"}]},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"code":"first","type":"codeVoice"},{"text":": ","type":"text"},{"type":"codeVoice","code":"Int"},{"type":"text","text":" 타입"}]}]},{"content":[{"inlineContent":[{"code":"second","type":"codeVoice"},{"type":"text","text":": "},{"code":"Int?","type":"codeVoice"},{"text":" 타입, 즉 “옵셔널 ","type":"text"},{"type":"codeVoice","code":"Int"},{"text":"”","type":"text"}],"type":"paragraph"}]}]},{"inlineContent":[{"type":"codeVoice","code":"Rank"},{"type":"text","text":"는 또한 "},{"type":"codeVoice","code":"values"},{"text":"라는 계산 프로퍼티를 정의한다. 이 프로퍼티는 ","type":"text"},{"type":"codeVoice","code":"Values"},{"type":"text","text":" 구조체의 인스턴스를 반환한다. 이 계산 프로퍼티는 카드의 랭크를 고려해 적절한 값으로 새로운 "},{"type":"codeVoice","code":"Values"},{"type":"text","text":" 인스턴스를 초기화한다. 잭, 퀸, 킹, 에이스에 대해 특별한 값을 사용하며, 숫자 카드의 경우 랭크의 원시 "},{"code":"Int","type":"codeVoice"},{"text":" 값을 사용한다.","type":"text"}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"type":"codeVoice","code":"BlackjackCard"},{"type":"text","text":" 구조체 자체는 "},{"type":"codeVoice","code":"rank"},{"type":"text","text":"와 "},{"code":"suit","type":"codeVoice"},{"type":"text","text":" 두 가지 프로퍼티를 가진다. 또한 "},{"type":"codeVoice","code":"description"},{"text":"이라는 계산 프로퍼티를 정의하는데, 이 프로퍼티는 ","type":"text"},{"code":"rank","type":"codeVoice"},{"type":"text","text":"와 "},{"code":"suit","type":"codeVoice"},{"text":"에 저장된 값을 사용해 카드의 이름과 값을 설명하는 문자열을 만든다. ","type":"text"},{"code":"description","type":"codeVoice"},{"type":"text","text":" 프로퍼티는 옵셔널 바인딩을 사용해 두 번째 값이 있는지 확인하고, 있다면 해당 값을 추가 설명에 포함한다."}]},{"type":"paragraph","inlineContent":[{"type":"codeVoice","code":"BlackjackCard"},{"type":"text","text":"는 사용자 정의 이니셜라이저가 없는 구조체이므로, "},{"type":"text","text":"doc:Initialization#Memberwise-Initializers-for-Structure-Types"},{"text":"에서 설명한 대로 암시적 멤버와이즈 이니셜라이저를 가진다. 이 이니셜라이저를 사용해 ","type":"text"},{"code":"theAceOfSpades","type":"codeVoice"},{"type":"text","text":"라는 새로운 상수를 초기화할 수 있다:"}]},{"syntax":"swift","code":["let theAceOfSpades = BlackjackCard(rank: .ace, suit: .spades)","print(\"theAceOfSpades: \\(theAceOfSpades.description)\")","\/\/ Prints \"theAceOfSpades: suit is ♠, value is 1 or 11\""],"type":"codeListing"},{"type":"paragraph","inlineContent":[{"code":"Rank","type":"codeVoice"},{"text":"와 ","type":"text"},{"code":"Suit","type":"codeVoice"},{"text":"가 ","type":"text"},{"type":"codeVoice","code":"BlackjackCard"},{"type":"text","text":" 내부에 중첩되어 있더라도, 이들의 타입은 문맥에서 추론할 수 있으므로 이 인스턴스의 초기화는 열거형 케이스를 케이스 이름("},{"type":"codeVoice","code":".ace"},{"type":"text","text":"와 "},{"code":".spades","type":"codeVoice"},{"type":"text","text":")만으로 참조할 수 있다. 위 예제에서 "},{"type":"codeVoice","code":"description"},{"type":"text","text":" 프로퍼티는 스페이드 에이스가 "},{"type":"codeVoice","code":"1"},{"type":"text","text":" 또는 "},{"type":"codeVoice","code":"11"},{"text":"의 값을 가진다고 정확히 보고한다.","type":"text"}]},{"level":2,"text":"중첩 타입 참조하기","anchor":"%EC%A4%91%EC%B2%A9-%ED%83%80%EC%9E%85-%EC%B0%B8%EC%A1%B0%ED%95%98%EA%B8%B0","type":"heading"},{"inlineContent":[{"text":"정의된 문맥 밖에서 중첩 타입을 사용하려면, 해당 타입이 속한 타입의 이름을 접두사로 붙인다:","type":"text"}],"type":"paragraph"},{"type":"codeListing","syntax":"swift","code":["let heartsSymbol = BlackjackCard.Suit.hearts.rawValue","\/\/ heartsSymbol은 \"♡\""]},{"type":"paragraph","inlineContent":[{"text":"위 예제에서 ","type":"text"},{"code":"Suit","type":"codeVoice"},{"type":"text","text":", "},{"code":"Rank","type":"codeVoice"},{"text":", ","type":"text"},{"type":"codeVoice","code":"Values"},{"type":"text","text":"와 같은 이름은 의도적으로 짧게 유지할 수 있다. 이는 해당 이름들이 정의된 문맥에 의해 자연스럽게 한정되기 때문이다."}]}]}],"references":{"doc://org.swift.tspl/documentation/The-Swift-Programming-Language":{"title":"The Swift Programming Language (6.1)","abstract":[],"kind":"article","role":"collection","type":"topic","url":"\/documentation\/the-swift-programming-language","identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language"}}}