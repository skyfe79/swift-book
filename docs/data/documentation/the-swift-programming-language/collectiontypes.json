{"identifier":{"url":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/CollectionTypes","interfaceLanguage":"swift"},"primaryContentSections":[{"kind":"content","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Swift는 값의 컬렉션을 저장하기 위해 세 가지 주요 "},{"type":"emphasis","inlineContent":[{"text":"컬렉션 타입","type":"text"}]},{"type":"text","text":"을 제공한다. 이는 배열, 집합, 딕셔너리로 알려져 있다. 배열은 값의 순서 있는 컬렉션이고, 집합은 중복 없는 값의 순서 없는 컬렉션이다. 딕셔너리는 키-값 쌍의 순서 없는 컬렉션이다."}]},{"inlineContent":[{"identifier":"CollectionTypes_intro","type":"image"}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"text":"Swift의 배열, 집합, 딕셔너리는 저장할 수 있는 값과 키의 타입을 항상 명확히 정의한다. 따라서 잘못된 타입의 값을 실수로 컬렉션에 삽입할 수 없다. 또한 컬렉션에서 어떤 타입의 값을 가져올지 확신할 수 있다.","type":"text"}]},{"type":"aside","style":"note","content":[{"type":"paragraph","inlineContent":[{"text":"Swift의 배열, 집합, 딕셔너리 타입은 ","type":"text"},{"type":"emphasis","inlineContent":[{"type":"text","text":"제네릭 컬렉션"}]},{"type":"text","text":"으로 구현된다. 제네릭 타입과 컬렉션에 대한 자세한 내용은 "},{"type":"reference","identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Generics","isActive":true},{"type":"text","text":"를 참고한다."}]}],"name":"참고"},{"anchor":"%EC%BB%AC%EB%A0%89%EC%85%98%EC%9D%98-%EB%B3%80%EA%B2%BD-%EA%B0%80%EB%8A%A5%EC%84%B1","text":"컬렉션의 변경 가능성","level":2,"type":"heading"},{"type":"paragraph","inlineContent":[{"text":"배열, 집합, 또는 딕셔너리를 생성하고 변수에 할당하면, 해당 컬렉션은 ","type":"text"},{"inlineContent":[{"text":"변경 가능","type":"text"}],"type":"emphasis"},{"type":"text","text":" 상태가 된다. 즉, 컬렉션을 생성한 후에도 내부의 항목을 추가, 삭제, 또는 수정할 수 있다. 반면, 배열, 집합, 또는 딕셔너리를 상수에 할당하면, 그 컬렉션은 "},{"inlineContent":[{"type":"text","text":"변경 불가능"}],"type":"emphasis"},{"type":"text","text":" 상태가 되며, 크기와 내용을 변경할 수 없다."}]},{"style":"note","content":[{"type":"paragraph","inlineContent":[{"text":"컬렉션을 변경할 필요가 없는 경우에는 불변 컬렉션을 생성하는 것이 좋다. 이렇게 하면 코드를 더 쉽게 이해할 수 있고, Swift 컴파일러가 생성한 컬렉션의 성능을 최적화할 수 있다.","type":"text"}]}],"name":"참고","type":"aside"},{"level":2,"anchor":"%EB%B0%B0%EC%97%B4","type":"heading","text":"배열"},{"inlineContent":[{"type":"emphasis","inlineContent":[{"text":"배열","type":"text"}]},{"type":"text","text":"은 동일한 타입의 값을 순서대로 저장한다. 배열에서는 같은 값이 서로 다른 위치에 여러 번 나타날 수 있다."}],"type":"paragraph"},{"style":"note","name":"참고","content":[{"inlineContent":[{"text":"Swift의 ","type":"text"},{"code":"Array","type":"codeVoice"},{"type":"text","text":" 타입은 Foundation의 "},{"type":"codeVoice","code":"NSArray"},{"type":"text","text":" 클래스와 연결된다."}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"text":"Foundation과 Cocoa에서 ","type":"text"},{"type":"codeVoice","code":"Array"},{"text":"를 사용하는 방법에 대한 자세한 내용은 ","type":"text"},{"identifier":"https:\/\/developer.apple.com\/documentation\/swift\/array#2846730","isActive":true,"type":"reference"},{"text":"를 참고한다.","type":"text"}]}],"type":"aside"},{"type":"heading","text":"배열 타입의 축약형 문법","level":3,"anchor":"%EB%B0%B0%EC%97%B4-%ED%83%80%EC%9E%85%EC%9D%98-%EC%B6%95%EC%95%BD%ED%98%95-%EB%AC%B8%EB%B2%95"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Swift에서 배열의 타입은 "},{"code":"Array<Element>","type":"codeVoice"},{"type":"text","text":" 형태로 작성한다. 여기서 "},{"type":"codeVoice","code":"Element"},{"type":"text","text":"는 배열이 저장할 수 있는 값의 타입을 나타낸다. 배열의 타입은 "},{"type":"codeVoice","code":"[Element]"},{"text":" 형태로 축약해서 쓸 수도 있다. 두 형태는 기능적으로 동일하지만, 이 가이드에서는 배열 타입을 언급할 때 축약형을 주로 사용한다.","type":"text"}]},{"type":"heading","anchor":"%EB%B9%88-%EB%B0%B0%EC%97%B4-%EC%83%9D%EC%84%B1%ED%95%98%EA%B8%B0","level":3,"text":"빈 배열 생성하기"},{"inlineContent":[{"type":"text","text":"Swift에서 빈 배열을 만드는 방법은 두 가지다."},{"text":"\n","type":"text"},{"text":"컨텍스트가 이미 타입 정보를 제공하는 경우, 예를 들어 함수 인자나 이미 타입이 지정된 변수 또는 상수라면,","type":"text"},{"text":"\n","type":"text"},{"text":"빈 배열 리터럴을 사용할 수 있다. 빈 배열 리터럴은 ","type":"text"},{"code":"[]","type":"codeVoice"},{"text":"(빈 대괄호 쌍)으로 표기한다:","type":"text"}],"type":"paragraph"},{"type":"codeListing","syntax":"swift","code":["var someInts: [Int] = []","print(\"someInts is of type [Int] with \\(someInts.count) items.\")","\/\/ Prints \"someInts is of type [Int] with 0 items.\""]},{"type":"paragraph","inlineContent":[{"type":"text","text":"또는 특정 타입의 빈 배열을 생성할 때 명시적 초기화 구문을 사용할 수도 있다."},{"text":"\n","type":"text"},{"type":"text","text":"이 경우, 대괄호 안에 요소 타입을 쓰고 괄호를 붙인다."},{"type":"text","text":"\n"},{"text":"예를 들어, 아래 코드에서 ","type":"text"},{"type":"codeVoice","code":"[Int]()"},{"type":"text","text":"와 같이 작성한다:"}]},{"syntax":"swift","type":"codeListing","code":["var someInts = [Int]()","print(\"someInts is of type [Int] with \\(someInts.count) items.\")","\/\/ Prints \"someInts is of type [Int] with 0 items.\""]},{"type":"paragraph","inlineContent":[{"type":"text","text":"두 방법 모두 동일한 결과를 만든다."},{"text":"\n","type":"text"},{"type":"text","text":"하지만 빈 배열 리터럴이 더 짧고 일반적으로 읽기 쉽다."}]},{"inlineContent":[{"text":"두 경우 모두, 빈 배열 리터럴(","type":"text"},{"code":"[]","type":"codeVoice"},{"type":"text","text":")을 사용해 기존 변수에 빈 배열을 재할당할 수 있다:"}],"type":"paragraph"},{"type":"codeListing","syntax":"swift","code":["someInts.append(3)","\/\/ someInts now contains 1 value of type Int","someInts = []","\/\/ someInts is now an empty array, but is still of type [Int]"]},{"text":"기본값으로 배열 생성하기","level":3,"type":"heading","anchor":"%EA%B8%B0%EB%B3%B8%EA%B0%92%EC%9C%BC%EB%A1%9C-%EB%B0%B0%EC%97%B4-%EC%83%9D%EC%84%B1%ED%95%98%EA%B8%B0"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Swift의 "},{"code":"Array","type":"codeVoice"},{"type":"text","text":" 타입은 특정 크기의 배열을 생성하고 모든 값을 동일한 기본값으로 설정할 수 있는 초기화 메서드를 제공한다. 이 초기화 메서드에는 적절한 타입의 기본값("},{"type":"codeVoice","code":"repeating"},{"text":" 매개변수)과 새 배열에서 해당 값이 반복되는 횟수(","type":"text"},{"type":"codeVoice","code":"count"},{"text":" 매개변수)를 전달한다:","type":"text"}]},{"syntax":"swift","code":["var threeDoubles = Array(repeating: 0.0, count: 3)","\/\/ threeDoubles는 [Double] 타입이며, [0.0, 0.0, 0.0]과 같다"],"type":"codeListing"},{"type":"heading","level":3,"anchor":"%EB%91%90-%EB%B0%B0%EC%97%B4%EC%9D%84-%EB%8D%94%ED%95%B4-%EC%83%88%EB%A1%9C%EC%9A%B4-%EB%B0%B0%EC%97%B4-%EC%83%9D%EC%84%B1%ED%95%98%EA%B8%B0","text":"두 배열을 더해 새로운 배열 생성하기"},{"type":"paragraph","inlineContent":[{"type":"text","text":"호환 가능한 타입을 가진 두 배열을 더하기 연산자("},{"code":"+","type":"codeVoice"},{"type":"text","text":")로 결합해 새로운 배열을 만들 수 있다. 새 배열의 타입은 두 배열의 타입으로부터 추론된다:"}]},{"syntax":"swift","code":["var anotherThreeDoubles = Array(repeating: 2.5, count: 3)","\/\/ anotherThreeDoubles는 [Double] 타입이며, [2.5, 2.5, 2.5]와 같다","","var sixDoubles = threeDoubles + anotherThreeDoubles","\/\/ sixDoubles는 [Double] 타입으로 추론되며, [0.0, 0.0, 0.0, 2.5, 2.5, 2.5]와 같다"],"type":"codeListing"},{"level":3,"text":"배열 리터럴로 배열 생성하기","type":"heading","anchor":"%EB%B0%B0%EC%97%B4-%EB%A6%AC%ED%84%B0%EB%9F%B4%EB%A1%9C-%EB%B0%B0%EC%97%B4-%EC%83%9D%EC%84%B1%ED%95%98%EA%B8%B0"},{"type":"paragraph","inlineContent":[{"text":"배열을 생성할 때는 ","type":"text"},{"type":"emphasis","inlineContent":[{"type":"text","text":"배열 리터럴"}]},{"type":"text","text":"을 사용할 수도 있다. 배열 리터럴은 하나 이상의 값을 배열로 간단히 표현하는 방법이다. 배열 리터럴은 쉼표로 구분된 값의 목록을 대괄호로 감싸서 작성한다:"}]},{"type":"codeListing","syntax":"swift","code":["[<#value 1#>, <#value 2#>, <#value 3#>]"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"아래 예제는 "},{"code":"String","type":"codeVoice"},{"type":"text","text":" 타입의 값을 저장하는 "},{"type":"codeVoice","code":"shoppingList"},{"type":"text","text":"라는 배열을 생성한다:"}]},{"code":["var shoppingList: [String] = [\"Eggs\", \"Milk\"]","\/\/ shoppingList는 두 개의 초기 값으로 초기화됨"],"syntax":"swift","type":"codeListing"},{"inlineContent":[{"type":"codeVoice","code":"shoppingList"},{"text":" 변수는 ","type":"text"},{"code":"[String]","type":"codeVoice"},{"type":"text","text":"으로 선언되어 “문자열 값의 배열”임을 나타낸다. 이 배열은 "},{"type":"codeVoice","code":"String"},{"type":"text","text":" 타입의 값만 저장할 수 있다. 여기서 "},{"type":"codeVoice","code":"shoppingList"},{"text":" 배열은 배열 리터럴 안에 작성된 두 개의 ","type":"text"},{"code":"String","type":"codeVoice"},{"type":"text","text":" 값("},{"type":"codeVoice","code":"\"Eggs\""},{"type":"text","text":"와 "},{"code":"\"Milk\"","type":"codeVoice"},{"type":"text","text":")으로 초기화된다."}],"type":"paragraph"},{"content":[{"inlineContent":[{"text":"","type":"text"},{"code":"shoppingList","type":"codeVoice"},{"text":" 배열은 ","type":"text"},{"type":"codeVoice","code":"var"},{"text":" 키워드로 선언되었으며, ","type":"text"},{"code":"let","type":"codeVoice"},{"text":" 키워드로 선언된 상수가 아니다. 이는 아래 예제에서 쇼핑 목록에 더 많은 항목을 추가할 수 있도록 하기 위함이다.","type":"text"}],"type":"paragraph"}],"style":"note","name":"참고","type":"aside"},{"type":"paragraph","inlineContent":[{"type":"text","text":"이 경우, 배열 리터럴은 두 개의 "},{"type":"codeVoice","code":"String"},{"text":" 값만 포함하고 있다. 이는 ","type":"text"},{"type":"codeVoice","code":"shoppingList"},{"type":"text","text":" 변수의 선언 타입(오직 "},{"type":"codeVoice","code":"String"},{"text":" 값만 포함할 수 있는 배열)과 일치하므로, 배열 리터럴을 사용해 ","type":"text"},{"code":"shoppingList","type":"codeVoice"},{"type":"text","text":"를 두 개의 초기 값으로 초기화할 수 있다."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Swift의 타입 추론 덕분에, 배열 리터럴이 동일한 타입의 값으로 초기화된다면 배열의 타입을 명시적으로 작성하지 않아도 된다. "},{"code":"shoppingList","type":"codeVoice"},{"text":"의 초기화는 더 짧은 형태로 작성할 수 있다:","type":"text"}]},{"type":"codeListing","code":["var shoppingList = [\"Eggs\", \"Milk\"]"],"syntax":"swift"},{"inlineContent":[{"text":"배열 리터럴의 모든 값이 동일한 타입이기 때문에, Swift는 ","type":"text"},{"type":"codeVoice","code":"shoppingList"},{"type":"text","text":" 변수에 "},{"type":"codeVoice","code":"[String]"},{"type":"text","text":" 타입을 사용하는 것이 적절하다고 추론할 수 있다."}],"type":"paragraph"},{"level":3,"type":"heading","text":"배열 접근 및 수정","anchor":"%EB%B0%B0%EC%97%B4-%EC%A0%91%EA%B7%BC-%EB%B0%8F-%EC%88%98%EC%A0%95"},{"type":"paragraph","inlineContent":[{"type":"text","text":"배열에 접근하고 수정하려면 메서드와 프로퍼티를 사용하거나, 서브스크립트 문법을 활용한다."}]},{"type":"paragraph","inlineContent":[{"text":"배열의 아이템 개수를 확인하려면 읽기 전용 프로퍼티인 ","type":"text"},{"code":"count","type":"codeVoice"},{"text":"를 사용한다:","type":"text"}]},{"code":["print(\"The shopping list contains \\(shoppingList.count) items.\")","\/\/ \"The shopping list contains 2 items.\" 출력"],"type":"codeListing","syntax":"swift"},{"inlineContent":[{"code":"count","type":"codeVoice"},{"type":"text","text":" 프로퍼티가 "},{"type":"codeVoice","code":"0"},{"text":"인지 확인하는 단축키로 ","type":"text"},{"type":"codeVoice","code":"isEmpty"},{"type":"text","text":" 불리언 프로퍼티를 사용한다:"}],"type":"paragraph"},{"code":["if shoppingList.isEmpty {","    print(\"The shopping list is empty.\")","} else {","    print(\"The shopping list isn't empty.\")","}","\/\/ \"The shopping list isn't empty.\" 출력"],"type":"codeListing","syntax":"swift"},{"inlineContent":[{"type":"text","text":"배열의 끝에 새로운 아이템을 추가하려면 "},{"type":"codeVoice","code":"append(_:)"},{"type":"text","text":" 메서드를 호출한다:"}],"type":"paragraph"},{"type":"codeListing","syntax":"swift","code":["shoppingList.append(\"Flour\")","\/\/ shoppingList는 이제 3개의 아이템을 포함하며, 누군가 팬케이크를 만들고 있다"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"또는, 호환 가능한 하나 이상의 아이템을 담은 배열을 덧셈 할당 연산자("},{"type":"codeVoice","code":"+="},{"text":")를 사용해 추가한다:","type":"text"}]},{"type":"codeListing","syntax":"swift","code":["shoppingList += [\"Baking Powder\"]","\/\/ shoppingList는 이제 4개의 아이템을 포함한다","shoppingList += [\"Chocolate Spread\", \"Cheese\", \"Butter\"]","\/\/ shoppingList는 이제 7개의 아이템을 포함한다"]},{"inlineContent":[{"type":"text","text":"배열에서 값을 가져오려면 "},{"inlineContent":[{"text":"서브스크립트 문법","type":"text"}],"type":"emphasis"},{"text":"을 사용한다. 배열 이름 바로 뒤에 대괄호 안에 원하는 값의 인덱스를 전달한다:","type":"text"}],"type":"paragraph"},{"type":"codeListing","syntax":"swift","code":["var firstItem = shoppingList[0]","\/\/ firstItem은 \"Eggs\"와 같다"]},{"type":"aside","style":"note","name":"참고","content":[{"inlineContent":[{"type":"text","text":"배열의 첫 번째 아이템은 인덱스 "},{"type":"codeVoice","code":"0"},{"text":"을 가진다. Swift에서 배열은 항상 0부터 시작한다.","type":"text"}],"type":"paragraph"}]},{"inlineContent":[{"type":"text","text":"서브스크립트 문법을 사용해 특정 인덱스의 기존 값을 변경할 수 있다:"}],"type":"paragraph"},{"syntax":"swift","type":"codeListing","code":["shoppingList[0] = \"Six eggs\"","\/\/ 리스트의 첫 번째 아이템은 이제 \"Eggs\" 대신 \"Six eggs\"와 같다"]},{"type":"paragraph","inlineContent":[{"text":"서브스크립트 문법을 사용할 때는 지정한 인덱스가 유효해야 한다. 예를 들어, ","type":"text"},{"type":"codeVoice","code":"shoppingList[shoppingList.count] = \"Salt\""},{"text":"를 사용해 배열의 끝에 아이템을 추가하려고 하면 런타임 오류가 발생한다.","type":"text"}]},{"inlineContent":[{"type":"text","text":"서브스크립트 문법을 사용해 한 번에 여러 값을 변경할 수도 있다. 대체할 값의 길이가 원래 범위와 다르더라도 가능하다. 다음 예제는 "},{"code":"\"Chocolate Spread\"","type":"codeVoice"},{"type":"text","text":", "},{"type":"codeVoice","code":"\"Cheese\""},{"text":", ","type":"text"},{"type":"codeVoice","code":"\"Butter\""},{"type":"text","text":"를 "},{"type":"codeVoice","code":"\"Bananas\""},{"text":"와 ","type":"text"},{"code":"\"Apples\"","type":"codeVoice"},{"text":"로 대체한다:","type":"text"}],"type":"paragraph"},{"type":"codeListing","code":["shoppingList[4...6] = [\"Bananas\", \"Apples\"]","\/\/ shoppingList는 이제 6개의 아이템을 포함한다"],"syntax":"swift"},{"inlineContent":[{"type":"text","text":"특정 인덱스에 아이템을 삽입하려면 "},{"code":"insert(_:at:)","type":"codeVoice"},{"type":"text","text":" 메서드를 호출한다:"}],"type":"paragraph"},{"syntax":"swift","type":"codeListing","code":["shoppingList.insert(\"Maple Syrup\", at: 0)","\/\/ shoppingList는 이제 7개의 아이템을 포함한다","\/\/ \"Maple Syrup\"가 이제 리스트의 첫 번째 아이템이다"]},{"inlineContent":[{"type":"codeVoice","code":"insert(_:at:)"},{"type":"text","text":" 메서드를 호출하면 "},{"code":"\"Maple Syrup\"","type":"codeVoice"},{"type":"text","text":"라는 새 아이템이 쇼핑 리스트의 맨 앞에 삽입된다. 이때 인덱스는 "},{"code":"0","type":"codeVoice"},{"text":"이다.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"text":"마찬가지로, ","type":"text"},{"type":"codeVoice","code":"remove(at:)"},{"type":"text","text":" 메서드를 사용해 배열에서 아이템을 제거할 수 있다. 이 메서드는 지정한 인덱스의 아이템을 제거하고 제거된 아이템을 반환한다 (반환된 값이 필요하지 않다면 무시해도 된다):"}],"type":"paragraph"},{"syntax":"swift","code":["let mapleSyrup = shoppingList.remove(at: 0)","\/\/ 인덱스 0에 있던 아이템이 방금 제거되었다","\/\/ shoppingList는 이제 6개의 아이템을 포함하며, \"Maple Syrup\"는 없다","\/\/ mapleSyrup 상수는 이제 제거된 \"Maple Syrup\" 문자열과 같다"],"type":"codeListing"},{"name":"참고","style":"note","type":"aside","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"배열의 현재 범위를 벗어난 인덱스로 값을 접근하거나 수정하려고 하면 런타임 오류가 발생한다. 인덱스를 사용하기 전에 배열의 "},{"type":"codeVoice","code":"count"},{"type":"text","text":" 프로퍼티와 비교해 유효한지 확인할 수 있다. 배열의 가장 큰 유효한 인덱스는 "},{"type":"codeVoice","code":"count - 1"},{"text":"이다. 배열은 0부터 인덱싱되기 때문이다. 그러나 ","type":"text"},{"type":"codeVoice","code":"count"},{"text":"가 ","type":"text"},{"code":"0","type":"codeVoice"},{"text":"인 경우 (즉, 배열이 비어 있는 경우) 유효한 인덱스는 없다.","type":"text"}]}]},{"inlineContent":[{"text":"아이템을 제거하면 배열의 빈 공간이 채워지므로, 인덱스 ","type":"text"},{"code":"0","type":"codeVoice"},{"text":"의 값은 다시 ","type":"text"},{"type":"codeVoice","code":"\"Six eggs\""},{"type":"text","text":"가 된다:"}],"type":"paragraph"},{"syntax":"swift","code":["firstItem = shoppingList[0]","\/\/ firstItem은 이제 \"Six eggs\"와 같다"],"type":"codeListing"},{"inlineContent":[{"type":"text","text":"배열의 마지막 아이템을 제거하려면 "},{"type":"codeVoice","code":"remove(at:)"},{"type":"text","text":" 메서드 대신 "},{"type":"codeVoice","code":"removeLast()"},{"text":" 메서드를 사용한다. 이렇게 하면 배열의 ","type":"text"},{"code":"count","type":"codeVoice"},{"type":"text","text":" 프로퍼티를 쿼리할 필요가 없다. "},{"type":"codeVoice","code":"remove(at:)"},{"text":" 메서드와 마찬가지로, ","type":"text"},{"type":"codeVoice","code":"removeLast()"},{"text":"는 제거된 아이템을 반환한다:","type":"text"}],"type":"paragraph"},{"syntax":"swift","code":["let apples = shoppingList.removeLast()","\/\/ 배열의 마지막 아이템이 방금 제거되었다","\/\/ shoppingList는 이제 5개의 아이템을 포함하며, \"Apples\"는 없다","\/\/ apples 상수는 이제 제거된 \"Apples\" 문자열과 같다"],"type":"codeListing"},{"text":"배열 순회하기","type":"heading","level":3,"anchor":"%EB%B0%B0%EC%97%B4-%EC%88%9C%ED%9A%8C%ED%95%98%EA%B8%B0"},{"type":"paragraph","inlineContent":[{"text":"배열에 있는 모든 값을 순회하려면 ","type":"text"},{"type":"codeVoice","code":"for"},{"text":"-","type":"text"},{"type":"codeVoice","code":"in"},{"text":" 루프를 사용한다:","type":"text"}]},{"syntax":"swift","type":"codeListing","code":["for item in shoppingList {","    print(item)","}","\/\/ Six eggs","\/\/ Milk","\/\/ Flour","\/\/ Baking Powder","\/\/ Bananas"]},{"type":"paragraph","inlineContent":[{"text":"각 항목의 값과 함께 정수 인덱스도 필요하다면, ","type":"text"},{"type":"codeVoice","code":"enumerated()"},{"text":" 메서드를 사용해 배열을 순회한다. 배열의 각 항목에 대해 ","type":"text"},{"type":"codeVoice","code":"enumerated()"},{"type":"text","text":" 메서드는 정수와 항목으로 구성된 튜플을 반환한다. 정수는 0부터 시작해 각 항목마다 1씩 증가한다. 전체 배열을 순회하면 이 정수는 항목의 인덱스와 일치한다. 순회 과정에서 튜플을 임시 상수나 변수로 분해할 수 있다:"}]},{"type":"codeListing","syntax":"swift","code":["for (index, value) in shoppingList.enumerated() {","    print(\"Item \\(index + 1): \\(value)\")","}","\/\/ Item 1: Six eggs","\/\/ Item 2: Milk","\/\/ Item 3: Flour","\/\/ Item 4: Baking Powder","\/\/ Item 5: Bananas"]},{"type":"paragraph","inlineContent":[{"type":"codeVoice","code":"for"},{"type":"text","text":"-"},{"type":"codeVoice","code":"in"},{"type":"text","text":" 루프에 대한 자세한 내용은 "},{"type":"text","text":"doc:ControlFlow#For-In-Loops"},{"type":"text","text":"를 참고한다."}]},{"level":2,"text":"집합(Set)","type":"heading","anchor":"%EC%A7%91%ED%95%A9Set"},{"type":"paragraph","inlineContent":[{"type":"text","text":"*집합(Set)*은 순서가 정의되지 않은 컬렉션에 동일한 타입의 고유한 값들을 저장한다. 항목의 순서가 중요하지 않거나, 특정 항목이 단 한 번만 나타나도록 보장해야 할 때 배열 대신 집합을 사용할 수 있다."}]},{"name":"참고","style":"note","content":[{"inlineContent":[{"text":"Swift의 ","type":"text"},{"code":"Set","type":"codeVoice"},{"type":"text","text":" 타입은 Foundation의 "},{"type":"codeVoice","code":"NSSet"},{"text":" 클래스와 브리징된다.","type":"text"},{"text":"\n","type":"text"},{"type":"text","text":"Foundation 및 Cocoa에서 "},{"type":"codeVoice","code":"Set"},{"text":"을 사용하는 방법에 대한 자세한 내용은 ","type":"text"},{"type":"reference","isActive":true,"identifier":"https:\/\/developer.apple.com\/documentation\/swift\/set#2845530"},{"type":"text","text":"을 참고한다."}],"type":"paragraph"}],"type":"aside"},{"anchor":"%EC%A7%91%ED%95%A9-%ED%83%80%EC%9E%85%EC%9D%98-%ED%95%B4%EC%8B%9C-%EA%B0%92","level":3,"type":"heading","text":"집합 타입의 해시 값"},{"type":"paragraph","inlineContent":[{"type":"text","text":"어떤 타입을 집합에 저장하려면 "},{"inlineContent":[{"type":"text","text":"해시 가능"}],"type":"emphasis"},{"type":"text","text":" 해야 한다. 즉, 해당 타입은 자신의 "},{"type":"emphasis","inlineContent":[{"type":"text","text":"해시 값"}]},{"type":"text","text":"을 계산할 수 있는 방법을 제공해야 한다. 해시 값은 동일한 객체에 대해 항상 같은 "},{"code":"Int","type":"codeVoice"},{"type":"text","text":" 값이다. 예를 들어 "},{"type":"codeVoice","code":"a == b"},{"text":"일 때, ","type":"text"},{"code":"a","type":"codeVoice"},{"type":"text","text":"의 해시 값은 "},{"code":"b","type":"codeVoice"},{"type":"text","text":"의 해시 값과 같다."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Swift의 기본 타입들(예: "},{"type":"codeVoice","code":"String"},{"text":", ","type":"text"},{"code":"Int","type":"codeVoice"},{"type":"text","text":", "},{"code":"Double","type":"codeVoice"},{"type":"text","text":", "},{"type":"codeVoice","code":"Bool"},{"text":")은 기본적으로 해시 가능하며, 집합의 값 타입이나 딕셔너리의 키 타입으로 사용할 수 있다. 또한, 연관 값을 가지지 않는 열거형 케이스 값들도 기본적으로 해시 가능하다.","type":"text"}]},{"type":"aside","style":"note","name":"참고","content":[{"inlineContent":[{"type":"text","text":"커스텀 타입을 집합의 값 타입이나 딕셔너리의 키 타입으로 사용하려면 Swift 표준 라이브러리의 "},{"type":"codeVoice","code":"Hashable"},{"type":"text","text":" 프로토콜을 준수하게 만들면 된다. 필요한 "},{"type":"codeVoice","code":"hash(into:)"},{"type":"text","text":" 메서드를 구현하는 방법에 대한 자세한 내용은 "},{"isActive":true,"identifier":"https:\/\/developer.apple.com\/documentation\/swift\/hashable","type":"reference"},{"type":"text","text":"을 참고하라. 프로토콜 준수에 대한 정보는 "},{"type":"reference","identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Protocols","isActive":true},{"text":"에서 확인할 수 있다.","type":"text"}],"type":"paragraph"}]},{"level":3,"type":"heading","text":"Set 타입 구문","anchor":"Set-%ED%83%80%EC%9E%85-%EA%B5%AC%EB%AC%B8"},{"type":"paragraph","inlineContent":[{"text":"Swift에서 Set의 타입은 ","type":"text"},{"type":"codeVoice","code":"Set<Element>"},{"type":"text","text":"로 작성한다. 여기서 "},{"type":"codeVoice","code":"Element"},{"text":"는 Set이 저장할 수 있는 값의 타입을 나타낸다. 배열과 달리 Set은 간단한 축약 형태가 없다.","type":"text"}]},{"level":3,"anchor":"%EB%B9%88-Set-%EC%83%9D%EC%84%B1-%EB%B0%8F-%EC%B4%88%EA%B8%B0%ED%99%94","type":"heading","text":"빈 Set 생성 및 초기화"},{"type":"paragraph","inlineContent":[{"type":"text","text":"특정 타입의 빈 Set을 생성하려면 초기화 구문을 사용한다:"}]},{"type":"codeListing","syntax":"swift","code":["var letters = Set<Character>()","print(\"letters is of type Set<Character> with \\(letters.count) items.\")","\/\/ Prints \"letters is of type Set<Character> with 0 items.\""]},{"name":"참고","type":"aside","style":"note","content":[{"inlineContent":[{"text":"","type":"text"},{"code":"letters","type":"codeVoice"},{"text":" 변수의 타입은 초기화 구문의 타입에서 ","type":"text"},{"type":"codeVoice","code":"Set<Character>"},{"type":"text","text":"로 추론된다."}],"type":"paragraph"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"또한, 함수 인자나 이미 타입이 지정된 변수 또는 상수와 같이 컨텍스트가 이미 타입 정보를 제공하는 경우, 빈 배열 리터럴을 사용해 빈 Set을 생성할 수 있다:"}]},{"code":["letters.insert(\"a\")","\/\/ letters now contains 1 value of type Character","letters = []","\/\/ letters is now an empty set, but is still of type Set<Character>"],"type":"codeListing","syntax":"swift"},{"type":"heading","text":"배열 리터럴로 Set 생성하기","level":3,"anchor":"%EB%B0%B0%EC%97%B4-%EB%A6%AC%ED%84%B0%EB%9F%B4%EB%A1%9C-Set-%EC%83%9D%EC%84%B1%ED%95%98%EA%B8%B0"},{"inlineContent":[{"type":"text","text":"배열 리터럴을 사용해 Set을 초기화할 수 있다. 이는 하나 이상의 값을 Set 컬렉션으로 간단히 표현하는 방법이다."}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"type":"text","text":"아래 예제는 "},{"code":"String","type":"codeVoice"},{"type":"text","text":" 타입의 값을 저장하는 "},{"code":"favoriteGenres","type":"codeVoice"},{"text":"라는 Set을 생성한다:","type":"text"}]},{"type":"codeListing","code":["var favoriteGenres: Set<String> = [\"Rock\", \"Classical\", \"Hip hop\"]","\/\/ favoriteGenres는 초기값으로 세 개의 항목을 가지고 있다"],"syntax":"swift"},{"inlineContent":[{"type":"codeVoice","code":"favoriteGenres"},{"type":"text","text":" 변수는 “"},{"type":"codeVoice","code":"String"},{"type":"text","text":" 값들의 Set”으로 선언되었으며, 이는 "},{"type":"codeVoice","code":"Set<String>"},{"type":"text","text":"으로 표기된다. 이 특정 Set은 "},{"type":"codeVoice","code":"String"},{"type":"text","text":" 타입의 값만 저장할 수 있다. 여기서 "},{"code":"favoriteGenres","type":"codeVoice"},{"text":" Set은 배열 리터럴 안에 작성된 세 개의 ","type":"text"},{"code":"String","type":"codeVoice"},{"type":"text","text":" 값("},{"code":"\"Rock\"","type":"codeVoice"},{"type":"text","text":", "},{"code":"\"Classical\"","type":"codeVoice"},{"type":"text","text":", "},{"code":"\"Hip hop\"","type":"codeVoice"},{"type":"text","text":")으로 초기화되었다."}],"type":"paragraph"},{"content":[{"type":"paragraph","inlineContent":[{"text":"","type":"text"},{"type":"codeVoice","code":"favoriteGenres"},{"type":"text","text":" Set은 변수로 선언되었으며("},{"code":"var","type":"codeVoice"},{"type":"text","text":" 키워드 사용), 상수가 아니다("},{"code":"let","type":"codeVoice"},{"type":"text","text":" 키워드 사용). 이는 아래 예제에서 항목을 추가하고 제거하기 때문이다."}]}],"style":"note","name":"참고","type":"aside"},{"inlineContent":[{"type":"text","text":"Set 타입은 배열 리터럴만으로는 추론할 수 없으므로, "},{"type":"codeVoice","code":"Set"},{"text":" 타입을 명시적으로 선언해야 한다. 그러나 Swift의 타입 추론 덕분에, 배열 리터럴이 단일 타입의 값만 포함하고 있다면 Set의 요소 타입을 작성하지 않아도 된다. ","type":"text"},{"type":"codeVoice","code":"favoriteGenres"},{"type":"text","text":"의 초기화는 다음과 같이 더 짧게 작성할 수 있다:"}],"type":"paragraph"},{"syntax":"swift","code":["var favoriteGenres: Set = [\"Rock\", \"Classical\", \"Hip hop\"]"],"type":"codeListing"},{"type":"paragraph","inlineContent":[{"type":"text","text":"배열 리터럴의 모든 값이 동일한 타입이기 때문에, Swift는 "},{"type":"codeVoice","code":"favoriteGenres"},{"type":"text","text":" 변수에 사용할 타입이 "},{"type":"codeVoice","code":"Set<String>"},{"type":"text","text":"임을 추론할 수 있다."}]},{"type":"heading","text":"집합(Set) 접근 및 수정","level":3,"anchor":"%EC%A7%91%ED%95%A9Set-%EC%A0%91%EA%B7%BC-%EB%B0%8F-%EC%88%98%EC%A0%95"},{"type":"paragraph","inlineContent":[{"type":"text","text":"집합을 다루려면 메서드와 프로퍼티를 사용한다."}]},{"type":"paragraph","inlineContent":[{"text":"집합에 포함된 항목의 개수를 확인하려면 ","type":"text"},{"code":"count","type":"codeVoice"},{"type":"text","text":" 프로퍼티를 사용한다:"}]},{"type":"codeListing","syntax":"swift","code":["print(\"I have \\(favoriteGenres.count) favorite music genres.\")","\/\/ Prints \"I have 3 favorite music genres.\""]},{"type":"paragraph","inlineContent":[{"code":"count","type":"codeVoice"},{"text":" 프로퍼티가 ","type":"text"},{"type":"codeVoice","code":"0"},{"text":"인지 확인하는 단축키로 ","type":"text"},{"code":"isEmpty","type":"codeVoice"},{"type":"text","text":" 프로퍼티를 사용한다:"}]},{"syntax":"swift","type":"codeListing","code":["if favoriteGenres.isEmpty {","    print(\"As far as music goes, I'm not picky.\")","} else {","    print(\"I have particular music preferences.\")","}","\/\/ Prints \"I have particular music preferences.\""]},{"type":"paragraph","inlineContent":[{"type":"text","text":"새 항목을 추가하려면 "},{"type":"codeVoice","code":"insert(_:)"},{"type":"text","text":" 메서드를 호출한다:"}]},{"type":"codeListing","syntax":"swift","code":["favoriteGenres.insert(\"Jazz\")","\/\/ favoriteGenres now contains 4 items"]},{"inlineContent":[{"type":"text","text":"항목을 제거하려면 "},{"type":"codeVoice","code":"remove(_:)"},{"type":"text","text":" 메서드를 호출한다. 이 메서드는 집합에 해당 항목이 있으면 제거하고 제거된 값을 반환하며, 항목이 없으면 "},{"type":"codeVoice","code":"nil"},{"text":"을 반환한다. 모든 항목을 한 번에 제거하려면 ","type":"text"},{"code":"removeAll()","type":"codeVoice"},{"text":" 메서드를 사용한다.","type":"text"}],"type":"paragraph"},{"type":"codeListing","code":["if let removedGenre = favoriteGenres.remove(\"Rock\") {","    print(\"\\(removedGenre)? I'm over it.\")","} else {","    print(\"I never much cared for that.\")","}","\/\/ Prints \"Rock? I'm over it.\""],"syntax":"swift"},{"inlineContent":[{"type":"text","text":"특정 항목이 집합에 포함되어 있는지 확인하려면 "},{"type":"codeVoice","code":"contains(_:)"},{"text":" 메서드를 사용한다.","type":"text"}],"type":"paragraph"},{"code":["if favoriteGenres.contains(\"Funk\") {","    print(\"I get up on the good foot.\")","} else {","    print(\"It's too funky in here.\")","}","\/\/ Prints \"It's too funky in here.\""],"type":"codeListing","syntax":"swift"},{"type":"heading","text":"Set 순회하기","anchor":"Set-%EC%88%9C%ED%9A%8C%ED%95%98%EA%B8%B0","level":3},{"type":"paragraph","inlineContent":[{"code":"for-in","type":"codeVoice"},{"type":"text","text":" 루프를 사용해 Set의 값을 순회할 수 있다."}]},{"code":["for genre in favoriteGenres {","    print(\"\\(genre)\")","}","\/\/ Classical","\/\/ Jazz","\/\/ Hip hop"],"type":"codeListing","syntax":"swift"},{"type":"paragraph","inlineContent":[{"type":"codeVoice","code":"for-in"},{"type":"text","text":" 루프에 대한 자세한 내용은 "},{"text":"doc:ControlFlow#For-In-Loops","type":"text"},{"type":"text","text":"를 참고한다."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Swift의 "},{"code":"Set","type":"codeVoice"},{"type":"text","text":" 타입은 정의된 순서가 없다. 특정 순서로 Set의 값을 순회하려면 "},{"type":"codeVoice","code":"sorted()"},{"type":"text","text":" 메서드를 사용한다. 이 메서드는 "},{"type":"codeVoice","code":"<"},{"text":" 연산자를 사용해 정렬된 배열로 Set의 요소를 반환한다.","type":"text"}]},{"code":["for genre in favoriteGenres.sorted() {","    print(\"\\(genre)\")","}","\/\/ Classical","\/\/ Hip hop","\/\/ Jazz"],"syntax":"swift","type":"codeListing"},{"text":"집합 연산 수행하기","anchor":"%EC%A7%91%ED%95%A9-%EC%97%B0%EC%82%B0-%EC%88%98%ED%96%89%ED%95%98%EA%B8%B0","type":"heading","level":2},{"type":"paragraph","inlineContent":[{"type":"text","text":"두 집합을 효율적으로 결합하거나, 두 집합이 공통으로 가지는 값을 찾거나, 두 집합이 같은 값을 모두 포함하는지, 일부만 포함하는지, 아니면 전혀 포함하지 않는지 확인하는 등 기본적인 집합 연산을 수행할 수 있다."}]},{"anchor":"%EA%B8%B0%EB%B3%B8-%EC%A7%91%ED%95%A9-%EC%97%B0%EC%82%B0","level":3,"text":"기본 집합 연산","type":"heading"},{"type":"paragraph","inlineContent":[{"text":"아래 그림은 두 집합 ","type":"text"},{"code":"a","type":"codeVoice"},{"type":"text","text":"와 "},{"code":"b","type":"codeVoice"},{"text":"를 보여주며, 다양한 집합 연산의 결과를 음영 처리된 영역으로 표현한다.","type":"text"}]},{"type":"paragraph","inlineContent":[{"type":"image","identifier":"setVennDiagram"}]},{"items":[{"content":[{"inlineContent":[{"type":"codeVoice","code":"intersection(_:)"},{"text":" 메서드를 사용해 두 집합에 공통된 값만 포함된 새로운 집합을 생성한다.","type":"text"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"code":"symmetricDifference(_:)","type":"codeVoice"},{"text":" 메서드를 사용해 두 집합 중 하나에만 포함된 값을 가진 새로운 집합을 생성한다.","type":"text"}]}]},{"content":[{"inlineContent":[{"type":"codeVoice","code":"union(_:)"},{"type":"text","text":" 메서드를 사용해 두 집합의 모든 값을 포함한 새로운 집합을 생성한다."}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"type":"codeVoice","code":"subtracting(_:)"},{"type":"text","text":" 메서드를 사용해 지정된 집합에 없는 값을 가진 새로운 집합을 생성한다."}],"type":"paragraph"}]}],"type":"unorderedList"},{"code":["let oddDigits: Set = [1, 3, 5, 7, 9]","let evenDigits: Set = [0, 2, 4, 6, 8]","let singleDigitPrimeNumbers: Set = [2, 3, 5, 7]","","oddDigits.union(evenDigits).sorted()","\/\/ [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]","oddDigits.intersection(evenDigits).sorted()","\/\/ []","oddDigits.subtracting(singleDigitPrimeNumbers).sorted()","\/\/ [1, 9]","oddDigits.symmetricDifference(singleDigitPrimeNumbers).sorted()","\/\/ [1, 2, 9]"],"type":"codeListing","syntax":"swift"},{"anchor":"%EC%A7%91%ED%95%A9%EC%9D%98-%ED%8F%AC%ED%95%A8-%EA%B4%80%EA%B3%84%EC%99%80-%EB%8F%99%EB%93%B1%EC%84%B1","text":"집합의 포함 관계와 동등성","level":3,"type":"heading"},{"type":"paragraph","inlineContent":[{"type":"text","text":"아래 그림은 세 개의 집합 "},{"code":"a","type":"codeVoice"},{"text":", ","type":"text"},{"code":"b","type":"codeVoice"},{"type":"text","text":", "},{"code":"c","type":"codeVoice"},{"type":"text","text":"를 보여준다. 겹치는 영역은 집합 간 공유되는 요소를 나타낸다. 집합 "},{"code":"a","type":"codeVoice"},{"type":"text","text":"는 집합 "},{"type":"codeVoice","code":"b"},{"type":"text","text":"의 *상위 집합(superset)*이다. 왜냐하면 "},{"code":"a","type":"codeVoice"},{"type":"text","text":"는 "},{"type":"codeVoice","code":"b"},{"text":"의 모든 요소를 포함하기 때문이다. 반대로, 집합 ","type":"text"},{"code":"b","type":"codeVoice"},{"type":"text","text":"는 집합 "},{"code":"a","type":"codeVoice"},{"text":"의 *하위 집합(subset)*이다. ","type":"text"},{"code":"b","type":"codeVoice"},{"text":"의 모든 요소가 ","type":"text"},{"type":"codeVoice","code":"a"},{"type":"text","text":"에 포함되기 때문이다. 집합 "},{"code":"b","type":"codeVoice"},{"type":"text","text":"와 "},{"code":"c","type":"codeVoice"},{"type":"text","text":"는 서로 "},{"inlineContent":[{"type":"text","text":"서로소(disjoint)"}],"type":"emphasis"},{"type":"text","text":" 관계이다. 두 집합 간 공통 요소가 없기 때문이다."}]},{"inlineContent":[{"type":"image","identifier":"setEulerDiagram"}],"type":"paragraph"},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"text":"두 집합이 동일한 값을 모두 포함하는지 확인하려면 “is equal” 연산자(","type":"text"},{"type":"codeVoice","code":"=="},{"text":")를 사용한다.","type":"text"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"한 집합의 모든 값이 특정 집합에 포함되는지 확인하려면 "},{"code":"isSubset(of:)","type":"codeVoice"},{"type":"text","text":" 메서드를 사용한다."}]}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"한 집합이 특정 집합의 모든 값을 포함하는지 확인하려면 ","type":"text"},{"type":"codeVoice","code":"isSuperset(of:)"},{"text":" 메서드를 사용한다.","type":"text"}]}]},{"content":[{"inlineContent":[{"text":"한 집합이 특정 집합의 하위 집합 또는 상위 집합이지만 동일하지는 않은지 확인하려면 ","type":"text"},{"type":"codeVoice","code":"isStrictSubset(of:)"},{"type":"text","text":" 또는 "},{"type":"codeVoice","code":"isStrictSuperset(of:)"},{"text":" 메서드를 사용한다.","type":"text"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"text":"두 집합이 공통된 값을 전혀 가지고 있지 않은지 확인하려면 ","type":"text"},{"code":"isDisjoint(with:)","type":"codeVoice"},{"type":"text","text":" 메서드를 사용한다."}],"type":"paragraph"}]}],"type":"unorderedList"},{"code":["let houseAnimals: Set = [\"🐶\", \"🐱\"]","let farmAnimals: Set = [\"🐮\", \"🐔\", \"🐑\", \"🐶\", \"🐱\"]","let cityAnimals: Set = [\"🐦\", \"🐭\"]","","houseAnimals.isSubset(of: farmAnimals)","\/\/ true","farmAnimals.isSuperset(of: houseAnimals)","\/\/ true","farmAnimals.isDisjoint(with: cityAnimals)","\/\/ true"],"type":"codeListing","syntax":"swift"},{"anchor":"%EB%94%95%EC%85%94%EB%84%88%EB%A6%AC","level":2,"text":"딕셔너리","type":"heading"},{"inlineContent":[{"inlineContent":[{"type":"text","text":"딕셔너리"}],"type":"emphasis"},{"type":"text","text":"는 동일한 타입의 키와 동일한 타입의 값 사이의 연관 관계를 저장하는 컬렉션이다. 딕셔너리에서는 순서가 정의되지 않는다. 각 값은 고유한 "},{"type":"emphasis","inlineContent":[{"type":"text","text":"키"}]},{"type":"text","text":"와 연결되며, 이 키는 딕셔너리 내에서 해당 값을 식별하는 역할을 한다. 배열의 항목과 달리 딕셔너리의 항목은 특정 순서를 가지지 않는다. 딕셔너리는 식별자를 기반으로 값을 조회해야 할 때 사용한다. 실제 사전에서 특정 단어의 정의를 찾는 방식과 유사하다."}],"type":"paragraph"},{"name":"참고","type":"aside","style":"note","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Swift의 "},{"type":"codeVoice","code":"Dictionary"},{"text":" 타입은 Foundation의 ","type":"text"},{"code":"NSDictionary","type":"codeVoice"},{"type":"text","text":" 클래스와 연결된다."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Foundation과 Cocoa에서 "},{"code":"Dictionary","type":"codeVoice"},{"text":"를 사용하는 방법에 대한 자세한 내용은 ","type":"text"},{"isActive":true,"identifier":"https:\/\/developer.apple.com\/documentation\/swift\/dictionary#2846239","type":"reference"},{"text":"를 참고한다.","type":"text"}]}]},{"type":"heading","level":3,"text":"딕셔너리 타입의 축약형 문법","anchor":"%EB%94%95%EC%85%94%EB%84%88%EB%A6%AC-%ED%83%80%EC%9E%85%EC%9D%98-%EC%B6%95%EC%95%BD%ED%98%95-%EB%AC%B8%EB%B2%95"},{"inlineContent":[{"type":"text","text":"스위프트에서 딕셔너리의 타입은 "},{"type":"codeVoice","code":"Dictionary<Key, Value>"},{"type":"text","text":"로 작성한다. 여기서 "},{"type":"codeVoice","code":"Key"},{"type":"text","text":"는 딕셔너리의 키로 사용할 수 있는 값의 타입을 나타내고, "},{"type":"codeVoice","code":"Value"},{"type":"text","text":"는 해당 키에 저장될 값의 타입을 나타낸다."}],"type":"paragraph"},{"style":"note","name":"참고","type":"aside","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"딕셔너리의 "},{"code":"Key","type":"codeVoice"},{"type":"text","text":" 타입은 "},{"type":"codeVoice","code":"Hashable"},{"text":" 프로토콜을 준수해야 한다. 이는 세트의 값 타입과 동일한 요구사항이다.","type":"text"}]}]},{"type":"paragraph","inlineContent":[{"text":"딕셔너리의 타입을 ","type":"text"},{"code":"[Key: Value]","type":"codeVoice"},{"type":"text","text":"와 같은 축약형으로 작성할 수도 있다. 두 형식은 기능적으로 동일하지만, 가이드 전반에 걸쳐 딕셔너리 타입을 언급할 때는 축약형을 주로 사용한다."}]},{"level":3,"anchor":"%EB%B9%88-%EB%94%95%EC%85%94%EB%84%88%EB%A6%AC-%EC%83%9D%EC%84%B1%ED%95%98%EA%B8%B0","text":"빈 딕셔너리 생성하기","type":"heading"},{"type":"paragraph","inlineContent":[{"type":"text","text":"배열과 마찬가지로, 특정 타입의 빈 "},{"type":"codeVoice","code":"딕셔너리"},{"type":"text","text":"를 초기화 구문을 사용해 생성할 수 있다:"}]},{"syntax":"swift","code":["var namesOfIntegers: [Int: String] = [:]","\/\/ namesOfIntegers는 빈 [Int: String] 딕셔너리다"],"type":"codeListing"},{"type":"paragraph","inlineContent":[{"type":"text","text":"이 예제는 정수 값의 사람이 읽을 수 있는 이름을 저장하기 위해 "},{"type":"codeVoice","code":"[Int: String]"},{"type":"text","text":" 타입의 빈 딕셔너리를 생성한다. 키는 "},{"type":"codeVoice","code":"Int"},{"text":" 타입이고, 값은 ","type":"text"},{"code":"String","type":"codeVoice"},{"type":"text","text":" 타입이다."}]},{"inlineContent":[{"type":"text","text":"만약 컨텍스트가 이미 타입 정보를 제공한다면, 빈 딕셔너리 리터럴("},{"code":"[:]","type":"codeVoice"},{"type":"text","text":", 즉 대괄호 안에 콜론)을 사용해 빈 딕셔너리를 생성할 수 있다:"}],"type":"paragraph"},{"type":"codeListing","syntax":"swift","code":["namesOfIntegers[16] = \"sixteen\"","\/\/ namesOfIntegers는 이제 1개의 키-값 쌍을 포함한다","namesOfIntegers = [:]","\/\/ namesOfIntegers는 다시 [Int: String] 타입의 빈 딕셔너리가 된다"]},{"level":3,"anchor":"%EB%94%95%EC%85%94%EB%84%88%EB%A6%AC-%EB%A6%AC%ED%84%B0%EB%9F%B4%EB%A1%9C-%EB%94%95%EC%85%94%EB%84%88%EB%A6%AC-%EC%83%9D%EC%84%B1%ED%95%98%EA%B8%B0","text":"딕셔너리 리터럴로 딕셔너리 생성하기","type":"heading"},{"inlineContent":[{"type":"text","text":"이전에 살펴본 배열 리터럴과 유사한 문법을 사용해 딕셔너리를 초기화할 수도 있다. 딕셔너리 리터럴은 하나 이상의 키-값 쌍을 "},{"code":"Dictionary","type":"codeVoice"},{"type":"text","text":" 컬렉션으로 간단히 표현하는 방법이다."}],"type":"paragraph"},{"inlineContent":[{"text":"키-값 쌍은 키와 값의 조합이다. 딕셔너리 리터럴에서 각 키-값 쌍은 콜론으로 구분되며, 여러 쌍은 쉼표로 구분된 목록 형태로 작성된다. 전체는 대괄호로 둘러싸인다:","type":"text"}],"type":"paragraph"},{"code":["[<#key 1#>: <#value 1#>, <#key 2#>: <#value 2#>, <#key 3#>: <#value 3#>]"],"syntax":"swift","type":"codeListing"},{"inlineContent":[{"type":"text","text":"아래 예제는 국제 공항의 이름을 저장하기 위한 딕셔너리를 생성한다. 이 딕셔너리에서 키는 국제 항공 운송 협회(IATA) 코드이며, 값은 공항 이름이다:"}],"type":"paragraph"},{"syntax":"swift","type":"codeListing","code":["var airports: [String: String] = [\"YYZ\": \"Toronto Pearson\", \"DUB\": \"Dublin\"]"]},{"type":"paragraph","inlineContent":[{"type":"codeVoice","code":"airports"},{"type":"text","text":" 딕셔너리는 "},{"type":"codeVoice","code":"[String: String]"},{"type":"text","text":" 타입으로 선언되었다. 이는 “키가 "},{"type":"codeVoice","code":"String"},{"text":" 타입이고, 값도 ","type":"text"},{"type":"codeVoice","code":"String"},{"type":"text","text":" 타입인 "},{"code":"Dictionary","type":"codeVoice"},{"text":"“를 의미한다.","type":"text"}]},{"name":"참고","content":[{"inlineContent":[{"type":"text","text":""},{"code":"airports","type":"codeVoice"},{"type":"text","text":" 딕셔너리는 "},{"type":"codeVoice","code":"var"},{"type":"text","text":" 키워드로 변수로 선언되었으며, "},{"type":"codeVoice","code":"let"},{"text":" 키워드로 상수로 선언되지 않았다. 이는 아래 예제에서 더 많은 공항을 딕셔너리에 추가하기 위함이다.","type":"text"}],"type":"paragraph"}],"style":"note","type":"aside"},{"type":"paragraph","inlineContent":[{"code":"airports","type":"codeVoice"},{"text":" 딕셔너리는 두 개의 키-값 쌍을 포함하는 딕셔너리 리터럴로 초기화되었다. 첫 번째 쌍은 키가 ","type":"text"},{"code":"\"YYZ\"","type":"codeVoice"},{"text":"이고 값이 ","type":"text"},{"code":"\"Toronto Pearson\"","type":"codeVoice"},{"type":"text","text":"이다. 두 번째 쌍은 키가 "},{"code":"\"DUB\"","type":"codeVoice"},{"type":"text","text":"이고 값이 "},{"type":"codeVoice","code":"\"Dublin\""},{"text":"이다.","type":"text"}]},{"inlineContent":[{"text":"이 딕셔너리 리터럴은 두 개의 ","type":"text"},{"code":"String: String","type":"codeVoice"},{"text":" 쌍을 포함한다. 이 키-값 타입은 ","type":"text"},{"type":"codeVoice","code":"airports"},{"text":" 변수 선언의 타입(키와 값이 모두 ","type":"text"},{"code":"String","type":"codeVoice"},{"type":"text","text":"인 딕셔너리)과 일치하므로, 딕셔너리 리터럴을 "},{"type":"codeVoice","code":"airports"},{"type":"text","text":" 딕셔너리를 초기화하는 데 사용할 수 있다."}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"배열과 마찬가지로, 딕셔너리를 키와 값의 타입이 일관된 딕셔너리 리터럴로 초기화할 때는 타입을 명시적으로 작성하지 않아도 된다. "},{"code":"airports","type":"codeVoice"},{"type":"text","text":" 초기화를 더 짧은 형태로 작성할 수 있다:"}],"type":"paragraph"},{"syntax":"swift","type":"codeListing","code":["var airports = [\"YYZ\": \"Toronto Pearson\", \"DUB\": \"Dublin\"]"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"리터럴의 모든 키가 동일한 타입이고, 모든 값도 동일한 타입이므로, Swift는 "},{"type":"codeVoice","code":"[String: String]"},{"type":"text","text":"이 "},{"type":"codeVoice","code":"airports"},{"text":" 딕셔너리에 적합한 타입임을 추론할 수 있다.","type":"text"}]},{"level":3,"type":"heading","anchor":"%EB%94%95%EC%85%94%EB%84%88%EB%A6%AC-%EC%A0%91%EA%B7%BC-%EB%B0%8F-%EC%88%98%EC%A0%95","text":"딕셔너리 접근 및 수정"},{"type":"paragraph","inlineContent":[{"text":"딕셔너리에 접근하고 수정할 때는 메서드와 프로퍼티를 사용하거나, 서브스크립트 문법을 활용한다.","type":"text"}]},{"inlineContent":[{"text":"배열과 마찬가지로, ","type":"text"},{"type":"codeVoice","code":"Dictionary"},{"text":"의 항목 수를 확인하려면 읽기 전용 프로퍼티인 ","type":"text"},{"type":"codeVoice","code":"count"},{"type":"text","text":"를 사용한다:"}],"type":"paragraph"},{"type":"codeListing","syntax":"swift","code":["print(\"The airports dictionary contains \\(airports.count) items.\")","\/\/ Prints \"The airports dictionary contains 2 items.\""]},{"inlineContent":[{"type":"codeVoice","code":"count"},{"text":" 프로퍼티가 ","type":"text"},{"type":"codeVoice","code":"0"},{"type":"text","text":"인지 확인하는 단축키로, 불리언 프로퍼티인 "},{"code":"isEmpty","type":"codeVoice"},{"text":"를 사용한다:","type":"text"}],"type":"paragraph"},{"syntax":"swift","type":"codeListing","code":["if airports.isEmpty {","    print(\"The airports dictionary is empty.\")","} else {","    print(\"The airports dictionary isn't empty.\")","}","\/\/ Prints \"The airports dictionary isn't empty.\""]},{"inlineContent":[{"type":"text","text":"서브스크립트 문법을 사용해 딕셔너리에 새로운 항목을 추가할 수 있다. 적절한 타입의 새로운 키를 서브스크립트 인덱스로 사용하고, 적절한 타입의 새로운 값을 할당한다:"}],"type":"paragraph"},{"code":["airports[\"LHR\"] = \"London\"","\/\/ the airports dictionary now contains 3 items"],"type":"codeListing","syntax":"swift"},{"inlineContent":[{"text":"특정 키와 연결된 값을 변경할 때도 서브스크립트 문법을 사용할 수 있다:","type":"text"}],"type":"paragraph"},{"code":["airports[\"LHR\"] = \"London Heathrow\"","\/\/ the value for \"LHR\" has been changed to \"London Heathrow\""],"type":"codeListing","syntax":"swift"},{"type":"paragraph","inlineContent":[{"text":"서브스크립트 대신 딕셔너리의 ","type":"text"},{"code":"updateValue(_:forKey:)","type":"codeVoice"},{"type":"text","text":" 메서드를 사용해 특정 키에 대한 값을 설정하거나 업데이트할 수 있다. 위의 서브스크립트 예제와 마찬가지로, "},{"type":"codeVoice","code":"updateValue(_:forKey:)"},{"type":"text","text":" 메서드는 키가 존재하지 않으면 값을 설정하고, 키가 이미 존재하면 값을 업데이트한다. 하지만 서브스크립트와 달리, "},{"code":"updateValue(_:forKey:)","type":"codeVoice"},{"type":"text","text":" 메서드는 업데이트 후 "},{"type":"emphasis","inlineContent":[{"type":"text","text":"이전"}]},{"type":"text","text":" 값을 반환한다. 이를 통해 업데이트가 발생했는지 확인할 수 있다."}]},{"inlineContent":[{"code":"updateValue(_:forKey:)","type":"codeVoice"},{"text":" 메서드는 딕셔너리의 값 타입에 대한 옵셔널 값을 반환한다. 예를 들어, ","type":"text"},{"type":"codeVoice","code":"String"},{"type":"text","text":" 값을 저장하는 딕셔너리의 경우, 이 메서드는 "},{"type":"codeVoice","code":"String?"},{"type":"text","text":" 타입, 즉 “옵셔널 "},{"code":"String","type":"codeVoice"},{"type":"text","text":"” 값을 반환한다. 이 옵셔널 값은 업데이트 전 해당 키에 대한 이전 값을 포함하거나, 값이 존재하지 않았다면 "},{"code":"nil","type":"codeVoice"},{"text":"을 포함한다:","type":"text"}],"type":"paragraph"},{"syntax":"swift","type":"codeListing","code":["if let oldValue = airports.updateValue(\"Dublin Airport\", forKey: \"DUB\") {","    print(\"The old value for DUB was \\(oldValue).\")","}","\/\/ Prints \"The old value for DUB was Dublin.\""]},{"type":"paragraph","inlineContent":[{"text":"특정 키에 대한 값을 딕셔너리에서 가져올 때도 서브스크립트 문법을 사용할 수 있다. 값이 존재하지 않는 키를 요청할 가능성이 있기 때문에, 딕셔너리의 서브스크립트는 딕셔너리의 값 타입에 대한 옵셔널 값을 반환한다. 요청한 키에 대한 값이 딕셔너리에 존재한다면, 서브스크립트는 해당 키의 기존 값을 포함한 옵셔널 값을 반환한다. 그렇지 않으면 ","type":"text"},{"type":"codeVoice","code":"nil"},{"text":"을 반환한다:","type":"text"}]},{"code":["if let airportName = airports[\"DUB\"] {","    print(\"The name of the airport is \\(airportName).\")","} else {","    print(\"That airport isn't in the airports dictionary.\")","}","\/\/ Prints \"The name of the airport is Dublin Airport.\""],"syntax":"swift","type":"codeListing"},{"type":"paragraph","inlineContent":[{"type":"text","text":"서브스크립트 문법을 사용해 딕셔너리에서 키-값 쌍을 제거할 수 있다. 해당 키에 "},{"type":"codeVoice","code":"nil"},{"text":" 값을 할당하면 된다:","type":"text"}]},{"code":["airports[\"APL\"] = \"Apple International\"","\/\/ \"Apple International\" isn't the real airport for APL, so delete it","airports[\"APL\"] = nil","\/\/ APL has now been removed from the dictionary"],"type":"codeListing","syntax":"swift"},{"type":"paragraph","inlineContent":[{"text":"또는 ","type":"text"},{"code":"removeValue(forKey:)","type":"codeVoice"},{"text":" 메서드를 사용해 딕셔너리에서 키-값 쌍을 제거할 수 있다. 이 메서드는 키-값 쌍이 존재하면 제거하고 제거된 값을 반환하며, 값이 존재하지 않으면 ","type":"text"},{"code":"nil","type":"codeVoice"},{"type":"text","text":"을 반환한다:"}]},{"syntax":"swift","code":["if let removedValue = airports.removeValue(forKey: \"DUB\") {","    print(\"The removed airport's name is \\(removedValue).\")","} else {","    print(\"The airports dictionary doesn't contain a value for DUB.\")","}","\/\/ Prints \"The removed airport's name is Dublin Airport.\""],"type":"codeListing"},{"text":"딕셔너리 순회하기","level":3,"type":"heading","anchor":"%EB%94%95%EC%85%94%EB%84%88%EB%A6%AC-%EC%88%9C%ED%9A%8C%ED%95%98%EA%B8%B0"},{"type":"paragraph","inlineContent":[{"code":"for","type":"codeVoice"},{"type":"text","text":"-"},{"type":"codeVoice","code":"in"},{"text":" 루프를 사용해 딕셔너리의 키-값 쌍을 순회할 수 있다. 딕셔너리의 각 항목은 ","type":"text"},{"code":"(key, value)","type":"codeVoice"},{"type":"text","text":" 튜플로 반환되며, 순회 과정에서 튜플의 멤버를 임시 상수나 변수로 분해할 수 있다:"}]},{"syntax":"swift","type":"codeListing","code":["for (airportCode, airportName) in airports {","    print(\"\\(airportCode): \\(airportName)\")","}","\/\/ LHR: London Heathrow","\/\/ YYZ: Toronto Pearson"]},{"type":"paragraph","inlineContent":[{"type":"codeVoice","code":"for"},{"text":"-","type":"text"},{"code":"in","type":"codeVoice"},{"type":"text","text":" 루프에 대해 더 자세히 알아보려면 "},{"type":"text","text":"doc:ControlFlow#For-In-Loops"},{"text":"를 참고한다.","type":"text"}]},{"inlineContent":[{"type":"text","text":"딕셔너리의 "},{"code":"keys","type":"codeVoice"},{"text":"와 ","type":"text"},{"code":"values","type":"codeVoice"},{"text":" 프로퍼티에 접근해 키나 값의 컬렉션을 가져와 순회할 수도 있다:","type":"text"}],"type":"paragraph"},{"syntax":"swift","type":"codeListing","code":["for airportCode in airports.keys {","    print(\"Airport code: \\(airportCode)\")","}","\/\/ Airport code: LHR","\/\/ Airport code: YYZ","","for airportName in airports.values {","    print(\"Airport name: \\(airportName)\")","}","\/\/ Airport name: London Heathrow","\/\/ Airport name: Toronto Pearson"]},{"inlineContent":[{"code":"Array","type":"codeVoice"},{"text":" 타입을 인자로 받는 API와 함께 딕셔너리의 키나 값을 사용해야 한다면, ","type":"text"},{"code":"keys","type":"codeVoice"},{"type":"text","text":"나 "},{"type":"codeVoice","code":"values"},{"type":"text","text":" 프로퍼티로 새로운 배열을 초기화한다:"}],"type":"paragraph"},{"type":"codeListing","syntax":"swift","code":["let airportCodes = [String](airports.keys)","\/\/ airportCodes is [\"LHR\", \"YYZ\"]","","let airportNames = [String](airports.values)","\/\/ airportNames is [\"London Heathrow\", \"Toronto Pearson\"]"]},{"type":"paragraph","inlineContent":[{"text":"Swift의 ","type":"text"},{"type":"codeVoice","code":"Dictionary"},{"text":" 타입은 정의된 순서가 없다. 특정 순서로 딕셔너리의 키나 값을 순회하려면, ","type":"text"},{"code":"keys","type":"codeVoice"},{"text":"나 ","type":"text"},{"type":"codeVoice","code":"values"},{"type":"text","text":" 프로퍼티에 "},{"code":"sorted()","type":"codeVoice"},{"type":"text","text":" 메서드를 사용한다."}]}]}],"metadata":{"title":"컬렉션 타입"},"schemaVersion":{"major":0,"minor":3,"patch":0},"abstract":[{"type":"text","text":"배열, 집합, 딕셔너리를 활용해 데이터를 구조화한다."}],"kind":"article","sections":[],"hierarchy":{"paths":[["doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language"]]},"references":{"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/Generics":{"type":"topic","abstract":[{"type":"text","text":"여러 타입에 대해 동작하는 코드를 작성하고, 해당 타입에 대한 요구사항을 명시할 수 있다."}],"title":"제네릭","role":"article","url":"\/documentation\/the-swift-programming-language\/generics","identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Generics","kind":"article"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language":{"title":"The Swift Programming Language (6.1)","abstract":[],"kind":"article","role":"collection","type":"topic","url":"\/documentation\/the-swift-programming-language","identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language"},"https://developer.apple.com/documentation/swift/array#2846730":{"title":"Array와 NSArray 연결하기","url":"https:\/\/developer.apple.com\/documentation\/swift\/array#2846730","titleInlineContent":[{"type":"text","text":"Array와 NSArray 연결하기"}],"type":"link","identifier":"https:\/\/developer.apple.com\/documentation\/swift\/array#2846730"},"CollectionTypes_intro":{"variants":[{"url":"\/images\/org.swift.tspl\/CollectionTypes_intro@2x.png","traits":["2x","light"]},{"url":"\/images\/org.swift.tspl\/CollectionTypes_intro~dark@2x.png","traits":["2x","dark"]}],"alt":null,"type":"image","identifier":"CollectionTypes_intro"},"https://developer.apple.com/documentation/swift/set#2845530":{"identifier":"https:\/\/developer.apple.com\/documentation\/swift\/set#2845530","url":"https:\/\/developer.apple.com\/documentation\/swift\/set#2845530","titleInlineContent":[{"type":"text","text":"Bridging Between Set and NSSet"}],"title":"Bridging Between Set and NSSet","type":"link"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/Protocols":{"type":"topic","abstract":[{"type":"text","text":"특정 타입이 반드시 구현해야 하는 요구사항을 정의한다."}],"title":"프로토콜","role":"article","url":"\/documentation\/the-swift-programming-language\/protocols","kind":"article","identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Protocols"},"https://developer.apple.com/documentation/swift/hashable":{"identifier":"https:\/\/developer.apple.com\/documentation\/swift\/hashable","url":"https:\/\/developer.apple.com\/documentation\/swift\/hashable","titleInlineContent":[{"type":"codeVoice","code":"Hashable"}],"title":"Hashable","type":"link"},"https://developer.apple.com/documentation/swift/dictionary#2846239":{"identifier":"https:\/\/developer.apple.com\/documentation\/swift\/dictionary#2846239","type":"link","titleInlineContent":[{"type":"text","text":"Bridging Between Dictionary and NSDictionary"}],"title":"Bridging Between Dictionary and NSDictionary","url":"https:\/\/developer.apple.com\/documentation\/swift\/dictionary#2846239"},"setVennDiagram":{"identifier":"setVennDiagram","type":"image","alt":null,"variants":[{"traits":["2x","light"],"url":"\/images\/org.swift.tspl\/setVennDiagram@2x.png"},{"url":"\/images\/org.swift.tspl\/setVennDiagram~dark@2x.png","traits":["2x","dark"]}]},"setEulerDiagram":{"type":"image","variants":[{"url":"\/images\/org.swift.tspl\/setEulerDiagram@2x.png","traits":["2x","light"]},{"url":"\/images\/org.swift.tspl\/setEulerDiagram~dark@2x.png","traits":["2x","dark"]}],"alt":null,"identifier":"setEulerDiagram"}}}