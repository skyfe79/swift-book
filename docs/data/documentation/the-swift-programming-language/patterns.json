{"primaryContentSections":[{"content":[{"type":"paragraph","inlineContent":[{"type":"emphasis","inlineContent":[{"text":"패턴","type":"text"}]},{"text":"은 단일 값 또는 복합 값의 구조를 나타낸다. 예를 들어, 튜플 ","type":"text"},{"type":"codeVoice","code":"(1, 2)"},{"type":"text","text":"의 구조는 두 개의 요소로 이루어진 쉼표로 구분된 리스트다. 패턴은 특정 값이 아닌 값의 구조를 나타내므로 다양한 값과 매칭할 수 있다. 예를 들어, 패턴 "},{"type":"codeVoice","code":"(x, y)"},{"text":"는 튜플 ","type":"text"},{"code":"(1, 2)","type":"codeVoice"},{"type":"text","text":"뿐만 아니라 다른 두 요소 튜플과도 매칭된다. 패턴을 값과 매칭하는 것 외에도, 복합 값의 일부 또는 전체를 추출하고 각 부분을 상수나 변수 이름에 바인딩할 수 있다."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Swift에는 두 가지 기본적인 종류의 패턴이 있다: 모든 종류의 값과 성공적으로 매칭되는 패턴과 런타임에 지정된 값과 매칭되지 않을 수 있는 패턴."}]},{"inlineContent":[{"type":"text","text":"첫 번째 종류의 패턴은 단순 변수, 상수, 옵셔널 바인딩에서 값을 분해할 때 사용된다. 이 패턴에는 와일드카드 패턴, 식별자 패턴, 그리고 이를 포함하는 값 바인딩 또는 튜플 패턴이 포함된다. 이러한 패턴에 타입 어노테이션을 지정해 특정 타입의 값만 매칭되도록 제한할 수 있다."}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"type":"text","text":"두 번째 종류의 패턴은 완전한 패턴 매칭에 사용되며, 런타임에 매칭하려는 값이 없을 수 있다. 이 패턴에는 열거형 케이스 패턴, 옵셔널 패턴, 표현식 패턴, 타입 캐스팅 패턴이 포함된다. 이러한 패턴은 "},{"type":"codeVoice","code":"switch"},{"type":"text","text":" 문의 케이스 라벨, "},{"type":"codeVoice","code":"do"},{"type":"text","text":" 문의 "},{"code":"catch","type":"codeVoice"},{"text":" 절, 또는 ","type":"text"},{"code":"if","type":"codeVoice"},{"type":"text","text":", "},{"code":"while","type":"codeVoice"},{"type":"text","text":", "},{"code":"guard","type":"codeVoice"},{"type":"text","text":", "},{"type":"codeVoice","code":"for"},{"type":"text","text":"-"},{"type":"codeVoice","code":"in"},{"type":"text","text":" 문의 케이스 조건에서 사용된다."}]},{"style":"note","name":"패턴 문법","type":"aside","content":[{"type":"paragraph","inlineContent":[{"text":"","type":"text"}]},{"inlineContent":[{"type":"emphasis","inlineContent":[{"text":"pattern","type":"text"}]},{"type":"text","text":" → "},{"type":"emphasis","inlineContent":[{"type":"text","text":"wildcard-pattern"}]},{"type":"text","text":" "},{"inlineContent":[{"text":"type-annotation","type":"text"}],"type":"emphasis"},{"inlineContent":[{"text":"?","type":"text"}],"type":"emphasis"},{"type":"text","text":" "},{"type":"text","text":"\n"},{"inlineContent":[{"text":"pattern","type":"text"}],"type":"emphasis"},{"type":"text","text":" → "},{"type":"emphasis","inlineContent":[{"type":"text","text":"identifier-pattern"}]},{"type":"text","text":" "},{"type":"emphasis","inlineContent":[{"type":"text","text":"type-annotation"}]},{"type":"emphasis","inlineContent":[{"type":"text","text":"?"}]},{"type":"text","text":" "},{"type":"text","text":"\n"},{"inlineContent":[{"type":"text","text":"pattern"}],"type":"emphasis"},{"text":" → ","type":"text"},{"inlineContent":[{"text":"value-binding-pattern","type":"text"}],"type":"emphasis"},{"type":"text","text":" "},{"type":"text","text":"\n"},{"inlineContent":[{"text":"pattern","type":"text"}],"type":"emphasis"},{"type":"text","text":" → "},{"type":"emphasis","inlineContent":[{"type":"text","text":"tuple-pattern"}]},{"text":" ","type":"text"},{"type":"emphasis","inlineContent":[{"text":"type-annotation","type":"text"}]},{"type":"emphasis","inlineContent":[{"text":"?","type":"text"}]},{"text":" ","type":"text"},{"type":"text","text":"\n"},{"type":"emphasis","inlineContent":[{"type":"text","text":"pattern"}]},{"text":" → ","type":"text"},{"inlineContent":[{"text":"enum-case-pattern","type":"text"}],"type":"emphasis"},{"type":"text","text":" "},{"type":"text","text":"\n"},{"type":"emphasis","inlineContent":[{"type":"text","text":"pattern"}]},{"text":" → ","type":"text"},{"inlineContent":[{"type":"text","text":"optional-pattern"}],"type":"emphasis"},{"text":" ","type":"text"},{"text":"\n","type":"text"},{"inlineContent":[{"text":"pattern","type":"text"}],"type":"emphasis"},{"type":"text","text":" → "},{"type":"emphasis","inlineContent":[{"type":"text","text":"type-casting-pattern"}]},{"text":" ","type":"text"},{"text":"\n","type":"text"},{"inlineContent":[{"type":"text","text":"pattern"}],"type":"emphasis"},{"type":"text","text":" → "},{"type":"emphasis","inlineContent":[{"type":"text","text":"expression-pattern"}]}],"type":"paragraph"}]},{"type":"heading","text":"와일드카드 패턴","level":2,"anchor":"%EC%99%80%EC%9D%BC%EB%93%9C%EC%B9%B4%EB%93%9C-%ED%8C%A8%ED%84%B4"},{"inlineContent":[{"type":"emphasis","inlineContent":[{"text":"와일드카드 패턴","type":"text"}]},{"text":"은 모든 값을 매칭하고 무시하며, 언더스코어(","type":"text"},{"code":"_","type":"codeVoice"},{"type":"text","text":")로 구성된다. 매칭 대상의 값이 중요하지 않을 때 와일드카드 패턴을 사용한다. 예를 들어, 다음 코드는 "},{"code":"1...3","type":"codeVoice"},{"text":" 범위를 순회하면서 각 반복에서 범위의 현재 값을 무시한다:","type":"text"}],"type":"paragraph"},{"code":["for _ in 1...3 {","    \/\/ 어떤 작업을 세 번 수행한다.","}"],"type":"codeListing","syntax":"swift"},{"style":"note","name":"와일드카드 패턴 문법","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":""}]},{"inlineContent":[{"inlineContent":[{"type":"text","text":"와일드카드 패턴"}],"type":"emphasis"},{"text":" → ","type":"text"},{"type":"strong","inlineContent":[{"code":"_","type":"codeVoice"}]}],"type":"paragraph"}],"type":"aside"},{"type":"heading","text":"식별자 패턴","level":2,"anchor":"%EC%8B%9D%EB%B3%84%EC%9E%90-%ED%8C%A8%ED%84%B4"},{"type":"paragraph","inlineContent":[{"inlineContent":[{"type":"text","text":"식별자 패턴"}],"type":"emphasis"},{"type":"text","text":"은 모든 값을 매칭하고, 매칭된 값을 변수나 상수 이름에 바인딩한다. 예를 들어, 다음 상수 선언에서 "},{"type":"codeVoice","code":"someValue"},{"type":"text","text":"는 "},{"type":"codeVoice","code":"Int"},{"text":" 타입의 값 ","type":"text"},{"code":"42","type":"codeVoice"},{"type":"text","text":"와 매칭되는 식별자 패턴이다:"}]},{"code":["let someValue = 42"],"type":"codeListing","syntax":"swift"},{"inlineContent":[{"text":"매칭이 성공하면, 값 ","type":"text"},{"type":"codeVoice","code":"42"},{"text":"는 상수 이름 ","type":"text"},{"type":"codeVoice","code":"someValue"},{"type":"text","text":"에 바인딩(할당)된다."}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"text":"변수나 상수 선언의 왼쪽에 있는 패턴이 식별자 패턴일 때, 식별자 패턴은 암시적으로 값 바인딩 패턴의 하위 패턴이 된다.","type":"text"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":""}]},{"inlineContent":[{"type":"emphasis","inlineContent":[{"type":"text","text":"identifier-pattern"}]},{"type":"text","text":" → "},{"type":"emphasis","inlineContent":[{"type":"text","text":"identifier"}]}],"type":"paragraph"}],"name":"식별자 패턴의 문법","type":"aside","style":"note"},{"text":"값 바인딩 패턴","anchor":"%EA%B0%92-%EB%B0%94%EC%9D%B8%EB%94%A9-%ED%8C%A8%ED%84%B4","type":"heading","level":2},{"type":"paragraph","inlineContent":[{"inlineContent":[{"type":"text","text":"값 바인딩 패턴"}],"type":"emphasis"},{"type":"text","text":"은 매칭된 값을 변수나 상수 이름에 바인딩한다. 매칭된 값을 상수 이름에 바인딩하는 값 바인딩 패턴은 "},{"type":"codeVoice","code":"let"},{"type":"text","text":" 키워드로 시작하고, 변수 이름에 바인딩하는 패턴은 "},{"code":"var","type":"codeVoice"},{"type":"text","text":" 키워드로 시작한다."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"값 바인딩 패턴 내의 식별자 패턴은 매칭된 값에 새로운 변수나 상수를 바인딩한다. 예를 들어, 튜플의 요소를 분해하고 각 요소의 값을 해당 식별자 패턴에 바인딩할 수 있다."}]},{"type":"codeListing","syntax":"swift","code":["let point = (3, 2)","switch point {","\/\/ point의 요소를 x와 y에 바인딩.","case let (x, y):","    print(\"The point is at (\\(x), \\(y)).\")","}","\/\/ 출력: \"The point is at (3, 2).\""]},{"inlineContent":[{"text":"위 예제에서 ","type":"text"},{"code":"let","type":"codeVoice"},{"text":"은 튜플 패턴 ","type":"text"},{"code":"(x, y)","type":"codeVoice"},{"text":"의 각 식별자 패턴에 적용된다. 이 동작 때문에 ","type":"text"},{"type":"codeVoice","code":"switch"},{"text":" 케이스 ","type":"text"},{"code":"case let (x, y):","type":"codeVoice"},{"text":"와 ","type":"text"},{"type":"codeVoice","code":"case (let x, let y):"},{"type":"text","text":"는 동일한 값에 매칭된다."}],"type":"paragraph"},{"type":"aside","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":""}]},{"inlineContent":[{"type":"emphasis","inlineContent":[{"text":"value-binding-pattern","type":"text"}]},{"type":"text","text":" → "},{"type":"strong","inlineContent":[{"code":"var","type":"codeVoice"}]},{"text":" ","type":"text"},{"type":"emphasis","inlineContent":[{"type":"text","text":"pattern"}]},{"text":" | ","type":"text"},{"inlineContent":[{"type":"codeVoice","code":"let"}],"type":"strong"},{"type":"text","text":" "},{"inlineContent":[{"text":"pattern","type":"text"}],"type":"emphasis"}],"type":"paragraph"}],"style":"note","name":"값 바인딩 패턴 문법"},{"level":2,"text":"튜플 패턴","type":"heading","anchor":"%ED%8A%9C%ED%94%8C-%ED%8C%A8%ED%84%B4"},{"type":"paragraph","inlineContent":[{"inlineContent":[{"type":"text","text":"튜플 패턴"}],"type":"emphasis"},{"type":"text","text":"은 쉼표로 구분된 0개 이상의 패턴을 괄호로 감싼 형태이다. 튜플 패턴은 해당 튜플 타입의 값과 매칭된다."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"타입 어노테이션을 사용하면 튜플 패턴이 특정 튜플 타입과만 매칭되도록 제한할 수 있다. 예를 들어, 상수 선언 "},{"code":"let (x, y): (Int, Int) = (1, 2)","type":"codeVoice"},{"type":"text","text":"에서 튜플 패턴 "},{"type":"codeVoice","code":"(x, y): (Int, Int)"},{"text":"는 두 요소가 모두 ","type":"text"},{"type":"codeVoice","code":"Int"},{"text":" 타입인 튜플 타입과만 매칭된다.","type":"text"}]},{"inlineContent":[{"type":"text","text":"튜플 패턴이 "},{"type":"codeVoice","code":"for"},{"text":"-","type":"text"},{"type":"codeVoice","code":"in"},{"type":"text","text":" 문이나 변수\/상수 선언에서 패턴으로 사용될 때, 와일드카드 패턴, 식별자 패턴, 옵셔널 패턴, 또는 이러한 패턴을 포함한 다른 튜플 패턴만 포함할 수 있다. 예를 들어, 다음 코드는 튜플 패턴 "},{"code":"(x, 0)","type":"codeVoice"},{"text":"의 요소 ","type":"text"},{"type":"codeVoice","code":"0"},{"text":"이 표현식 패턴이기 때문에 유효하지 않다:","type":"text"}],"type":"paragraph"},{"syntax":"swift","type":"codeListing","code":["let points = [(0, 0), (1, 0), (1, 1), (2, 0), (2, 1)]","\/\/ 이 코드는 유효하지 않다.","for (x, 0) in points {","    \/* ... *\/","}"]},{"inlineContent":[{"type":"text","text":"단일 요소를 포함하는 튜플 패턴의 괄호는 아무런 효과가 없다. 이 패턴은 단일 요소의 타입과 매칭된다. 예를 들어, 다음 코드는 모두 동일하다:"}],"type":"paragraph"},{"syntax":"swift","code":["let a = 2        \/\/ a: Int = 2","let (a) = 2      \/\/ a: Int = 2","let (a): Int = 2 \/\/ a: Int = 2"],"type":"codeListing"},{"type":"aside","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":""}]},{"inlineContent":[{"type":"emphasis","inlineContent":[{"text":"tuple-pattern","type":"text"}]},{"type":"text","text":" → "},{"type":"strong","inlineContent":[{"type":"codeVoice","code":"("}]},{"type":"text","text":" "},{"type":"emphasis","inlineContent":[{"type":"text","text":"tuple-pattern-element-list"}]},{"type":"emphasis","inlineContent":[{"type":"text","text":"?"}]},{"type":"text","text":" "},{"type":"strong","inlineContent":[{"type":"codeVoice","code":")"}]},{"type":"text","text":" "},{"text":"\n","type":"text"},{"type":"emphasis","inlineContent":[{"type":"text","text":"tuple-pattern-element-list"}]},{"type":"text","text":" → "},{"type":"emphasis","inlineContent":[{"text":"tuple-pattern-element","type":"text"}]},{"type":"text","text":" | "},{"inlineContent":[{"type":"text","text":"tuple-pattern-element"}],"type":"emphasis"},{"type":"text","text":" "},{"type":"strong","inlineContent":[{"code":",","type":"codeVoice"}]},{"type":"text","text":" "},{"inlineContent":[{"text":"tuple-pattern-element-list","type":"text"}],"type":"emphasis"},{"type":"text","text":" "},{"text":"\n","type":"text"},{"type":"emphasis","inlineContent":[{"text":"tuple-pattern-element","type":"text"}]},{"type":"text","text":" → "},{"inlineContent":[{"type":"text","text":"pattern"}],"type":"emphasis"},{"text":" | ","type":"text"},{"type":"emphasis","inlineContent":[{"type":"text","text":"identifier"}]},{"type":"text","text":" "},{"inlineContent":[{"type":"codeVoice","code":":"}],"type":"strong"},{"type":"text","text":" "},{"inlineContent":[{"type":"text","text":"pattern"}],"type":"emphasis"}],"type":"paragraph"}],"style":"note","name":"튜플 패턴 문법"},{"type":"heading","text":"열거형 케이스 패턴","anchor":"%EC%97%B4%EA%B1%B0%ED%98%95-%EC%BC%80%EC%9D%B4%EC%8A%A4-%ED%8C%A8%ED%84%B4","level":2},{"type":"paragraph","inlineContent":[{"inlineContent":[{"text":"열거형 케이스 패턴","type":"text"}],"type":"emphasis"},{"type":"text","text":"은 기존 열거형 타입의 특정 케이스와 매칭된다. 이 패턴은 "},{"type":"codeVoice","code":"switch"},{"text":" 문의 케이스 레이블과 ","type":"text"},{"type":"codeVoice","code":"if"},{"text":", ","type":"text"},{"code":"while","type":"codeVoice"},{"type":"text","text":", "},{"code":"guard","type":"codeVoice"},{"type":"text","text":", "},{"code":"for","type":"codeVoice"},{"text":"-","type":"text"},{"code":"in","type":"codeVoice"},{"type":"text","text":" 문의 조건에서 사용된다."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"매칭하려는 열거형 케이스에 연관 값이 있다면, 해당 열거형 케이스 패턴은 각 연관 값에 대한 요소를 포함하는 튜플 패턴을 명시해야 한다. 연관 값을 포함한 열거형 케이스를 매칭하는 "},{"type":"codeVoice","code":"switch"},{"text":" 문의 예제는 ","type":"text"},{"text":"doc:Enumerations#Associated-Values","type":"text"},{"type":"text","text":"를 참고한다."}]},{"type":"paragraph","inlineContent":[{"text":"열거형 케이스 패턴은 옵셔널로 감싸진 해당 케이스의 값과도 매칭된다. 이 간결한 문법을 사용하면 옵셔널 패턴을 생략할 수 있다. ","type":"text"},{"type":"codeVoice","code":"Optional"},{"text":"이 열거형으로 구현되어 있기 때문에, ","type":"text"},{"code":".none","type":"codeVoice"},{"text":"과 ","type":"text"},{"code":".some","type":"codeVoice"},{"type":"text","text":"은 동일한 "},{"code":"switch","type":"codeVoice"},{"text":" 문에서 열거형 타입의 케이스와 함께 사용할 수 있다.","type":"text"}]},{"code":["enum SomeEnum { case left, right }","let x: SomeEnum? = .left","switch x {","case .left:","    print(\"Turn left\")","case .right:","    print(\"Turn right\")","case nil:","    print(\"Keep going straight\")","}","\/\/ Prints \"Turn left\""],"type":"codeListing","syntax":"swift"},{"type":"aside","style":"note","name":"열거형 케이스 패턴의 문법","content":[{"inlineContent":[{"type":"text","text":""}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"type":"emphasis","inlineContent":[{"text":"enum-case-pattern","type":"text"}]},{"type":"text","text":" → "},{"type":"emphasis","inlineContent":[{"text":"type-identifier","type":"text"}]},{"inlineContent":[{"text":"?","type":"text"}],"type":"emphasis"},{"text":" ","type":"text"},{"type":"strong","inlineContent":[{"type":"codeVoice","code":"."}]},{"text":" ","type":"text"},{"inlineContent":[{"type":"text","text":"enum-case-name"}],"type":"emphasis"},{"type":"text","text":" "},{"type":"emphasis","inlineContent":[{"type":"text","text":"tuple-pattern"}]},{"inlineContent":[{"text":"?","type":"text"}],"type":"emphasis"}]}]},{"level":2,"type":"heading","text":"옵셔널 패턴","anchor":"%EC%98%B5%EC%85%94%EB%84%90-%ED%8C%A8%ED%84%B4"},{"inlineContent":[{"type":"text","text":"옵셔널 패턴은 "},{"code":"Optional<Wrapped>","type":"codeVoice"},{"text":" 열거형의 ","type":"text"},{"type":"codeVoice","code":"some(Wrapped)"},{"type":"text","text":" 케이스로 래핑된 값을 매칭한다. 옵셔널 패턴은 식별자 패턴 뒤에 물음표를 붙여 사용하며, 열거형 케이스 패턴이 사용되는 곳에서 동일하게 활용할 수 있다."}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"text":"옵셔널 패턴은 ","type":"text"},{"code":"Optional","type":"codeVoice"},{"text":" 열거형 케이스 패턴을 간편하게 사용할 수 있도록 하는 문법적 설탕이다. 따라서 다음 두 코드는 동일한 결과를 보인다:","type":"text"}]},{"syntax":"swift","code":["let someOptional: Int? = 42","\/\/ 열거형 케이스 패턴을 사용해 매칭","if case .some(let x) = someOptional {","    print(x)","}","","\/\/ 옵셔널 패턴을 사용해 매칭","if case let x? = someOptional {","    print(x)","}"],"type":"codeListing"},{"type":"paragraph","inlineContent":[{"text":"옵셔널 패턴은 ","type":"text"},{"type":"codeVoice","code":"for"},{"text":"-","type":"text"},{"code":"in","type":"codeVoice"},{"type":"text","text":" 구문에서 옵셔널 값 배열을 순회할 때 유용하다. 이 패턴을 사용하면 "},{"code":"nil","type":"codeVoice"},{"text":"이 아닌 요소에 대해서만 반복문의 본문을 실행할 수 있다.","type":"text"}]},{"code":["let arrayOfOptionalInts: [Int?] = [nil, 2, 3, nil, 5]","\/\/ nil이 아닌 값만 매칭","for case let number? in arrayOfOptionalInts {","    print(\"Found a \\(number)\")","}","\/\/ Found a 2","\/\/ Found a 3","\/\/ Found a 5"],"type":"codeListing","syntax":"swift"},{"content":[{"inlineContent":[{"text":"","type":"text"}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"type":"emphasis","inlineContent":[{"type":"text","text":"optional-pattern"}]},{"type":"text","text":" → "},{"type":"emphasis","inlineContent":[{"text":"identifier-pattern","type":"text"}]},{"text":" ","type":"text"},{"type":"strong","inlineContent":[{"code":"?","type":"codeVoice"}]}]}],"style":"note","type":"aside","name":"옵셔널 패턴 문법"},{"level":2,"text":"타입 캐스팅 패턴","type":"heading","anchor":"%ED%83%80%EC%9E%85-%EC%BA%90%EC%8A%A4%ED%8C%85-%ED%8C%A8%ED%84%B4"},{"inlineContent":[{"text":"타입 캐스팅 패턴에는 ","type":"text"},{"type":"codeVoice","code":"is"},{"type":"text","text":" 패턴과 "},{"code":"as","type":"codeVoice"},{"text":" 패턴 두 가지가 있다. ","type":"text"},{"code":"is","type":"codeVoice"},{"text":" 패턴은 ","type":"text"},{"code":"switch","type":"codeVoice"},{"text":" 문의 case 레이블에서만 사용된다. ","type":"text"},{"code":"is","type":"codeVoice"},{"type":"text","text":"와 "},{"code":"as","type":"codeVoice"},{"type":"text","text":" 패턴은 다음과 같은 형태를 가진다:"}],"type":"paragraph"},{"code":["is <#type#>","<#pattern#> as <#type#>"],"type":"codeListing","syntax":"swift"},{"inlineContent":[{"type":"codeVoice","code":"is"},{"type":"text","text":" 패턴은 런타임에 값의 타입이 "},{"code":"is","type":"codeVoice"},{"text":" 패턴의 오른쪽에 지정된 타입과 동일하거나 그 타입의 하위 클래스인 경우에 매칭된다. ","type":"text"},{"type":"codeVoice","code":"is"},{"type":"text","text":" 패턴은 "},{"code":"is","type":"codeVoice"},{"type":"text","text":" 연산자와 유사하게 동작하며, 둘 다 타입 캐스팅을 수행하지만 반환된 타입을 버린다."}],"type":"paragraph"},{"inlineContent":[{"type":"codeVoice","code":"as"},{"type":"text","text":" 패턴은 런타임에 값의 타입이 "},{"code":"as","type":"codeVoice"},{"type":"text","text":" 패턴의 오른쪽에 지정된 타입과 동일하거나 그 타입의 하위 클래스인 경우에 매칭된다. 매칭이 성공하면, 매칭된 값의 타입은 "},{"code":"as","type":"codeVoice"},{"text":" 패턴의 오른쪽에 지정된 ","type":"text"},{"type":"emphasis","inlineContent":[{"type":"text","text":"패턴"}]},{"type":"text","text":"으로 캐스팅된다."}],"type":"paragraph"},{"inlineContent":[{"code":"switch","type":"codeVoice"},{"text":" 문을 사용해 ","type":"text"},{"type":"codeVoice","code":"is"},{"text":"와 ","type":"text"},{"type":"codeVoice","code":"as"},{"type":"text","text":" 패턴으로 값을 매칭하는 예제는 "},{"text":"doc:TypeCasting#Type-Casting-for-Any-and-AnyObject","type":"text"},{"type":"text","text":"를 참고한다."}],"type":"paragraph"},{"style":"note","type":"aside","name":"타입 캐스팅 패턴 문법","content":[{"type":"paragraph","inlineContent":[{"text":"","type":"text"}]},{"type":"paragraph","inlineContent":[{"type":"emphasis","inlineContent":[{"type":"text","text":"type-casting-pattern"}]},{"text":" → ","type":"text"},{"inlineContent":[{"type":"text","text":"is-pattern"}],"type":"emphasis"},{"text":" | ","type":"text"},{"type":"emphasis","inlineContent":[{"text":"as-pattern","type":"text"}]},{"text":" ","type":"text"},{"type":"text","text":"\n"},{"inlineContent":[{"text":"is-pattern","type":"text"}],"type":"emphasis"},{"text":" → ","type":"text"},{"type":"strong","inlineContent":[{"code":"is","type":"codeVoice"}]},{"type":"text","text":" "},{"inlineContent":[{"type":"text","text":"type"}],"type":"emphasis"},{"text":" ","type":"text"},{"text":"\n","type":"text"},{"inlineContent":[{"type":"text","text":"as-pattern"}],"type":"emphasis"},{"text":" → ","type":"text"},{"inlineContent":[{"type":"text","text":"pattern"}],"type":"emphasis"},{"type":"text","text":" "},{"type":"strong","inlineContent":[{"type":"codeVoice","code":"as"}]},{"text":" ","type":"text"},{"inlineContent":[{"text":"type","type":"text"}],"type":"emphasis"}]}]},{"text":"표현식 패턴","type":"heading","level":2,"anchor":"%ED%91%9C%ED%98%84%EC%8B%9D-%ED%8C%A8%ED%84%B4"},{"type":"paragraph","inlineContent":[{"type":"emphasis","inlineContent":[{"type":"text","text":"표현식 패턴"}]},{"type":"text","text":"은 표현식의 값을 나타낸다. 표현식 패턴은 "},{"code":"switch","type":"codeVoice"},{"type":"text","text":" 문의 case 라벨에서만 사용된다."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"표현식 패턴으로 표현된 값은 Swift 표준 라이브러리의 패턴 매칭 연산자("},{"code":"~=","type":"codeVoice"},{"text":")를 사용해 입력된 표현식의 값과 비교된다. ","type":"text"},{"type":"codeVoice","code":"~="},{"text":" 연산자가 ","type":"text"},{"code":"true","type":"codeVoice"},{"text":"를 반환하면 매칭이 성공한다. 기본적으로 ","type":"text"},{"type":"codeVoice","code":"~="},{"text":" 연산자는 동일한 타입의 두 값을 ","type":"text"},{"type":"codeVoice","code":"=="},{"type":"text","text":" 연산자를 사용해 비교한다. 또한 특정 범위 내에 값이 포함되는지 확인하는 방식으로 범위와의 매칭도 가능하다. 다음 예제에서 이를 확인할 수 있다."}]},{"code":["let point = (1, 2)","switch point {","case (0, 0):","    print(\"(0, 0) is at the origin.\")","case (-2...2, -2...2):","    print(\"(\\(point.0), \\(point.1)) is near the origin.\")","default:","    print(\"The point is at (\\(point.0), \\(point.1)).\")","}","\/\/ Prints \"(1, 2) is near the origin.\""],"type":"codeListing","syntax":"swift"},{"type":"paragraph","inlineContent":[{"code":"~=","type":"codeVoice"},{"text":" 연산자를 오버로드해 커스텀 매칭 동작을 정의할 수 있다. 예를 들어, 위 예제를 수정해 ","type":"text"},{"type":"codeVoice","code":"point"},{"text":" 표현식을 문자열 형태의 점과 비교하도록 만들 수 있다.","type":"text"}]},{"type":"codeListing","code":["\/\/ 문자열과 정수를 매칭하기 위해 ~= 연산자를 오버로드한다.","func ~= (pattern: String, value: Int) -> Bool {","    return pattern == \"\\(value)\"","}","switch point {","case (\"0\", \"0\"):","    print(\"(0, 0) is at the origin.\")","default:","    print(\"The point is at (\\(point.0), \\(point.1)).\")","}","\/\/ Prints \"The point is at (1, 2).\""],"syntax":"swift"},{"style":"note","name":"표현식 패턴 문법","content":[{"type":"paragraph","inlineContent":[{"text":"","type":"text"}]},{"type":"paragraph","inlineContent":[{"inlineContent":[{"type":"text","text":"expression-pattern"}],"type":"emphasis"},{"type":"text","text":" → "},{"inlineContent":[{"text":"expression","type":"text"}],"type":"emphasis"}]}],"type":"aside"}],"kind":"content"}],"hierarchy":{"paths":[["doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language"]]},"metadata":{"title":"패턴"},"kind":"article","sections":[],"abstract":[{"text":"값을 매칭하고 구조를 분해한다.","type":"text"}],"identifier":{"interfaceLanguage":"swift","url":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Patterns"},"schemaVersion":{"patch":0,"major":0,"minor":3},"references":{"doc://org.swift.tspl/documentation/The-Swift-Programming-Language":{"title":"The Swift Programming Language (6.1)","abstract":[],"kind":"article","role":"collection","type":"topic","url":"\/documentation\/the-swift-programming-language","identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language"}}}