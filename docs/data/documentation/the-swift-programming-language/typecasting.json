{"schemaVersion":{"patch":0,"minor":3,"major":0},"identifier":{"url":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/TypeCasting","interfaceLanguage":"swift"},"abstract":[{"type":"text","text":"값의 런타임 타입을 확인하고 더 구체적인 타입 정보를 제공한다."}],"metadata":{"title":"타입 캐스팅"},"primaryContentSections":[{"content":[{"inlineContent":[{"type":"emphasis","inlineContent":[{"type":"text","text":"타입 캐스팅"}]},{"type":"text","text":"은 인스턴스의 타입을 확인하거나, 해당 인스턴스를 클래스 계층 구조 내의 다른 슈퍼클래스나 서브클래스로 취급하는 방법이다."}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"Swift에서 타입 캐스팅은 "},{"type":"codeVoice","code":"is"},{"text":"와 ","type":"text"},{"code":"as","type":"codeVoice"},{"text":" 연산자를 통해 구현된다. 이 두 연산자는 값의 타입을 확인하거나 값을 다른 타입으로 캐스팅하는 간단하고 명확한 방법을 제공한다.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"text":"타입 캐스팅을 사용해 특정 프로토콜을 준수하는지 여부를 확인할 수도 있다. 자세한 내용은 ","type":"text"},{"type":"text","text":"doc:Protocols#Checking-for-Protocol-Conformance"},{"type":"text","text":"를 참고한다."}],"type":"paragraph"},{"text":"타입 캐스팅을 위한 클래스 계층 구조 정의","anchor":"%ED%83%80%EC%9E%85-%EC%BA%90%EC%8A%A4%ED%8C%85%EC%9D%84-%EC%9C%84%ED%95%9C-%ED%81%B4%EB%9E%98%EC%8A%A4-%EA%B3%84%EC%B8%B5-%EA%B5%AC%EC%A1%B0-%EC%A0%95%EC%9D%98","level":2,"type":"heading"},{"type":"paragraph","inlineContent":[{"type":"text","text":"클래스와 서브클래스로 이루어진 계층 구조를 활용하면 특정 클래스 인스턴스의 타입을 확인하고, 동일한 계층 구조 내에서 다른 클래스로 캐스팅할 수 있다. 아래 세 개의 코드 스니펫은 타입 캐스팅 예제를 위해 클래스 계층 구조와 해당 클래스의 인스턴스를 포함한 배열을 정의한다."}]},{"inlineContent":[{"text":"첫 번째 스니펫은 ","type":"text"},{"code":"MediaItem","type":"codeVoice"},{"type":"text","text":"이라는 새로운 기본 클래스를 정의한다. 이 클래스는 디지털 미디어 라이브러리에 등장하는 모든 종류의 아이템에 대한 기본 기능을 제공한다. 구체적으로, "},{"type":"codeVoice","code":"String"},{"text":" 타입의 ","type":"text"},{"type":"codeVoice","code":"name"},{"text":" 프로퍼티와 ","type":"text"},{"type":"codeVoice","code":"init(name:)"},{"type":"text","text":" 초기화 메서드를 선언한다. (모든 미디어 아이템, 영화와 노래를 포함해 이름을 가진다고 가정한다.)"}],"type":"paragraph"},{"syntax":"swift","code":["class MediaItem {","    var name: String","    init(name: String) {","        self.name = name","    }","}"],"type":"codeListing"},{"inlineContent":[{"text":"다음 스니펫은 ","type":"text"},{"type":"codeVoice","code":"MediaItem"},{"type":"text","text":"의 두 서브클래스를 정의한다. 첫 번째 서브클래스인 "},{"type":"codeVoice","code":"Movie"},{"type":"text","text":"는 영화나 필름에 대한 추가 정보를 캡슐화한다. 기본 "},{"type":"codeVoice","code":"MediaItem"},{"type":"text","text":" 클래스 위에 "},{"type":"codeVoice","code":"director"},{"type":"text","text":" 프로퍼티와 해당 초기화 메서드를 추가한다. 두 번째 서브클래스인 "},{"type":"codeVoice","code":"Song"},{"type":"text","text":"은 기본 클래스 위에 "},{"code":"artist","type":"codeVoice"},{"text":" 프로퍼티와 초기화 메서드를 추가한다:","type":"text"}],"type":"paragraph"},{"code":["class Movie: MediaItem {","    var director: String","    init(name: String, director: String) {","        self.director = director","        super.init(name: name)","    }","}","","class Song: MediaItem {","    var artist: String","    init(name: String, artist: String) {","        self.artist = artist","        super.init(name: name)","    }","}"],"type":"codeListing","syntax":"swift"},{"type":"paragraph","inlineContent":[{"text":"마지막 스니펫은 ","type":"text"},{"type":"codeVoice","code":"library"},{"type":"text","text":"라는 상수 배열을 생성한다. 이 배열은 두 개의 "},{"type":"codeVoice","code":"Movie"},{"type":"text","text":" 인스턴스와 세 개의 "},{"type":"codeVoice","code":"Song"},{"text":" 인스턴스를 포함한다. ","type":"text"},{"code":"library","type":"codeVoice"},{"type":"text","text":" 배열의 타입은 배열 리터럴의 내용으로 초기화함으로써 추론된다. Swift의 타입 체커는 "},{"type":"codeVoice","code":"Movie"},{"type":"text","text":"와 "},{"code":"Song","type":"codeVoice"},{"text":"이 ","type":"text"},{"type":"codeVoice","code":"MediaItem"},{"text":"이라는 공통의 슈퍼클래스를 가지고 있다는 것을 추론할 수 있으므로, ","type":"text"},{"code":"library","type":"codeVoice"},{"type":"text","text":" 배열의 타입을 "},{"type":"codeVoice","code":"[MediaItem]"},{"type":"text","text":"으로 추론한다:"}]},{"code":["let library = [","    Movie(name: \"Casablanca\", director: \"Michael Curtiz\"),","    Song(name: \"Blue Suede Shoes\", artist: \"Elvis Presley\"),","    Movie(name: \"Citizen Kane\", director: \"Orson Welles\"),","    Song(name: \"The One And Only\", artist: \"Chesney Hawkes\"),","    Song(name: \"Never Gonna Give You Up\", artist: \"Rick Astley\")","]","\/\/ the type of \"library\" is inferred to be [MediaItem]"],"type":"codeListing","syntax":"swift"},{"inlineContent":[{"code":"library","type":"codeVoice"},{"text":"에 저장된 아이템은 여전히 ","type":"text"},{"type":"codeVoice","code":"Movie"},{"text":"와 ","type":"text"},{"type":"codeVoice","code":"Song"},{"text":" 인스턴스다. 그러나 이 배열의 내용을 반복적으로 탐색하면, 반환되는 아이템은 ","type":"text"},{"code":"MediaItem","type":"codeVoice"},{"type":"text","text":" 타입으로 간주되며, "},{"type":"codeVoice","code":"Movie"},{"type":"text","text":"나 "},{"code":"Song","type":"codeVoice"},{"text":"으로 간주되지 않는다. 이들을 원래 타입으로 다루려면, 아래에서 설명한 대로 타입을 ","type":"text"},{"inlineContent":[{"type":"text","text":"확인"}],"type":"emphasis"},{"type":"text","text":"하거나 다른 타입으로 "},{"type":"emphasis","inlineContent":[{"type":"text","text":"다운캐스팅"}]},{"type":"text","text":"해야 한다."}],"type":"paragraph"},{"type":"heading","text":"타입 확인하기","level":2,"anchor":"%ED%83%80%EC%9E%85-%ED%99%95%EC%9D%B8%ED%95%98%EA%B8%B0"},{"type":"paragraph","inlineContent":[{"type":"emphasis","inlineContent":[{"text":"타입 확인 연산자","type":"text"}]},{"type":"text","text":" ("},{"code":"is","type":"codeVoice"},{"type":"text","text":")를 사용해 인스턴스가 특정 서브클래스 타입인지 확인할 수 있다. 타입 확인 연산자는 인스턴스가 해당 서브클래스 타입이면 "},{"type":"codeVoice","code":"true"},{"text":"를 반환하고, 그렇지 않으면 ","type":"text"},{"type":"codeVoice","code":"false"},{"type":"text","text":"를 반환한다."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"아래 예제는 "},{"code":"library","type":"codeVoice"},{"text":" 배열에서 ","type":"text"},{"code":"Movie","type":"codeVoice"},{"text":"와 ","type":"text"},{"type":"codeVoice","code":"Song"},{"text":" 인스턴스의 개수를 세는 ","type":"text"},{"code":"movieCount","type":"codeVoice"},{"text":"와 ","type":"text"},{"code":"songCount","type":"codeVoice"},{"text":" 변수를 정의한다:","type":"text"}]},{"type":"codeListing","code":["var movieCount = 0","var songCount = 0","","for item in library {","    if item is Movie {","        movieCount += 1","    } else if item is Song {","        songCount += 1","    }","}","","print(\"Media library contains \\(movieCount) movies and \\(songCount) songs\")","\/\/ Prints \"Media library contains 2 movies and 3 songs\""],"syntax":"swift"},{"inlineContent":[{"text":"이 예제는 ","type":"text"},{"code":"library","type":"codeVoice"},{"type":"text","text":" 배열의 모든 항목을 순회한다. 각 반복에서 "},{"code":"for","type":"codeVoice"},{"text":"-","type":"text"},{"code":"in","type":"codeVoice"},{"text":" 루프는 ","type":"text"},{"type":"codeVoice","code":"item"},{"type":"text","text":" 상수에 배열의 다음 "},{"code":"MediaItem","type":"codeVoice"},{"type":"text","text":"을 할당한다."}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"type":"codeVoice","code":"item is Movie"},{"text":"는 현재 ","type":"text"},{"code":"MediaItem","type":"codeVoice"},{"type":"text","text":"이 "},{"type":"codeVoice","code":"Movie"},{"type":"text","text":" 인스턴스인 경우 "},{"code":"true","type":"codeVoice"},{"type":"text","text":"를 반환하고, 그렇지 않으면 "},{"type":"codeVoice","code":"false"},{"text":"를 반환한다. 마찬가지로, ","type":"text"},{"code":"item is Song","type":"codeVoice"},{"type":"text","text":"은 항목이 "},{"type":"codeVoice","code":"Song"},{"type":"text","text":" 인스턴스인지 확인한다. "},{"type":"codeVoice","code":"for"},{"type":"text","text":"-"},{"code":"in","type":"codeVoice"},{"type":"text","text":" 루프가 끝나면, "},{"code":"movieCount","type":"codeVoice"},{"type":"text","text":"와 "},{"code":"songCount","type":"codeVoice"},{"type":"text","text":"에는 각 타입의 "},{"type":"codeVoice","code":"MediaItem"},{"text":" 인스턴스 개수가 저장된다.","type":"text"}]},{"type":"heading","anchor":"%EB%8B%A4%EC%9A%B4%EC%BA%90%EC%8A%A4%ED%8C%85","level":2,"text":"다운캐스팅"},{"inlineContent":[{"type":"text","text":"특정 클래스 타입의 상수나 변수가 실제로는 하위 클래스의 인스턴스를 참조할 수 있다. 이런 경우를 의심할 때, "},{"inlineContent":[{"type":"text","text":"타입 캐스트 연산자"}],"type":"emphasis"},{"type":"text","text":"("},{"code":"as?","type":"codeVoice"},{"type":"text","text":" 또는 "},{"code":"as!","type":"codeVoice"},{"text":")를 사용해 하위 클래스 타입으로 ","type":"text"},{"type":"emphasis","inlineContent":[{"type":"text","text":"다운캐스팅"}]},{"text":"을 시도할 수 있다.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"다운캐스팅은 실패할 수 있기 때문에, 타입 캐스트 연산자는 두 가지 형태로 제공된다. 조건부 형태인 "},{"code":"as?","type":"codeVoice"},{"type":"text","text":"는 다운캐스팅하려는 타입의 옵셔널 값을 반환한다. 강제 형태인 "},{"code":"as!","type":"codeVoice"},{"type":"text","text":"는 다운캐스팅을 시도하고 결과를 강제 언래핑하는 단일 동작을 수행한다."}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"다운캐스팅이 성공할지 확신할 수 없을 때는 조건부 형태의 타입 캐스트 연산자("},{"type":"codeVoice","code":"as?"},{"text":")를 사용한다. 이 연산자는 항상 옵셔널 값을 반환하며, 다운캐스팅이 불가능한 경우 ","type":"text"},{"code":"nil","type":"codeVoice"},{"text":"을 반환한다. 이를 통해 다운캐스팅이 성공했는지 확인할 수 있다.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"text":"다운캐스팅이 항상 성공할 것이라고 확신할 때만 강제 형태의 타입 캐스트 연산자(","type":"text"},{"code":"as!","type":"codeVoice"},{"type":"text","text":")를 사용한다. 이 연산자는 잘못된 클래스 타입으로 다운캐스팅을 시도할 경우 런타임 오류를 발생시킨다."}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"아래 예제는 "},{"type":"codeVoice","code":"library"},{"type":"text","text":"에 있는 각 "},{"code":"MediaItem","type":"codeVoice"},{"type":"text","text":"을 순회하며, 각 항목에 대한 적절한 설명을 출력한다. 이를 위해 각 항목을 "},{"code":"Movie","type":"codeVoice"},{"type":"text","text":" 또는 "},{"type":"codeVoice","code":"Song"},{"text":"으로 접근해야 한다. 단순히 ","type":"text"},{"code":"MediaItem","type":"codeVoice"},{"type":"text","text":"으로 접근하는 것만으로는 충분하지 않다. 설명에 사용하기 위해 "},{"code":"Movie","type":"codeVoice"},{"type":"text","text":"의 "},{"type":"codeVoice","code":"director"},{"text":" 속성이나 ","type":"text"},{"type":"codeVoice","code":"Song"},{"type":"text","text":"의 "},{"type":"codeVoice","code":"artist"},{"type":"text","text":" 속성에 접근해야 하기 때문이다."}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"type":"text","text":"이 예제에서 배열의 각 항목은 "},{"code":"Movie","type":"codeVoice"},{"text":"일 수도 있고 ","type":"text"},{"type":"codeVoice","code":"Song"},{"type":"text","text":"일 수도 있다. 각 항목에 대해 어떤 클래스를 사용해야 할지 미리 알 수 없기 때문에, 반복문을 통해 매번 다운캐스팅을 확인하기 위해 조건부 형태의 타입 캐스트 연산자("},{"code":"as?","type":"codeVoice"},{"text":")를 사용하는 것이 적절하다:","type":"text"}]},{"type":"codeListing","syntax":"swift","code":["for item in library {","    if let movie = item as? Movie {","        print(\"Movie: \\(movie.name), dir. \\(movie.director)\")","    } else if let song = item as? Song {","        print(\"Song: \\(song.name), by \\(song.artist)\")","    }","}","","\/\/ Movie: Casablanca, dir. Michael Curtiz","\/\/ Song: Blue Suede Shoes, by Elvis Presley","\/\/ Movie: Citizen Kane, dir. Orson Welles","\/\/ Song: The One And Only, by Chesney Hawkes","\/\/ Song: Never Gonna Give You Up, by Rick Astley"]},{"inlineContent":[{"type":"text","text":"이 예제는 현재 "},{"type":"codeVoice","code":"item"},{"text":"을 ","type":"text"},{"type":"codeVoice","code":"Movie"},{"type":"text","text":"로 다운캐스팅하는 것으로 시작한다. "},{"type":"codeVoice","code":"item"},{"text":"은 ","type":"text"},{"type":"codeVoice","code":"MediaItem"},{"type":"text","text":" 인스턴스이기 때문에 "},{"code":"Movie","type":"codeVoice"},{"type":"text","text":"일 가능성이 있다. 동시에 "},{"type":"codeVoice","code":"Song"},{"text":"일 수도 있고, 단순히 기본 ","type":"text"},{"code":"MediaItem","type":"codeVoice"},{"text":"일 수도 있다. 이러한 불확실성 때문에, 하위 클래스 타입으로 다운캐스팅을 시도할 때 ","type":"text"},{"type":"codeVoice","code":"as?"},{"type":"text","text":" 형태의 타입 캐스트 연산자는 "},{"type":"emphasis","inlineContent":[{"type":"text","text":"옵셔널"}]},{"text":" 값을 반환한다. ","type":"text"},{"type":"codeVoice","code":"item as? Movie"},{"type":"text","text":"의 결과는 "},{"type":"codeVoice","code":"Movie?"},{"type":"text","text":" 타입, 즉 “옵셔널 "},{"type":"codeVoice","code":"Movie"},{"text":"“이다.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"type":"codeVoice","code":"library"},{"text":" 배열에 있는 ","type":"text"},{"code":"Song","type":"codeVoice"},{"type":"text","text":" 인스턴스에 "},{"type":"codeVoice","code":"Movie"},{"type":"text","text":"로 다운캐스팅을 시도하면 실패한다. 이를 처리하기 위해 위 예제는 옵셔널 바인딩을 사용해 옵셔널 "},{"code":"Movie","type":"codeVoice"},{"type":"text","text":"가 실제로 값을 포함하는지 확인한다(즉, 다운캐스팅이 성공했는지 확인한다). 이 옵셔널 바인딩은 “"},{"code":"if let movie = item as? Movie","type":"codeVoice"},{"text":"”로 작성되며, 다음과 같이 읽을 수 있다:","type":"text"}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"“"},{"type":"codeVoice","code":"item"},{"text":"을 ","type":"text"},{"code":"Movie","type":"codeVoice"},{"text":"로 접근해 보라. 성공한다면, 반환된 옵셔널 ","type":"text"},{"type":"codeVoice","code":"Movie"},{"text":"에 저장된 값을 ","type":"text"},{"code":"movie","type":"codeVoice"},{"text":"라는 새로운 임시 상수로 설정하라.”","type":"text"}],"type":"paragraph"},{"inlineContent":[{"text":"다운캐스팅이 성공하면, ","type":"text"},{"type":"codeVoice","code":"movie"},{"type":"text","text":"의 속성을 사용해 해당 "},{"type":"codeVoice","code":"Movie"},{"text":" 인스턴스에 대한 설명을 출력한다. 여기에는 ","type":"text"},{"code":"director","type":"codeVoice"},{"type":"text","text":"의 이름이 포함된다. "},{"type":"codeVoice","code":"Song"},{"type":"text","text":" 인스턴스를 확인하고, "},{"code":"library","type":"codeVoice"},{"text":"에서 ","type":"text"},{"code":"Song","type":"codeVoice"},{"type":"text","text":"을 찾을 때마다 "},{"code":"artist","type":"codeVoice"},{"type":"text","text":" 이름을 포함한 적절한 설명을 출력하기 위해 비슷한 원칙이 적용된다."}],"type":"paragraph"},{"content":[{"inlineContent":[{"type":"text","text":"캐스팅은 실제로 인스턴스를 수정하거나 값을 변경하지 않는다. 기본 인스턴스는 동일하게 유지되며, 단순히 캐스팅된 타입의 인스턴스로 취급되고 접근된다."}],"type":"paragraph"}],"name":"참고","type":"aside","style":"note"},{"type":"heading","anchor":"Any%EC%99%80-AnyObject%EB%A5%BC-%EC%9C%84%ED%95%9C-%ED%83%80%EC%9E%85-%EC%BA%90%EC%8A%A4%ED%8C%85","text":"Any와 AnyObject를 위한 타입 캐스팅","level":2},{"type":"paragraph","inlineContent":[{"text":"Swift는 비특정 타입을 다루기 위해 두 가지 특별한 타입을 제공한다:","type":"text"}]},{"type":"unorderedList","items":[{"content":[{"inlineContent":[{"type":"codeVoice","code":"Any"},{"type":"text","text":"는 함수 타입을 포함한 모든 타입의 인스턴스를 나타낼 수 있다."}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"type":"codeVoice","code":"AnyObject"},{"type":"text","text":"는 모든 클래스 타입의 인스턴스를 나타낼 수 있다."}],"type":"paragraph"}]}]},{"inlineContent":[{"type":"codeVoice","code":"Any"},{"text":"와 ","type":"text"},{"code":"AnyObject","type":"codeVoice"},{"text":"는 명시적으로 그 기능과 동작이 필요할 때만 사용한다. 코드에서 다루는 타입을 구체적으로 지정하는 것이 항상 더 좋다.","type":"text"}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"type":"text","text":"다음은 "},{"type":"codeVoice","code":"Any"},{"text":"를 사용해 함수 타입과 비클래스 타입을 포함한 다양한 타입을 다루는 예제다. 이 예제는 ","type":"text"},{"code":"Any","type":"codeVoice"},{"type":"text","text":" 타입의 값을 저장할 수 있는 "},{"code":"things","type":"codeVoice"},{"type":"text","text":"라는 배열을 생성한다:"}]},{"code":["var things: [Any] = []","","things.append(0)","things.append(0.0)","things.append(42)","things.append(3.14159)","things.append(\"hello\")","things.append((3.0, 5.0))","things.append(Movie(name: \"Ghostbusters\", director: \"Ivan Reitman\"))","things.append({ (name: String) -> String in \"Hello, \\(name)\" })"],"type":"codeListing","syntax":"swift"},{"inlineContent":[{"type":"codeVoice","code":"things"},{"type":"text","text":" 배열은 두 개의 "},{"code":"Int","type":"codeVoice"},{"text":" 값, 두 개의 ","type":"text"},{"type":"codeVoice","code":"Double"},{"type":"text","text":" 값, 하나의 "},{"code":"String","type":"codeVoice"},{"type":"text","text":" 값, "},{"type":"codeVoice","code":"(Double, Double)"},{"text":" 타입의 튜플, “Ghostbusters” 영화, 그리고 ","type":"text"},{"code":"String","type":"codeVoice"},{"type":"text","text":" 값을 받아 다른 "},{"code":"String","type":"codeVoice"},{"type":"text","text":" 값을 반환하는 클로저 표현식을 포함한다."}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"type":"codeVoice","code":"Any"},{"text":" 또는 ","type":"text"},{"type":"codeVoice","code":"AnyObject"},{"text":" 타입으로만 알려진 상수나 변수의 구체적인 타입을 확인하려면, ","type":"text"},{"type":"codeVoice","code":"switch"},{"text":" 문의 케이스에서 ","type":"text"},{"type":"codeVoice","code":"is"},{"text":" 또는 ","type":"text"},{"code":"as","type":"codeVoice"},{"type":"text","text":" 패턴을 사용할 수 있다. 아래 예제는 "},{"type":"codeVoice","code":"things"},{"type":"text","text":" 배열의 각 항목을 반복하며 "},{"type":"codeVoice","code":"switch"},{"text":" 문을 사용해 각 항목의 타입을 확인한다. 여러 ","type":"text"},{"code":"switch","type":"codeVoice"},{"text":" 케이스는 매칭된 값을 특정 타입의 상수에 바인딩해 그 값을 출력한다:","type":"text"}]},{"type":"codeListing","code":["for thing in things {","    switch thing {","    case 0 as Int:","        print(\"zero as an Int\")","    case 0 as Double:","        print(\"zero as a Double\")","    case let someInt as Int:","        print(\"an integer value of \\(someInt)\")","    case let someDouble as Double where someDouble > 0:","        print(\"a positive double value of \\(someDouble)\")","    case is Double:","        print(\"some other double value that I don't want to print\")","    case let someString as String:","        print(\"a string value of \\\"\\(someString)\\\"\")","    case let (x, y) as (Double, Double):","        print(\"an (x, y) point at \\(x), \\(y)\")","    case let movie as Movie:","        print(\"a movie called \\(movie.name), dir. \\(movie.director)\")","    case let stringConverter as (String) -> String:","        print(stringConverter(\"Michael\"))","    default:","        print(\"something else\")","    }","}","","\/\/ zero as an Int","\/\/ zero as a Double","\/\/ an integer value of 42","\/\/ a positive double value of 3.14159","\/\/ a string value of \"hello\"","\/\/ an (x, y) point at 3.0, 5.0","\/\/ a movie called Ghostbusters, dir. Ivan Reitman","\/\/ Hello, Michael"],"syntax":"swift"},{"name":"참고","style":"note","type":"aside","content":[{"inlineContent":[{"text":"","type":"text"},{"code":"Any","type":"codeVoice"},{"type":"text","text":" 타입은 옵셔널 타입을 포함한 모든 타입의 값을 나타낼 수 있다. "},{"code":"Any","type":"codeVoice"},{"type":"text","text":" 타입이 예상되는 곳에 옵셔널 값을 사용하면 Swift는 경고를 표시한다. 만약 옵셔널 값을 "},{"code":"Any","type":"codeVoice"},{"text":" 값으로 사용해야 한다면, 아래와 같이 ","type":"text"},{"code":"as","type":"codeVoice"},{"type":"text","text":" 연산자를 사용해 명시적으로 옵셔널을 "},{"code":"Any","type":"codeVoice"},{"type":"text","text":"로 캐스팅할 수 있다."}],"type":"paragraph"},{"type":"codeListing","syntax":"swift","code":["let optionalNumber: Int? = 3","things.append(optionalNumber)        \/\/ 경고","things.append(optionalNumber as Any) \/\/ 경고 없음"]}]}],"kind":"content"}],"kind":"article","hierarchy":{"paths":[["doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language"]]},"sections":[],"references":{"doc://org.swift.tspl/documentation/The-Swift-Programming-Language":{"title":"The Swift Programming Language (6.1)","abstract":[],"kind":"article","role":"collection","type":"topic","url":"\/documentation\/the-swift-programming-language","identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language"}}}