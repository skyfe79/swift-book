{"metadata":{"title":"Swift 둘러보기"},"primaryContentSections":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"새로운 언어를 배울 때 첫 번째 프로그램은 화면에 “Hello, world!“를 출력하는 것이 전통이다. Swift에서는 이를 단 한 줄로 구현할 수 있다."}]},{"type":"codeListing","syntax":"swift","code":["print(\"Hello, world!\")","\/\/ Prints \"Hello, world!\""]},{"type":"paragraph","inlineContent":[{"type":"text","text":"다른 언어를 알고 있다면 이 구문이 익숙할 것이다. Swift에서는 이 한 줄이 완전한 프로그램이다. 텍스트를 출력하거나 문자열을 처리하는 기능을 위해 별도의 라이브러리를 임포트할 필요가 없다. 전역 범위에 작성된 코드가 프로그램의 시작점으로 사용되므로 "},{"type":"codeVoice","code":"main()"},{"text":" 함수가 필요하지 않다. 또한 모든 문장 끝에 세미콜론을 작성할 필요도 없다.","type":"text"}]},{"type":"paragraph","inlineContent":[{"text":"이 둘러보기는 다양한 프로그래밍 작업을 수행하는 방법을 보여줌으로써 Swift로 코드를 작성하기에 충분한 정보를 제공한다. 이해가 되지 않는 부분이 있어도 걱정하지 말자. 이 둘러보기에서 소개된 모든 내용은 이 책의 나머지 부분에서 자세히 설명된다.","type":"text"}]},{"type":"heading","text":"간단한 값","level":2,"anchor":"%EA%B0%84%EB%8B%A8%ED%95%9C-%EA%B0%92"},{"type":"paragraph","inlineContent":[{"type":"text","text":"상수를 만들 때는 "},{"type":"codeVoice","code":"let"},{"text":"을, 변수를 만들 때는 ","type":"text"},{"code":"var","type":"codeVoice"},{"type":"text","text":"를 사용한다. 상수의 값은 컴파일 시점에 알 필요가 없지만, 반드시 한 번만 값을 할당해야 한다. 즉, 한 번 결정한 값을 여러 곳에서 사용할 때 상수를 활용할 수 있다."}]},{"code":["var myVariable = 42","myVariable = 50","let myConstant = 42"],"type":"codeListing","syntax":"swift"},{"inlineContent":[{"type":"text","text":"상수나 변수는 할당하려는 값과 같은 타입이어야 한다. 하지만 항상 타입을 명시적으로 작성할 필요는 없다. 상수나 변수를 생성할 때 값을 제공하면 컴파일러가 타입을 추론한다. 위 예제에서 컴파일러는 "},{"type":"codeVoice","code":"myVariable"},{"text":"이 정수 타입임을 추론한다. 초기 값이 정수이기 때문이다.","type":"text"}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"type":"text","text":"초기 값이 충분한 정보를 제공하지 않거나 초기 값이 없는 경우, 변수 뒤에 콜론을 붙이고 타입을 명시한다."}]},{"code":["let implicitInteger = 70","let implicitDouble = 70.0","let explicitDouble: Double = 70"],"syntax":"swift","type":"codeListing"},{"type":"aside","style":"note","name":"실험","content":[{"type":"paragraph","inlineContent":[{"text":"","type":"text"},{"code":"Float","type":"codeVoice"},{"type":"text","text":" 타입으로 명시적으로 지정된 상수를 만들고 값을 4로 설정해 보자."}]}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"값은 절대 암시적으로 다른 타입으로 변환되지 않는다. 값을 다른 타입으로 변환해야 한다면, 원하는 타입의 인스턴스를 명시적으로 생성한다."}]},{"type":"codeListing","syntax":"swift","code":["let label = \"The width is \"","let width = 94","let widthLabel = label + String(width)"]},{"name":"실험","style":"note","type":"aside","content":[{"inlineContent":[{"text":"마지막 줄에서 ","type":"text"},{"code":"String","type":"codeVoice"},{"type":"text","text":"으로의 변환을 제거해 보자. 어떤 오류가 발생하는가?"}],"type":"paragraph"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"문자열에 값을 포함하는 더 간단한 방법도 있다. 값을 괄호 안에 넣고, 괄호 앞에 백슬래시("},{"code":"\\","type":"codeVoice"},{"text":")를 작성한다. 예를 들어:","type":"text"}]},{"code":["let apples = 3","let oranges = 5","let appleSummary = \"I have \\(apples) apples.\"","let fruitSummary = \"I have \\(apples + oranges) pieces of fruit.\""],"type":"codeListing","syntax":"swift"},{"name":"실험","content":[{"type":"paragraph","inlineContent":[{"text":"","type":"text"},{"type":"codeVoice","code":"\\()"},{"text":"를 사용해 부동소수점 계산을 문자열에 포함시키고, 누군가의 이름을 인사말에 포함시켜 보자.","type":"text"}]}],"style":"note","type":"aside"},{"inlineContent":[{"text":"여러 줄에 걸친 문자열은 세 개의 큰따옴표(","type":"text"},{"type":"codeVoice","code":"\"\"\""},{"type":"text","text":")를 사용한다. 각 줄의 시작 부분에 있는 들여쓰기는 닫는 따옴표의 들여쓰기와 일치하는 한 제거된다. 예를 들어:"}],"type":"paragraph"},{"syntax":"swift","code":["let quotation = \"\"\"","        Even though there's whitespace to the left,","        the actual lines aren't indented.","            Except for this line.","        Double quotes (\") can appear without being escaped.","","        I still have \\(apples + oranges) pieces of fruit.","        \"\"\""],"type":"codeListing"},{"type":"paragraph","inlineContent":[{"type":"text","text":"배열과 딕셔너리는 대괄호("},{"type":"codeVoice","code":"[]"},{"text":")를 사용해 생성하고, 인덱스나 키를 대괄호 안에 작성해 요소에 접근한다. 마지막 요소 뒤에 쉼표를 사용할 수 있다.","type":"text"}]},{"syntax":"swift","type":"codeListing","code":["var fruits = [\"strawberries\", \"limes\", \"tangerines\"]","fruits[1] = \"grapes\"","","var occupations = [","    \"Malcolm\": \"Captain\",","    \"Kaylee\": \"Mechanic\","," ]","occupations[\"Jayne\"] = \"Public Relations\""]},{"type":"paragraph","inlineContent":[{"text":"배열은 요소를 추가하면 자동으로 크기가 늘어난다.","type":"text"}]},{"code":["fruits.append(\"blueberries\")","print(fruits)","\/\/ Prints \"[\"strawberries\", \"grapes\", \"tangerines\", \"blueberries\"]\""],"syntax":"swift","type":"codeListing"},{"inlineContent":[{"type":"text","text":"빈 배열이나 딕셔너리를 생성할 때도 대괄호를 사용한다. 배열은 "},{"type":"codeVoice","code":"[]"},{"text":", 딕셔너리는 ","type":"text"},{"code":"[:]","type":"codeVoice"},{"type":"text","text":"로 작성한다."}],"type":"paragraph"},{"syntax":"swift","type":"codeListing","code":["fruits = []","occupations = [:]"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"빈 배열이나 딕셔너리를 새로운 변수에 할당하거나 타입 정보가 없는 곳에 할당할 때는 타입을 명시해야 한다."}]},{"syntax":"swift","code":["let emptyArray: [String] = []","let emptyDictionary: [String: Float] = [:]"],"type":"codeListing"},{"type":"heading","level":2,"text":"제어 흐름","anchor":"%EC%A0%9C%EC%96%B4-%ED%9D%90%EB%A6%84"},{"inlineContent":[{"type":"text","text":"조건문을 만들 때 "},{"type":"codeVoice","code":"if"},{"text":"와 ","type":"text"},{"type":"codeVoice","code":"switch"},{"type":"text","text":"를 사용하고, 반복문을 만들 때 "},{"code":"for","type":"codeVoice"},{"type":"text","text":"-"},{"type":"codeVoice","code":"in"},{"type":"text","text":", "},{"type":"codeVoice","code":"while"},{"type":"text","text":", "},{"type":"codeVoice","code":"repeat"},{"type":"text","text":"-"},{"code":"while","type":"codeVoice"},{"type":"text","text":"을 사용한다. 조건이나 반복 변수를 감싸는 괄호는 선택 사항이지만, 본문을 감싸는 중괄호는 필수이다."}],"type":"paragraph"},{"syntax":"swift","code":["let individualScores = [75, 43, 103, 87, 12]","var teamScore = 0","for score in individualScores {","    if score > 50 {","        teamScore += 3","    } else {","        teamScore += 1","    }","}","print(teamScore)","\/\/ Prints \"11\""],"type":"codeListing"},{"inlineContent":[{"code":"if","type":"codeVoice"},{"text":" 문에서 조건은 반드시 불리언(Boolean) 표현식이어야 한다. 예를 들어 ","type":"text"},{"code":"if score { ... }","type":"codeVoice"},{"text":"와 같은 코드는 에러를 발생시키며, 암시적으로 0과 비교하지 않는다.","type":"text"}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"code":"if","type":"codeVoice"},{"type":"text","text":"나 "},{"type":"codeVoice","code":"switch"},{"type":"text","text":"를 할당 연산자("},{"code":"=","type":"codeVoice"},{"text":") 뒤나 ","type":"text"},{"code":"return","type":"codeVoice"},{"text":" 뒤에 사용하여 조건에 따라 값을 선택할 수 있다.","type":"text"}]},{"type":"codeListing","syntax":"swift","code":["let scoreDecoration = if teamScore > 10 {","    \"🎉\"","} else {","    \"\"","}","print(\"Score:\", teamScore, scoreDecoration)","\/\/ Prints \"Score: 11 🎉\""]},{"type":"paragraph","inlineContent":[{"type":"codeVoice","code":"if"},{"text":"와 ","type":"text"},{"type":"codeVoice","code":"let"},{"text":"을 함께 사용하여 값이 없을 수도 있는 상황을 처리할 수 있다. 이러한 값은 옵셔널로 표현된다. 옵셔널 값은 값을 포함하거나, 값이 없음을 나타내는 ","type":"text"},{"type":"codeVoice","code":"nil"},{"text":"을 포함한다. 값의 타입 뒤에 물음표(","type":"text"},{"code":"?","type":"codeVoice"},{"type":"text","text":")를 붙여 옵셔널로 표시한다."}]},{"syntax":"swift","type":"codeListing","code":["var optionalString: String? = \"Hello\"","print(optionalString == nil)","\/\/ Prints \"false\"","","var optionalName: String? = \"John Appleseed\"","var greeting = \"Hello!\"","if let name = optionalName {","    greeting = \"Hello, \\(name)\"","}"]},{"type":"aside","style":"note","content":[{"inlineContent":[{"text":"","type":"text"},{"type":"codeVoice","code":"optionalName"},{"text":"을 ","type":"text"},{"type":"codeVoice","code":"nil"},{"text":"로 변경해 보자. 어떤 인사말이 나오는가? ","type":"text"},{"code":"optionalName","type":"codeVoice"},{"type":"text","text":"이 "},{"code":"nil","type":"codeVoice"},{"type":"text","text":"일 때 다른 인사말을 설정하는 "},{"code":"else","type":"codeVoice"},{"text":" 절을 추가해 보자.","type":"text"}],"type":"paragraph"}],"name":"실험"},{"inlineContent":[{"text":"옵셔널 값이 ","type":"text"},{"type":"codeVoice","code":"nil"},{"type":"text","text":"이면 조건은 "},{"type":"codeVoice","code":"false"},{"text":"가 되고 중괄호 안의 코드는 실행되지 않는다. 그렇지 않으면 옵셔널 값이 언래핑되어 ","type":"text"},{"type":"codeVoice","code":"let"},{"type":"text","text":" 뒤의 상수에 할당되며, 이 언래핑된 값은 코드 블록 내에서 사용할 수 있다."}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"text":"옵셔널 값을 처리하는 또 다른 방법은 ","type":"text"},{"code":"??","type":"codeVoice"},{"text":" 연산자를 사용해 기본값을 제공하는 것이다. 옵셔널 값이 없으면 대신 기본값이 사용된다.","type":"text"}]},{"code":["let nickname: String? = nil","let fullName: String = \"John Appleseed\"","let informalGreeting = \"Hi \\(nickname ?? fullName)\""],"syntax":"swift","type":"codeListing"},{"inlineContent":[{"type":"text","text":"같은 이름을 사용하여 값을 더 짧게 언래핑할 수도 있다."}],"type":"paragraph"},{"syntax":"swift","type":"codeListing","code":["if let nickname {","    print(\"Hey, \\(nickname)\")","}","\/\/ Doesn't print anything, because nickname is nil."]},{"inlineContent":[{"code":"switch","type":"codeVoice"},{"text":"는 다양한 종류의 데이터와 비교 연산을 지원한다. 정수와 동등성 테스트에만 제한되지 않는다.","type":"text"}],"type":"paragraph"},{"syntax":"swift","type":"codeListing","code":["let vegetable = \"red pepper\"","switch vegetable {","case \"celery\":","    print(\"Add some raisins and make ants on a log.\")","case \"cucumber\", \"watercress\":","    print(\"That would make a good tea sandwich.\")","case let x where x.hasSuffix(\"pepper\"):","    print(\"Is it a spicy \\(x)?\")","default:","    print(\"Everything tastes good in soup.\")","}","\/\/ Prints \"Is it a spicy red pepper?\""]},{"content":[{"type":"paragraph","inlineContent":[{"text":"","type":"text"},{"type":"codeVoice","code":"default"},{"type":"text","text":" 케이스를 제거해 보자. 어떤 에러가 발생하는가?"}]}],"name":"실험","type":"aside","style":"note"},{"inlineContent":[{"type":"text","text":"패턴에서 "},{"type":"codeVoice","code":"let"},{"type":"text","text":"을 사용하여 패턴에 일치하는 값을 상수에 할당할 수 있다."}],"type":"paragraph"},{"inlineContent":[{"code":"switch","type":"codeVoice"},{"type":"text","text":" 케이스 내부의 코드를 실행한 후, 프로그램은 "},{"type":"codeVoice","code":"switch"},{"type":"text","text":" 문을 빠져나간다. 다음 케이스로 실행이 이어지지 않으므로 각 케이스의 코드 끝에서 명시적으로 "},{"type":"codeVoice","code":"break"},{"text":"를 사용할 필요가 없다.","type":"text"}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"type":"codeVoice","code":"for"},{"text":"-","type":"text"},{"type":"codeVoice","code":"in"},{"type":"text","text":"을 사용하여 딕셔너리의 항목을 반복할 때 각 키-값 쌍에 사용할 이름 쌍을 제공한다. 딕셔너리는 순서가 없는 컬렉션이므로 키와 값은 임의의 순서로 반복된다."}]},{"syntax":"swift","code":["let interestingNumbers = [","    \"Prime\": [2, 3, 5, 7, 11, 13],","    \"Fibonacci\": [1, 1, 2, 3, 5, 8],","    \"Square\": [1, 4, 9, 16, 25],","]","var largest = 0","for (_, numbers) in interestingNumbers {","    for number in numbers {","        if number > largest {","            largest = number","        }","    }","}","print(largest)","\/\/ Prints \"25\""],"type":"codeListing"},{"type":"aside","content":[{"inlineContent":[{"text":"","type":"text"},{"type":"codeVoice","code":"_"},{"type":"text","text":"를 변수 이름으로 바꾸고, 어떤 종류의 숫자가 가장 큰지 추적해 보자."}],"type":"paragraph"}],"style":"note","name":"실험"},{"inlineContent":[{"code":"while","type":"codeVoice"},{"type":"text","text":"을 사용하여 조건이 변경될 때까지 코드 블록을 반복한다. 루프의 조건을 끝에 두면 루프가 최소한 한 번은 실행되도록 보장할 수 있다."}],"type":"paragraph"},{"type":"codeListing","code":["var n = 2","while n < 100 {","    n *= 2","}","print(n)","\/\/ Prints \"128\"","","var m = 2","repeat {","    m *= 2","} while m < 100","print(m)","\/\/ Prints \"128\""],"syntax":"swift"},{"type":"aside","name":"실험","style":"note","content":[{"inlineContent":[{"text":"조건을 ","type":"text"},{"type":"codeVoice","code":"m < 100"},{"text":"에서 ","type":"text"},{"type":"codeVoice","code":"m < 0"},{"text":"으로 변경하여 ","type":"text"},{"type":"codeVoice","code":"while"},{"text":"과 ","type":"text"},{"type":"codeVoice","code":"repeat"},{"text":"-","type":"text"},{"type":"codeVoice","code":"while"},{"type":"text","text":"이 루프 조건이 이미 거짓일 때 어떻게 다르게 동작하는지 확인해 보자."}],"type":"paragraph"}]},{"inlineContent":[{"type":"codeVoice","code":"..<"},{"type":"text","text":"를 사용하여 인덱스 범위를 만들고 루프에서 인덱스를 유지할 수 있다."}],"type":"paragraph"},{"syntax":"swift","code":["var total = 0","for i in 0..<4 {","    total += i","}","print(total)","\/\/ Prints \"6\""],"type":"codeListing"},{"inlineContent":[{"type":"codeVoice","code":"..<"},{"text":"는 상한 값을 제외한 범위를 만들고, ","type":"text"},{"code":"...","type":"codeVoice"},{"type":"text","text":"는 상한 값을 포함한 범위를 만든다."}],"type":"paragraph"},{"type":"heading","level":2,"text":"함수와 클로저","anchor":"%ED%95%A8%EC%88%98%EC%99%80-%ED%81%B4%EB%A1%9C%EC%A0%80"},{"inlineContent":[{"code":"func","type":"codeVoice"},{"type":"text","text":" 키워드를 사용해 함수를 선언한다. 함수를 호출할 때는 함수 이름 뒤에 괄호 안에 인자를 나열한다. "},{"type":"codeVoice","code":"->"},{"text":"를 사용해 매개변수 이름과 타입을 함수의 반환 타입과 구분한다.","type":"text"}],"type":"paragraph"},{"code":["func greet(person: String, day: String) -> String {","    return \"Hello \\(person), today is \\(day).\"","}","greet(person: \"Bob\", day: \"Tuesday\")"],"type":"codeListing","syntax":"swift"},{"style":"note","type":"aside","content":[{"type":"paragraph","inlineContent":[{"text":"","type":"text"},{"code":"day","type":"codeVoice"},{"type":"text","text":" 매개변수를 제거하고, 오늘의 점심 특선을 포함하는 매개변수를 추가해 보자."}]}],"name":"실험"},{"inlineContent":[{"type":"text","text":"기본적으로 함수는 매개변수 이름을 인자 레이블로 사용한다. 매개변수 이름 앞에 커스텀 인자 레이블을 작성하거나, "},{"code":"_","type":"codeVoice"},{"text":"를 사용해 인자 레이블을 생략할 수 있다.","type":"text"}],"type":"paragraph"},{"type":"codeListing","syntax":"swift","code":["func greet(_ person: String, on day: String) -> String {","    return \"Hello \\(person), today is \\(day).\"","}","greet(\"John\", on: \"Wednesday\")"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"튜플을 사용해 복합 값을 만들 수 있다. 예를 들어, 함수에서 여러 값을 반환할 때 유용하다. 튜플의 요소는 이름이나 숫자로 참조할 수 있다."}]},{"type":"codeListing","code":["func calculateStatistics(scores: [Int]) -> (min: Int, max: Int, sum: Int) {","    var min = scores[0]","    var max = scores[0]","    var sum = 0","","    for score in scores {","        if score > max {","            max = score","        } else if score < min {","            min = score","        }","        sum += score","    }","","    return (min, max, sum)","}","let statistics = calculateStatistics(scores: [5, 3, 100, 3, 9])","print(statistics.sum)","\/\/ \"120\" 출력","print(statistics.2)","\/\/ \"120\" 출력"],"syntax":"swift"},{"inlineContent":[{"text":"함수는 중첩될 수 있다. 중첩 함수는 외부 함수에서 선언된 변수에 접근할 수 있다. 중첩 함수를 사용해 길거나 복잡한 함수의 코드를 정리할 수 있다.","type":"text"}],"type":"paragraph"},{"syntax":"swift","code":["func returnFifteen() -> Int {","    var y = 10","    func add() {","        y += 5","    }","    add()","    return y","}","returnFifteen()"],"type":"codeListing"},{"type":"paragraph","inlineContent":[{"type":"text","text":"함수는 퍼스트클래스 타입이다. 이는 함수가 다른 함수를 반환 값으로 가질 수 있음을 의미한다."}]},{"syntax":"swift","code":["func makeIncrementer() -> ((Int) -> Int) {","    func addOne(number: Int) -> Int {","        return 1 + number","    }","    return addOne","}","var increment = makeIncrementer()","increment(7)"],"type":"codeListing"},{"inlineContent":[{"text":"함수는 다른 함수를 인자로 받을 수 있다.","type":"text"}],"type":"paragraph"},{"code":["func hasAnyMatches(list: [Int], condition: (Int) -> Bool) -> Bool {","    for item in list {","        if condition(item) {","            return true","        }","    }","    return false","}","func lessThanTen(number: Int) -> Bool {","    return number < 10","}","var numbers = [20, 19, 7, 12]","hasAnyMatches(list: numbers, condition: lessThanTen)"],"type":"codeListing","syntax":"swift"},{"inlineContent":[{"type":"text","text":"함수는 클로저의 특수한 경우다. 클로저는 나중에 호출할 수 있는 코드 블록이다. 클로저 내부의 코드는 클로저가 생성된 스코프에서 사용 가능한 변수와 함수에 접근할 수 있다. 클로저가 실행될 때 다른 스코프에 있더라도 접근이 가능하다. 중첩 함수에서 이미 이 예를 보았다. 이름 없는 클로저를 작성하려면 코드를 중괄호("},{"code":"{}","type":"codeVoice"},{"type":"text","text":")로 감싼다. "},{"type":"codeVoice","code":"in"},{"type":"text","text":"을 사용해 인자와 반환 타입을 본문과 구분한다."}],"type":"paragraph"},{"code":["numbers.map({ (number: Int) -> Int in","    let result = 3 * number","    return result","})"],"type":"codeListing","syntax":"swift"},{"style":"note","name":"실험","type":"aside","content":[{"inlineContent":[{"type":"text","text":"모든 홀수에 대해 0을 반환하도록 클로저를 다시 작성해 보자."}],"type":"paragraph"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"클로저를 더 간결하게 작성하는 여러 방법이 있다. 클로저의 타입이 이미 알려져 있을 때, 예를 들어 델리게이트의 콜백인 경우, 매개변수 타입, 반환 타입 또는 둘 다 생략할 수 있다. 단일 문장 클로저는 암시적으로 해당 문장의 값을 반환한다."}]},{"code":["let mappedNumbers = numbers.map({ number in 3 * number })","print(mappedNumbers)","\/\/ \"[60, 57, 21, 36]\" 출력"],"type":"codeListing","syntax":"swift"},{"type":"paragraph","inlineContent":[{"type":"text","text":"매개변수를 이름 대신 숫자로 참조할 수 있다. 이 방법은 매우 짧은 클로저에서 특히 유용하다. 함수의 마지막 인자로 전달된 클로저는 괄호 바로 뒤에 나타낼 수 있다. 클로저가 함수의 유일한 인자라면 괄호를 완전히 생략할 수 있다."}]},{"code":["let sortedNumbers = numbers.sorted { $0 > $1 }","print(sortedNumbers)","\/\/ \"[20, 19, 12, 7]\" 출력"],"type":"codeListing","syntax":"swift"},{"type":"heading","text":"객체와 클래스","level":2,"anchor":"%EA%B0%9D%EC%B2%B4%EC%99%80-%ED%81%B4%EB%9E%98%EC%8A%A4"},{"type":"paragraph","inlineContent":[{"type":"text","text":"클래스를 생성하려면 "},{"code":"class","type":"codeVoice"},{"text":" 키워드 뒤에 클래스 이름을 작성한다. 클래스 내부의 프로퍼티 선언은 상수나 변수 선언과 동일하지만, 클래스의 컨텍스트 안에서 이루어진다. 마찬가지로 메서드와 함수 선언도 같은 방식으로 작성한다.","type":"text"}]},{"type":"codeListing","code":["class Shape {","    var numberOfSides = 0","    func simpleDescription() -> String {","        return \"A shape with \\(numberOfSides) sides.\"","    }","}"],"syntax":"swift"},{"name":"실험","style":"note","content":[{"inlineContent":[{"type":"text","text":""},{"code":"let","type":"codeVoice"},{"type":"text","text":"을 사용해 상수 프로퍼티를 추가하고, 인자를 받는 메서드를 하나 더 만들어 보자."}],"type":"paragraph"}],"type":"aside"},{"type":"paragraph","inlineContent":[{"type":"text","text":"클래스의 인스턴스를 생성하려면 클래스 이름 뒤에 괄호를 붙인다. 점 표기법을 사용해 인스턴스의 프로퍼티와 메서드에 접근한다."}]},{"syntax":"swift","type":"codeListing","code":["var shape = Shape()","shape.numberOfSides = 7","var shapeDescription = shape.simpleDescription()"]},{"inlineContent":[{"text":"이 ","type":"text"},{"type":"codeVoice","code":"Shape"},{"text":" 클래스는 중요한 것을 빠뜨렸다. 인스턴스가 생성될 때 클래스를 설정하는 초기화 메서드다. ","type":"text"},{"type":"codeVoice","code":"init"},{"text":"을 사용해 초기화 메서드를 만든다.","type":"text"}],"type":"paragraph"},{"syntax":"swift","code":["class NamedShape {","    var numberOfSides: Int = 0","    var name: String","","    init(name: String) {","       self.name = name","    }","","    func simpleDescription() -> String {","       return \"A shape with \\(numberOfSides) sides.\"","    }","}"],"type":"codeListing"},{"type":"paragraph","inlineContent":[{"type":"text","text":"초기화 메서드의 인자와 프로퍼티를 구분하기 위해 "},{"code":"self","type":"codeVoice"},{"type":"text","text":"를 사용한다. 클래스의 인스턴스를 생성할 때 초기화 메서드의 인자를 함수 호출처럼 전달한다. 모든 프로퍼티는 선언 시("},{"code":"numberOfSides","type":"codeVoice"},{"type":"text","text":"처럼) 또는 초기화 메서드 안에서("},{"code":"name","type":"codeVoice"},{"text":"처럼) 값을 할당해야 한다.","type":"text"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"객체가 해제되기 전에 정리 작업이 필요하다면 "},{"type":"codeVoice","code":"deinit"},{"type":"text","text":"을 사용해 소멸자를 만들 수 있다."}]},{"inlineContent":[{"text":"서브클래스는 클래스 이름 뒤에 콜론을 붙이고 슈퍼클래스 이름을 적는다. 모든 클래스가 표준 루트 클래스를 상속해야 하는 것은 아니므로, 필요에 따라 슈퍼클래스를 포함하거나 생략할 수 있다.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"서브클래스에서 슈퍼클래스의 메서드를 재정의할 때는 "},{"code":"override","type":"codeVoice"},{"type":"text","text":"를 사용한다. 실수로 "},{"type":"codeVoice","code":"override"},{"type":"text","text":" 없이 메서드를 재정의하면 컴파일러가 오류로 인식한다. 또한 슈퍼클래스에서 실제로 재정의할 메서드가 없는데 "},{"code":"override","type":"codeVoice"},{"type":"text","text":"를 사용하면 컴파일러가 이를 감지한다."}],"type":"paragraph"},{"type":"codeListing","syntax":"swift","code":["class Square: NamedShape {","    var sideLength: Double","","    init(sideLength: Double, name: String) {","        self.sideLength = sideLength","        super.init(name: name)","        numberOfSides = 4","    }","","    func area() -> Double {","        return sideLength * sideLength","    }","","    override func simpleDescription() -> String {","        return \"A square with sides of length \\(sideLength).\"","    }","}","let test = Square(sideLength: 5.2, name: \"my test square\")","test.area()","test.simpleDescription()"]},{"style":"note","name":"실험","content":[{"inlineContent":[{"text":"","type":"text"},{"type":"codeVoice","code":"NamedShape"},{"type":"text","text":"의 서브클래스인 "},{"code":"Circle","type":"codeVoice"},{"type":"text","text":"을 만들어 보자. 반지름과 이름을 초기화 메서드의 인자로 받고, "},{"type":"codeVoice","code":"area()"},{"text":"와 ","type":"text"},{"type":"codeVoice","code":"simpleDescription()"},{"type":"text","text":" 메서드를 구현한다."}],"type":"paragraph"}],"type":"aside"},{"inlineContent":[{"type":"text","text":"단순히 저장되는 프로퍼티 외에도, 프로퍼티에 게터와 세터를 추가할 수 있다."}],"type":"paragraph"},{"type":"codeListing","syntax":"swift","code":["class EquilateralTriangle: NamedShape {","    var sideLength: Double = 0.0","","    init(sideLength: Double, name: String) {","        self.sideLength = sideLength","        super.init(name: name)","        numberOfSides = 3","    }","","    var perimeter: Double {","        get {","             return 3.0 * sideLength","        }","        set {","            sideLength = newValue \/ 3.0","        }","    }","","    override func simpleDescription() -> String {","        return \"An equilateral triangle with sides of length \\(sideLength).\"","    }","}","var triangle = EquilateralTriangle(sideLength: 3.1, name: \"a triangle\")","print(triangle.perimeter)","\/\/ Prints \"9.3\"","triangle.perimeter = 9.9","print(triangle.sideLength)","\/\/ Prints \"3.3000000000000003\""]},{"inlineContent":[{"code":"perimeter","type":"codeVoice"},{"type":"text","text":"의 세터에서 새 값은 암시적으로 "},{"type":"codeVoice","code":"newValue"},{"type":"text","text":"라는 이름을 가진다. "},{"code":"set","type":"codeVoice"},{"text":" 뒤에 괄호를 붙여 명시적인 이름을 제공할 수도 있다.","type":"text"}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"code":"EquilateralTriangle","type":"codeVoice"},{"type":"text","text":" 클래스의 초기화 메서드는 세 단계로 이루어진다:"}]},{"type":"orderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"서브클래스가 선언한 프로퍼티의 값을 설정한다."}]}]},{"content":[{"inlineContent":[{"type":"text","text":"슈퍼클래스의 초기화 메서드를 호출한다."}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"text":"슈퍼클래스에서 정의한 프로퍼티의 값을 변경한다. 이 시점에서 메서드, 게터, 세터를 사용해 추가 설정 작업을 할 수도 있다.","type":"text"}],"type":"paragraph"}]}]},{"type":"paragraph","inlineContent":[{"text":"프로퍼티를 계산할 필요는 없지만, 새 값을 설정하기 전후에 실행할 코드가 필요하다면 ","type":"text"},{"code":"willSet","type":"codeVoice"},{"type":"text","text":"과 "},{"type":"codeVoice","code":"didSet"},{"text":"을 사용한다. 이 코드는 초기화 메서드 외부에서 값이 변경될 때마다 실행된다. 예를 들어, 아래 클래스는 삼각형의 변 길이가 항상 정사각형의 변 길이와 같도록 보장한다.","type":"text"}]},{"code":["class TriangleAndSquare {","    var triangle: EquilateralTriangle {","        willSet {","            square.sideLength = newValue.sideLength","        }","    }","    var square: Square {","        willSet {","            triangle.sideLength = newValue.sideLength","        }","    }","    init(size: Double, name: String) {","        square = Square(sideLength: size, name: name)","        triangle = EquilateralTriangle(sideLength: size, name: name)","    }","}","var triangleAndSquare = TriangleAndSquare(size: 10, name: \"another test shape\")","print(triangleAndSquare.square.sideLength)","\/\/ Prints \"10.0\"","print(triangleAndSquare.triangle.sideLength)","\/\/ Prints \"10.0\"","triangleAndSquare.square = Square(sideLength: 50, name: \"larger square\")","print(triangleAndSquare.triangle.sideLength)","\/\/ Prints \"50.0\""],"type":"codeListing","syntax":"swift"},{"inlineContent":[{"type":"text","text":"옵셔널 값을 다룰 때는 메서드, 프로퍼티, 서브스크립팅 같은 작업 앞에 "},{"type":"codeVoice","code":"?"},{"type":"text","text":"를 붙일 수 있다. "},{"code":"?","type":"codeVoice"},{"text":" 앞의 값이 ","type":"text"},{"code":"nil","type":"codeVoice"},{"text":"이면 ","type":"text"},{"code":"?","type":"codeVoice"},{"text":" 뒤의 모든 작업은 무시되고 전체 표현식의 값은 ","type":"text"},{"type":"codeVoice","code":"nil"},{"type":"text","text":"이 된다. 그렇지 않으면 옵셔널 값이 언래핑되고, "},{"code":"?","type":"codeVoice"},{"text":" 뒤의 모든 작업은 언래핑된 값에 대해 수행된다. 두 경우 모두 전체 표현식의 값은 옵셔널 값이다.","type":"text"}],"type":"paragraph"},{"type":"codeListing","code":["let optionalSquare: Square? = Square(sideLength: 2.5, name: \"optional square\")","let sideLength = optionalSquare?.sideLength"],"syntax":"swift"},{"text":"열거형과 구조체","anchor":"%EC%97%B4%EA%B1%B0%ED%98%95%EA%B3%BC-%EA%B5%AC%EC%A1%B0%EC%B2%B4","type":"heading","level":2},{"type":"paragraph","inlineContent":[{"type":"codeVoice","code":"enum"},{"text":"을 사용해 열거형을 정의한다. 클래스와 다른 이름 있는 타입들처럼 열거형도 메서드를 가질 수 있다.","type":"text"}]},{"code":["enum Rank: Int {","    case ace = 1","    case two, three, four, five, six, seven, eight, nine, ten","    case jack, queen, king","","    func simpleDescription() -> String {","        switch self {","        case .ace:","            return \"ace\"","        case .jack:","            return \"jack\"","        case .queen:","            return \"queen\"","        case .king:","            return \"king\"","        default:","            return String(self.rawValue)","        }","    }","}","let ace = Rank.ace","let aceRawValue = ace.rawValue"],"type":"codeListing","syntax":"swift"},{"type":"aside","name":"실험","style":"note","content":[{"inlineContent":[{"type":"text","text":"두 "},{"code":"Rank","type":"codeVoice"},{"type":"text","text":" 값을 비교하는 함수를 작성해 보자. 비교는 각각의 원시 값을 기준으로 한다."}],"type":"paragraph"}]},{"inlineContent":[{"text":"스위프트는 기본적으로 원시 값을 0부터 시작해 1씩 증가시키지만, 명시적으로 값을 지정해 이 동작을 변경할 수 있다. 위 예제에서는 ","type":"text"},{"type":"codeVoice","code":"Ace"},{"text":"에 원시 값 ","type":"text"},{"type":"codeVoice","code":"1"},{"text":"을 명시적으로 할당했고, 나머지 원시 값은 순서대로 지정되었다. 문자열이나 부동소수점 숫자를 열거형의 원시 타입으로 사용할 수도 있다. ","type":"text"},{"type":"codeVoice","code":"rawValue"},{"type":"text","text":" 프로퍼티를 사용해 열거형 케이스의 원시 값에 접근한다."}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"type":"codeVoice","code":"init?(rawValue:)"},{"type":"text","text":" 이니셜라이저를 사용해 원시 값으로부터 열거형 인스턴스를 생성한다. 이 이니셜라이저는 원시 값과 일치하는 열거형 케이스를 반환하거나, 일치하는 "},{"type":"codeVoice","code":"Rank"},{"type":"text","text":"가 없으면 "},{"type":"codeVoice","code":"nil"},{"text":"을 반환한다.","type":"text"}]},{"type":"codeListing","code":["if let convertedRank = Rank(rawValue: 3) {","    let threeDescription = convertedRank.simpleDescription()","}"],"syntax":"swift"},{"type":"paragraph","inlineContent":[{"type":"text","text":"열거형의 케이스 값은 실제 값이며, 단순히 원시 값을 나타내는 또 다른 방식이 아니다. 사실, 의미 있는 원시 값이 없는 경우에는 원시 값을 제공하지 않아도 된다."}]},{"syntax":"swift","type":"codeListing","code":["enum Suit {","    case spades, hearts, diamonds, clubs","","    func simpleDescription() -> String {","        switch self {","        case .spades:","            return \"spades\"","        case .hearts:","            return \"hearts\"","        case .diamonds:","            return \"diamonds\"","        case .clubs:","            return \"clubs\"","        }","    }","}","let hearts = Suit.hearts","let heartsDescription = hearts.simpleDescription()"]},{"content":[{"type":"paragraph","inlineContent":[{"text":"","type":"text"},{"code":"Suit","type":"codeVoice"},{"type":"text","text":"에 "},{"type":"codeVoice","code":"color()"},{"type":"text","text":" 메서드를 추가해 보자. 스페이드와 클럽은 “black”을, 하트와 다이아몬드는 “red”를 반환한다."}]}],"style":"note","name":"실험","type":"aside"},{"type":"paragraph","inlineContent":[{"type":"text","text":"열거형의 "},{"type":"codeVoice","code":"hearts"},{"type":"text","text":" 케이스를 참조하는 두 가지 방식을 주목하자. "},{"type":"codeVoice","code":"hearts"},{"text":" 상수에 값을 할당할 때는 열거형 케이스 ","type":"text"},{"code":"Suit.hearts","type":"codeVoice"},{"text":"를 전체 이름으로 참조한다. 상수에 명시적 타입이 지정되지 않았기 때문이다. 스위치 내부에서는 열거형 케이스를 축약형 ","type":"text"},{"code":".hearts","type":"codeVoice"},{"text":"로 참조한다. ","type":"text"},{"code":"self","type":"codeVoice"},{"type":"text","text":"의 값이 이미 "},{"code":"Suit","type":"codeVoice"},{"text":" 타입임이 알려져 있기 때문이다. 값의 타입이 이미 알려진 경우에는 언제나 축약형을 사용할 수 있다.","type":"text"}]},{"inlineContent":[{"text":"열거형이 원시 값을 가지면, 그 값은 선언의 일부로 결정된다. 즉, 특정 열거형 케이스의 모든 인스턴스는 항상 동일한 원시 값을 가진다. 열거형 케이스에 값을 연관시킬 수도 있다. 이 값은 인스턴스를 생성할 때 결정되며, 열거형 케이스의 각 인스턴스마다 다를 수 있다. 연관된 값은 열거형 케이스 인스턴스의 저장 프로퍼티처럼 동작한다고 볼 수 있다. 예를 들어, 서버에 일출과 일몰 시간을 요청하는 경우를 생각해 보자. 서버는 요청한 정보를 응답하거나, 무엇이 잘못되었는지 설명하는 메시지를 응답한다.","type":"text"}],"type":"paragraph"},{"syntax":"swift","code":["enum ServerResponse {","    case result(String, String)","    case failure(String)","}","","let success = ServerResponse.result(\"6:00 am\", \"8:09 pm\")","let failure = ServerResponse.failure(\"Out of cheese.\")","","switch success {","case let .result(sunrise, sunset):","    print(\"Sunrise is at \\(sunrise) and sunset is at \\(sunset).\")","case let .failure(message):","    print(\"Failure...  \\(message)\")","}","\/\/ Prints \"Sunrise is at 6:00 am and sunset is at 8:09 pm.\""],"type":"codeListing"},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":""},{"type":"codeVoice","code":"ServerResponse"},{"text":"에 세 번째 케이스를 추가하고, 스위치에도 이를 반영해 보자.","type":"text"}]}],"style":"note","type":"aside","name":"실험"},{"type":"paragraph","inlineContent":[{"type":"text","text":"일출과 일몰 시간이 어떻게 "},{"type":"codeVoice","code":"ServerResponse"},{"text":" 값에서 추출되는지 주목하자. 이 값은 스위치 케이스와 매치되는 과정에서 추출된다.","type":"text"}]},{"inlineContent":[{"type":"codeVoice","code":"struct"},{"text":"를 사용해 구조체를 정의한다. 구조체는 클래스와 많은 동작을 공유한다. 메서드와 이니셜라이저를 포함한다. 구조체와 클래스의 가장 중요한 차이점 중 하나는 구조체는 코드에서 전달될 때 항상 복사되지만, 클래스는 참조로 전달된다는 점이다.","type":"text"}],"type":"paragraph"},{"type":"codeListing","syntax":"swift","code":["struct Card {","    var rank: Rank","    var suit: Suit","    func simpleDescription() -> String {","        return \"The \\(rank.simpleDescription()) of \\(suit.simpleDescription())\"","    }","}","let threeOfSpades = Card(rank: .three, suit: .spades)","let threeOfSpadesDescription = threeOfSpades.simpleDescription()"]},{"style":"note","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"각 랭크와 슈트의 조합으로 이루어진 카드 한 벌을 담은 배열을 반환하는 함수를 작성해 보자."}]}],"type":"aside","name":"실험"},{"level":2,"anchor":"%EB%8F%99%EC%8B%9C%EC%84%B1","text":"동시성","type":"heading"},{"type":"paragraph","inlineContent":[{"type":"text","text":"비동기적으로 실행되는 함수를 표시하려면 "},{"code":"async","type":"codeVoice"},{"type":"text","text":"를 사용한다."}]},{"type":"codeListing","code":["func fetchUserID(from server: String) async -> Int {","    if server == \"primary\" {","        return 97","    }","    return 501","}"],"syntax":"swift"},{"type":"paragraph","inlineContent":[{"type":"text","text":"비동기 함수를 호출할 때는 앞에 "},{"type":"codeVoice","code":"await"},{"type":"text","text":"를 붙인다."}]},{"syntax":"swift","code":["func fetchUsername(from server: String) async -> String {","    let userID = await fetchUserID(from: server)","    if userID == 501 {","        return \"John Appleseed\"","    }","    return \"Guest\"","}"],"type":"codeListing"},{"type":"paragraph","inlineContent":[{"type":"codeVoice","code":"async let"},{"type":"text","text":"을 사용하면 비동기 함수를 호출하고 다른 비동기 코드와 병렬로 실행할 수 있다. 반환된 값을 사용할 때는 "},{"code":"await","type":"codeVoice"},{"text":"를 붙인다.","type":"text"}]},{"type":"codeListing","syntax":"swift","code":["func connectUser(to server: String) async {","    async let userID = fetchUserID(from: server)","    async let username = fetchUsername(from: server)","    let greeting = await \"Hello \\(username), user ID \\(userID)\"","    print(greeting)","}"]},{"type":"paragraph","inlineContent":[{"code":"Task","type":"codeVoice"},{"type":"text","text":"를 사용하면 동기 코드에서 비동기 함수를 호출하고 결과를 기다리지 않을 수 있다."}]},{"type":"codeListing","code":["Task {","    await connectUser(to: \"primary\")","}","\/\/ Prints \"Hello Guest, user ID 97\""],"syntax":"swift"},{"type":"paragraph","inlineContent":[{"type":"text","text":"태스크 그룹을 사용하면 동시성 코드를 구조화할 수 있다."}]},{"code":["let userIDs = await withTaskGroup(of: Int.self) { group in","    for server in [\"primary\", \"secondary\", \"development\"] {","        group.addTask {","            return await fetchUserID(from: server)","        }","    }","","    var results: [Int] = []","    for await result in group {","        results.append(result)","    }","    return results","}"],"type":"codeListing","syntax":"swift"},{"type":"paragraph","inlineContent":[{"text":"액터는 클래스와 유사하지만, 서로 다른 비동기 함수가 동일한 액터의 인스턴스와 안전하게 상호작용할 수 있도록 보장한다.","type":"text"}]},{"code":["actor ServerConnection {","    var server: String = \"primary\"","    private var activeUsers: [Int] = []","    func connect() async -> Int {","        let userID = await fetchUserID(from: server)","        \/\/ ... 서버와 통신 ...","        activeUsers.append(userID)","        return userID","    }","}"],"type":"codeListing","syntax":"swift"},{"inlineContent":[{"text":"액터의 메서드를 호출하거나 프로퍼티에 접근할 때는 ","type":"text"},{"code":"await","type":"codeVoice"},{"text":"를 사용해 해당 코드가 액터에서 이미 실행 중인 다른 코드가 끝날 때까지 기다려야 할 수 있음을 표시한다.","type":"text"}],"type":"paragraph"},{"type":"codeListing","syntax":"swift","code":["let server = ServerConnection()","let userID = await server.connect()"]},{"type":"heading","anchor":"%ED%94%84%EB%A1%9C%ED%86%A0%EC%BD%9C%EA%B3%BC-%ED%99%95%EC%9E%A5","level":2,"text":"프로토콜과 확장"},{"type":"paragraph","inlineContent":[{"code":"protocol","type":"codeVoice"},{"text":"을 사용해 프로토콜을 정의한다.","type":"text"}]},{"type":"codeListing","syntax":"swift","code":["protocol ExampleProtocol {","     var simpleDescription: String { get }","     mutating func adjust()","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"클래스, 열거형, 구조체 모두 프로토콜을 채택할 수 있다."}]},{"code":["class SimpleClass: ExampleProtocol {","     var simpleDescription: String = \"A very simple class.\"","     var anotherProperty: Int = 69105","     func adjust() {","          simpleDescription += \"  Now 100% adjusted.\"","     }","}","var a = SimpleClass()","a.adjust()","let aDescription = a.simpleDescription","","struct SimpleStructure: ExampleProtocol {","     var simpleDescription: String = \"A simple structure\"","     mutating func adjust() {","          simpleDescription += \" (adjusted)\"","     }","}","var b = SimpleStructure()","b.adjust()","let bDescription = b.simpleDescription"],"type":"codeListing","syntax":"swift"},{"name":"실험","style":"note","type":"aside","content":[{"inlineContent":[{"type":"text","text":""},{"type":"codeVoice","code":"ExampleProtocol"},{"text":"에 새로운 요구사항을 추가해 보자. ","type":"text"},{"type":"codeVoice","code":"SimpleClass"},{"type":"text","text":"와 "},{"type":"codeVoice","code":"SimpleStructure"},{"type":"text","text":"가 여전히 프로토콜을 준수하려면 어떤 변경이 필요한가?"}],"type":"paragraph"}]},{"type":"paragraph","inlineContent":[{"type":"codeVoice","code":"SimpleStructure"},{"type":"text","text":"의 선언에서 "},{"type":"codeVoice","code":"mutating"},{"text":" 키워드를 사용해 구조체를 수정하는 메서드를 표시한다. ","type":"text"},{"type":"codeVoice","code":"SimpleClass"},{"type":"text","text":"의 선언에서는 클래스의 메서드가 항상 클래스를 수정할 수 있기 때문에 "},{"type":"codeVoice","code":"mutating"},{"text":" 키워드가 필요하지 않다.","type":"text"}]},{"type":"paragraph","inlineContent":[{"type":"codeVoice","code":"extension"},{"text":"을 사용해 기존 타입에 새로운 메서드나 계산된 속성과 같은 기능을 추가할 수 있다. 확장을 통해 다른 곳에서 선언된 타입이나 라이브러리나 프레임워크에서 임포트한 타입에 프로토콜 준수를 추가할 수도 있다.","type":"text"}]},{"code":["extension Int: ExampleProtocol {","    var simpleDescription: String {","        return \"The number \\(self)\"","    }","    mutating func adjust() {","        self += 42","    }"," }","print(7.simpleDescription)","\/\/ Prints \"The number 7\""],"type":"codeListing","syntax":"swift"},{"type":"aside","style":"note","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":""},{"type":"codeVoice","code":"Double"},{"type":"text","text":" 타입에 "},{"code":"absoluteValue","type":"codeVoice"},{"type":"text","text":" 속성을 추가하는 확장을 작성해 보자."}]}],"name":"실험"},{"type":"paragraph","inlineContent":[{"type":"text","text":"프로토콜 이름을 다른 이름 있는 타입처럼 사용할 수 있다. 예를 들어, 서로 다른 타입이지만 모두 하나의 프로토콜을 준수하는 객체 컬렉션을 만들 수 있다. 프로토콜 타입으로 박싱된 값을 다룰 때는 프로토콜 정의 외부의 메서드를 사용할 수 없다."}]},{"code":["let protocolValue: any ExampleProtocol = a","print(protocolValue.simpleDescription)","\/\/ Prints \"A very simple class.  Now 100% adjusted.\"","\/\/ print(protocolValue.anotherProperty)  \/\/ Uncomment to see the error"],"type":"codeListing","syntax":"swift"},{"inlineContent":[{"code":"protocolValue","type":"codeVoice"},{"type":"text","text":" 변수의 런타임 타입이 "},{"code":"SimpleClass","type":"codeVoice"},{"type":"text","text":"임에도 불구하고, 컴파일러는 이를 "},{"code":"ExampleProtocol","type":"codeVoice"},{"type":"text","text":" 타입으로 간주한다. 이는 클래스가 프로토콜 준수 외에 추가로 구현한 메서드나 속성에 실수로 접근할 수 없음을 의미한다."}],"type":"paragraph"},{"level":2,"type":"heading","text":"에러 처리","anchor":"%EC%97%90%EB%9F%AC-%EC%B2%98%EB%A6%AC"},{"type":"paragraph","inlineContent":[{"code":"Error","type":"codeVoice"},{"type":"text","text":" 프로토콜을 채택한 타입을 사용해 에러를 표현한다."}]},{"code":["enum PrinterError: Error {","    case outOfPaper","    case noToner","    case onFire","}"],"type":"codeListing","syntax":"swift"},{"inlineContent":[{"type":"text","text":"에러를 던질 때는 "},{"code":"throw","type":"codeVoice"},{"type":"text","text":"를 사용하고, 에러를 던질 수 있는 함수는 "},{"type":"codeVoice","code":"throws"},{"text":"로 표시한다. 함수 내에서 에러를 던지면, 함수는 즉시 반환되고 호출한 코드가 에러를 처리한다.","type":"text"}],"type":"paragraph"},{"type":"codeListing","syntax":"swift","code":["func send(job: Int, toPrinter printerName: String) throws -> String {","    if printerName == \"Never Has Toner\" {","        throw PrinterError.noToner","    }","    return \"Job sent\"","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"에러를 처리하는 방법은 여러 가지다. "},{"code":"do","type":"codeVoice"},{"type":"text","text":"-"},{"code":"catch","type":"codeVoice"},{"text":"를 사용하는 방법이 그 중 하나다. ","type":"text"},{"type":"codeVoice","code":"do"},{"type":"text","text":" 블록 안에서 에러를 던질 수 있는 코드 앞에 "},{"type":"codeVoice","code":"try"},{"type":"text","text":"를 붙인다. "},{"type":"codeVoice","code":"catch"},{"type":"text","text":" 블록 안에서는 에러가 자동으로 "},{"type":"codeVoice","code":"error"},{"text":"라는 이름으로 주어지며, 다른 이름을 지정할 수도 있다.","type":"text"}]},{"syntax":"swift","type":"codeListing","code":["do {","    let printerResponse = try send(job: 1040, toPrinter: \"Bi Sheng\")","    print(printerResponse)","} catch {","    print(error)","}","\/\/ Prints \"Job sent\""]},{"type":"aside","style":"note","name":"실험","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"프린터 이름을 "},{"code":"\"Never Has Toner\"","type":"codeVoice"},{"type":"text","text":"로 바꿔서 "},{"type":"codeVoice","code":"send(job:toPrinter:)"},{"type":"text","text":" 함수가 에러를 던지도록 해보자."}]}]},{"inlineContent":[{"type":"text","text":"특정 에러를 처리하기 위해 여러 개의 "},{"code":"catch","type":"codeVoice"},{"text":" 블록을 제공할 수 있다. ","type":"text"},{"code":"catch","type":"codeVoice"},{"type":"text","text":" 뒤에 패턴을 작성하는 방식은 "},{"type":"codeVoice","code":"switch"},{"type":"text","text":" 문의 "},{"code":"case","type":"codeVoice"},{"type":"text","text":"와 유사하다."}],"type":"paragraph"},{"code":["do {","    let printerResponse = try send(job: 1440, toPrinter: \"Gutenberg\")","    print(printerResponse)","} catch PrinterError.onFire {","    print(\"I'll just put this over here, with the rest of the fire.\")","} catch let printerError as PrinterError {","    print(\"Printer error: \\(printerError).\")","} catch {","    print(error)","}","\/\/ Prints \"Job sent\""],"type":"codeListing","syntax":"swift"},{"name":"실험","type":"aside","content":[{"type":"paragraph","inlineContent":[{"text":"","type":"text"},{"type":"codeVoice","code":"do"},{"text":" 블록 안에 에러를 던지는 코드를 추가해보자. 첫 번째 ","type":"text"},{"code":"catch","type":"codeVoice"},{"type":"text","text":" 블록에서 처리될 에러는 어떤 종류인가? 두 번째와 세 번째 블록에서는 어떤 에러가 처리되는가?"}]}],"style":"note"},{"type":"paragraph","inlineContent":[{"type":"text","text":"에러를 처리하는 또 다른 방법은 "},{"type":"codeVoice","code":"try?"},{"text":"를 사용해 결과를 옵셔널로 변환하는 것이다. 함수가 에러를 던지면 특정 에러는 버려지고 결과는 ","type":"text"},{"code":"nil","type":"codeVoice"},{"type":"text","text":"이 된다. 그렇지 않으면 함수가 반환한 값을 포함한 옵셔널이 결과로 나온다."}]},{"type":"codeListing","code":["let printerSuccess = try? send(job: 1884, toPrinter: \"Mergenthaler\")","let printerFailure = try? send(job: 1885, toPrinter: \"Never Has Toner\")"],"syntax":"swift"},{"inlineContent":[{"type":"codeVoice","code":"defer"},{"type":"text","text":"를 사용해 함수 내의 다른 코드가 모두 실행된 후, 함수가 반환되기 직전에 실행될 코드 블록을 작성할 수 있다. 이 코드는 함수가 에러를 던지더라도 실행된다. "},{"code":"defer","type":"codeVoice"},{"type":"text","text":"를 사용하면 설정 코드와 정리 코드를 서로 가까이 배치할 수 있으며, 이 코드들은 서로 다른 시점에 실행된다."}],"type":"paragraph"},{"type":"codeListing","syntax":"swift","code":["var fridgeIsOpen = false","let fridgeContent = [\"milk\", \"eggs\", \"leftovers\"]","","func fridgeContains(_ food: String) -> Bool {","    fridgeIsOpen = true","    defer {","        fridgeIsOpen = false","    }","","    let result = fridgeContent.contains(food)","    return result","}","if fridgeContains(\"banana\") {","    print(\"Found a banana\")","}","print(fridgeIsOpen)","\/\/ Prints \"false\""]},{"text":"제네릭","level":2,"type":"heading","anchor":"%EC%A0%9C%EB%84%A4%EB%A6%AD"},{"inlineContent":[{"type":"text","text":"제네릭 함수나 타입을 만들려면 꺾쇠 괄호 안에 이름을 작성한다."}],"type":"paragraph"},{"type":"codeListing","code":["func makeArray<Item>(repeating item: Item, numberOfTimes: Int) -> [Item] {","    var result: [Item] = []","    for _ in 0..<numberOfTimes {","         result.append(item)","    }","    return result","}","makeArray(repeating: \"knock\", numberOfTimes: 4)"],"syntax":"swift"},{"type":"paragraph","inlineContent":[{"type":"text","text":"함수와 메서드뿐만 아니라 클래스, 열거형, 구조체도 제네릭으로 만들 수 있다."}]},{"syntax":"swift","code":["\/\/ Swift 표준 라이브러리의 옵셔널 타입을 재구현","enum OptionalValue<Wrapped> {","    case none","    case some(Wrapped)","}","var possibleInteger: OptionalValue<Int> = .none","possibleInteger = .some(100)"],"type":"codeListing"},{"inlineContent":[{"type":"text","text":"본문 바로 앞에 "},{"type":"codeVoice","code":"where"},{"type":"text","text":"를 사용해 요구사항 목록을 지정할 수 있다. 예를 들어, 타입이 특정 프로토콜을 구현하도록 요구하거나, 두 타입이 동일하도록 요구하거나, 클래스가 특정 슈퍼클래스를 가지도록 요구할 수 있다."}],"type":"paragraph"},{"code":["func anyCommonElements<T: Sequence, U: Sequence>(_ lhs: T, _ rhs: U) -> Bool","    where T.Element: Equatable, T.Element == U.Element","{","    for lhsItem in lhs {","        for rhsItem in rhs {","            if lhsItem == rhsItem {","                return true","            }","        }","    }","   return false","}","anyCommonElements([1, 2, 3], [3])"],"type":"codeListing","syntax":"swift"},{"style":"note","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":""},{"code":"anyCommonElements(_:_:)","type":"codeVoice"},{"text":" 함수를 수정해 두 시퀀스가 공통으로 가지는 엘리먼트를 배열로 반환하는 함수를 만들어 보자.","type":"text"}]}],"type":"aside","name":"실험"},{"type":"paragraph","inlineContent":[{"code":"<T: Equatable>","type":"codeVoice"},{"text":"은 ","type":"text"},{"code":"<T> ... where T: Equatable","type":"codeVoice"},{"type":"text","text":"과 동일하다."}]}],"kind":"content"}],"abstract":[{"type":"text","text":"Swift의 기능과 문법을 탐구한다."}],"schemaVersion":{"minor":3,"major":0,"patch":0},"identifier":{"url":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/GuidedTour","interfaceLanguage":"swift"},"hierarchy":{"paths":[["doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language"]]},"sections":[],"kind":"article","references":{"doc://org.swift.tspl/documentation/The-Swift-Programming-Language":{"title":"The Swift Programming Language (6.1)","abstract":[],"kind":"article","role":"collection","type":"topic","url":"\/documentation\/the-swift-programming-language","identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language"}}}