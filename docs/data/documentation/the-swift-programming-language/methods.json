{"schemaVersion":{"minor":3,"patch":0,"major":0},"sections":[],"kind":"article","abstract":[{"type":"text","text":"특정 인스턴스나 타입에 속한 함수를 정의하고 호출하는 방법을 알아본다."}],"primaryContentSections":[{"content":[{"inlineContent":[{"inlineContent":[{"text":"메서드","type":"text"}],"type":"emphasis"},{"type":"text","text":"는 특정 타입과 연관된 함수를 의미한다. 클래스, 구조체, 열거형 모두 인스턴스 메서드를 정의할 수 있다. 인스턴스 메서드는 해당 타입의 인스턴스와 관련된 특정 작업과 기능을 캡슐화한다. 또한 클래스, 구조체, 열거형은 타입 메서드도 정의할 수 있다. 타입 메서드는 타입 자체와 연관되며, Objective-C의 클래스 메서드와 유사하다."}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Swift에서 구조체와 열거형이 메서드를 정의할 수 있다는 점은 C와 Objective-C와의 큰 차이점이다. Objective-C에서는 클래스만 메서드를 정의할 수 있다. 반면 Swift에서는 클래스, 구조체, 열거형 중 어떤 타입을 정의할지 선택할 수 있고, 여전히 해당 타입에 메서드를 정의할 수 있는 유연성을 제공한다."}]},{"anchor":"%EC%9D%B8%EC%8A%A4%ED%84%B4%EC%8A%A4-%EB%A9%94%EC%84%9C%EB%93%9C","level":2,"text":"인스턴스 메서드","type":"heading"},{"type":"paragraph","inlineContent":[{"inlineContent":[{"text":"인스턴스 메서드","type":"text"}],"type":"emphasis"},{"type":"text","text":"는 특정 클래스, 구조체, 또는 열거형의 인스턴스에 속하는 함수다. 이 메서드는 인스턴스 프로퍼티에 접근하고 수정하는 방법을 제공하거나, 인스턴스의 목적과 관련된 기능을 제공함으로써 해당 인스턴스의 기능을 지원한다. 인스턴스 메서드는 "},{"isActive":true,"type":"reference","identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Functions"},{"type":"text","text":"에서 설명한 함수와 동일한 문법을 사용한다."}]},{"inlineContent":[{"type":"text","text":"인스턴스 메서드는 해당 타입의 시작과 끝 중괄호 안에 작성한다. 인스턴스 메서드는 해당 타입의 다른 모든 인스턴스 메서드와 프로퍼티에 암시적으로 접근할 수 있다. 인스턴스 메서드는 해당 타입의 특정 인스턴스에서만 호출할 수 있다. 기존 인스턴스 없이 단독으로 호출할 수 없다."}],"type":"paragraph"},{"inlineContent":[{"text":"다음은 특정 동작이 발생한 횟수를 세는 데 사용할 수 있는 간단한 ","type":"text"},{"type":"codeVoice","code":"Counter"},{"type":"text","text":" 클래스를 정의한 예제다:"}],"type":"paragraph"},{"code":["class Counter {","    var count = 0","    func increment() {","        count += 1","    }","    func increment(by amount: Int) {","        count += amount","    }","    func reset() {","        count = 0","    }","}"],"type":"codeListing","syntax":"swift"},{"inlineContent":[{"type":"codeVoice","code":"Counter"},{"text":" 클래스는 세 가지 인스턴스 메서드를 정의한다:","type":"text"}],"type":"paragraph"},{"type":"unorderedList","items":[{"content":[{"inlineContent":[{"type":"codeVoice","code":"increment()"},{"type":"text","text":"는 카운터를 "},{"code":"1","type":"codeVoice"},{"text":"만큼 증가시킨다.","type":"text"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"type":"codeVoice","code":"increment(by: Int)"},{"text":"는 카운터를 지정된 정수만큼 증가시킨다.","type":"text"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"code":"reset()","type":"codeVoice"},{"type":"text","text":"는 카운터를 "},{"type":"codeVoice","code":"0"},{"text":"으로 초기화한다.","type":"text"}]}]}]},{"inlineContent":[{"code":"Counter","type":"codeVoice"},{"type":"text","text":" 클래스는 현재 카운터 값을 추적하기 위해 "},{"code":"count","type":"codeVoice"},{"type":"text","text":"라는 변수 프로퍼티도 선언한다."}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"type":"text","text":"인스턴스 메서드는 프로퍼티와 동일한 점 문법으로 호출한다:"}]},{"code":["let counter = Counter()","\/\/ 초기 카운터 값은 0","counter.increment()","\/\/ 카운터 값은 이제 1","counter.increment(by: 5)","\/\/ 카운터 값은 이제 6","counter.reset()","\/\/ 카운터 값은 이제 0"],"type":"codeListing","syntax":"swift"},{"inlineContent":[{"text":"함수 매개변수는 함수 본문 내에서 사용할 이름과 함수를 호출할 때 사용할 인자 레이블을 모두 가질 수 있다. 이는 ","type":"text"},{"type":"text","text":"doc:Functions#Function-Argument-Labels-and-Parameter-Names"},{"type":"text","text":"에서 설명한 바와 같다. 메서드 매개변수도 마찬가지다. 메서드는 단순히 타입과 연관된 함수이기 때문이다."}],"type":"paragraph"},{"type":"heading","text":"self 프로퍼티","level":3,"anchor":"self-%ED%94%84%EB%A1%9C%ED%8D%BC%ED%8B%B0"},{"inlineContent":[{"text":"모든 타입의 인스턴스는 ","type":"text"},{"type":"codeVoice","code":"self"},{"text":"라는 암시적 프로퍼티를 가지고 있다. 이 ","type":"text"},{"type":"codeVoice","code":"self"},{"text":" 프로퍼티는 인스턴스 자체와 정확히 동일하다. 인스턴스 메서드 내에서 현재 인스턴스를 참조할 때 ","type":"text"},{"type":"codeVoice","code":"self"},{"text":" 프로퍼티를 사용한다.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"앞서 예제의 "},{"type":"codeVoice","code":"increment()"},{"type":"text","text":" 메서드는 다음과 같이 작성할 수도 있다:"}],"type":"paragraph"},{"code":["func increment() {","    self.count += 1","}"],"type":"codeListing","syntax":"swift"},{"type":"paragraph","inlineContent":[{"type":"text","text":"실제로는 코드에 "},{"code":"self","type":"codeVoice"},{"text":"를 자주 작성할 필요가 없다. ","type":"text"},{"type":"codeVoice","code":"self"},{"type":"text","text":"를 명시적으로 작성하지 않으면, Swift는 메서드 내에서 알려진 프로퍼티나 메서드 이름을 사용할 때 현재 인스턴스의 프로퍼티나 메서드를 참조한다고 가정한다. 이 가정은 "},{"type":"codeVoice","code":"Counter"},{"text":"의 세 인스턴스 메서드 내에서 ","type":"text"},{"type":"codeVoice","code":"self.count"},{"type":"text","text":" 대신 "},{"type":"codeVoice","code":"count"},{"text":"를 사용한 것에서 확인할 수 있다.","type":"text"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"이 규칙의 주요 예외는 인스턴스 메서드의 매개변수 이름이 해당 인스턴스의 프로퍼티 이름과 동일한 경우다. 이 경우 매개변수 이름이 우선순위를 가지며, 프로퍼티를 더 명확하게 참조해야 한다. 이때 "},{"code":"self","type":"codeVoice"},{"text":" 프로퍼티를 사용해 매개변수 이름과 프로퍼티 이름을 구분한다.","type":"text"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"여기서 "},{"type":"codeVoice","code":"self"},{"type":"text","text":"는 "},{"type":"codeVoice","code":"x"},{"type":"text","text":"라는 메서드 매개변수와 "},{"code":"x","type":"codeVoice"},{"type":"text","text":"라는 인스턴스 프로퍼티를 명확히 구분한다:"}]},{"syntax":"swift","type":"codeListing","code":["struct Point {","    var x = 0.0, y = 0.0","    func isToTheRightOf(x: Double) -> Bool {","        return self.x > x","    }","}","let somePoint = Point(x: 4.0, y: 5.0)","if somePoint.isToTheRightOf(x: 1.0) {","    print(\"This point is to the right of the line where x == 1.0\")","}","\/\/ Prints \"This point is to the right of the line where x == 1.0\""]},{"type":"paragraph","inlineContent":[{"code":"self","type":"codeVoice"},{"type":"text","text":" 접두사가 없으면 Swift는 "},{"type":"codeVoice","code":"x"},{"text":"의 두 사용 모두 메서드 매개변수 ","type":"text"},{"type":"codeVoice","code":"x"},{"type":"text","text":"를 참조한다고 가정한다."}]},{"level":3,"text":"인스턴스 메서드 내부에서 값 타입 수정하기","type":"heading","anchor":"%EC%9D%B8%EC%8A%A4%ED%84%B4%EC%8A%A4-%EB%A9%94%EC%84%9C%EB%93%9C-%EB%82%B4%EB%B6%80%EC%97%90%EC%84%9C-%EA%B0%92-%ED%83%80%EC%9E%85-%EC%88%98%EC%A0%95%ED%95%98%EA%B8%B0"},{"type":"paragraph","inlineContent":[{"type":"text","text":"구조체와 열거형은 "},{"type":"emphasis","inlineContent":[{"text":"값 타입","type":"text"}]},{"type":"text","text":"이다. 기본적으로 값 타입의 프로퍼티는 인스턴스 메서드 내부에서 수정할 수 없다."}]},{"inlineContent":[{"type":"text","text":"그러나 특정 메서드 내부에서 구조체나 열거형의 프로퍼티를 수정해야 한다면, 해당 메서드에 "},{"inlineContent":[{"type":"text","text":"mutating"}],"type":"emphasis"},{"text":" 동작을 허용할 수 있다. 이렇게 하면 메서드 내부에서 프로퍼티를 변경할 수 있으며, 메서드가 종료될 때 변경 사항이 원래 구조체에 반영된다. 또한 메서드는 암시적인 ","type":"text"},{"type":"codeVoice","code":"self"},{"type":"text","text":" 프로퍼티에 완전히 새로운 인스턴스를 할당할 수도 있으며, 이 새로운 인스턴스는 메서드가 종료될 때 기존 인스턴스를 대체한다."}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"이 동작을 허용하려면 해당 메서드의 "},{"type":"codeVoice","code":"func"},{"text":" 키워드 앞에 ","type":"text"},{"type":"codeVoice","code":"mutating"},{"type":"text","text":" 키워드를 추가하면 된다:"}],"type":"paragraph"},{"type":"codeListing","syntax":"swift","code":["struct Point {","    var x = 0.0, y = 0.0","    mutating func moveBy(x deltaX: Double, y deltaY: Double) {","        x += deltaX","        y += deltaY","    }","}","var somePoint = Point(x: 1.0, y: 1.0)","somePoint.moveBy(x: 2.0, y: 3.0)","print(\"The point is now at (\\(somePoint.x), \\(somePoint.y))\")","\/\/ Prints \"The point is now at (3.0, 4.0)\""]},{"inlineContent":[{"type":"text","text":"위의 "},{"type":"codeVoice","code":"Point"},{"text":" 구조체는 ","type":"text"},{"type":"codeVoice","code":"moveBy(x:y:)"},{"type":"text","text":"라는 mutating 메서드를 정의한다. 이 메서드는 "},{"type":"codeVoice","code":"Point"},{"type":"text","text":" 인스턴스를 특정 양만큼 이동시킨다. 이 메서드는 새로운 점을 반환하는 대신, 호출된 점을 직접 수정한다. 프로퍼티를 수정할 수 있도록 메서드 정의에 "},{"code":"mutating","type":"codeVoice"},{"text":" 키워드를 추가했다.","type":"text"}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"type":"text","text":"구조체 타입의 상수에서는 mutating 메서드를 호출할 수 없다는 점에 주의해야 한다. 이는 프로퍼티가 변수로 선언되었더라도 상수로 선언된 인스턴스의 프로퍼티는 변경할 수 없기 때문이다. 이 내용은 "},{"type":"text","text":"doc:Properties#Stored-Properties-of-Constant-Structure-Instances"},{"type":"text","text":"에서 자세히 설명한다:"}]},{"code":["let fixedPoint = Point(x: 3.0, y: 3.0)","fixedPoint.moveBy(x: 2.0, y: 3.0)","\/\/ this will report an error"],"type":"codeListing","syntax":"swift"},{"text":"뮤테이션 메서드 내에서 self에 할당하기","type":"heading","anchor":"%EB%AE%A4%ED%85%8C%EC%9D%B4%EC%85%98-%EB%A9%94%EC%84%9C%EB%93%9C-%EB%82%B4%EC%97%90%EC%84%9C-self%EC%97%90-%ED%95%A0%EB%8B%B9%ED%95%98%EA%B8%B0","level":3},{"type":"paragraph","inlineContent":[{"type":"text","text":"뮤테이션 메서드는 암시적 "},{"type":"codeVoice","code":"self"},{"text":" 프로퍼티에 완전히 새로운 인스턴스를 할당할 수 있다. 위에서 보여준 ","type":"text"},{"code":"Point","type":"codeVoice"},{"type":"text","text":" 예제를 다음과 같은 방식으로 작성할 수도 있다:"}]},{"code":["struct Point {","    var x = 0.0, y = 0.0","    mutating func moveBy(x deltaX: Double, y deltaY: Double) {","        self = Point(x: x + deltaX, y: y + deltaY)","    }","}"],"syntax":"swift","type":"codeListing"},{"type":"paragraph","inlineContent":[{"type":"text","text":"이 버전의 뮤테이션 "},{"code":"moveBy(x:y:)","type":"codeVoice"},{"text":" 메서드는 ","type":"text"},{"code":"x","type":"codeVoice"},{"text":"와 ","type":"text"},{"code":"y","type":"codeVoice"},{"type":"text","text":" 값이 목표 위치로 설정된 새로운 구조체를 생성한다. 이 메서드를 호출한 결과는 이전 버전을 호출한 것과 정확히 동일하다."}]},{"type":"paragraph","inlineContent":[{"text":"열거형의 뮤테이션 메서드는 암시적 ","type":"text"},{"code":"self","type":"codeVoice"},{"text":" 매개변수를 동일한 열거형의 다른 케이스로 설정할 수 있다:","type":"text"}]},{"syntax":"swift","code":["enum TriStateSwitch {","    case off, low, high","    mutating func next() {","        switch self {","        case .off:","            self = .low","        case .low:","            self = .high","        case .high:","            self = .off","        }","    }","}","var ovenLight = TriStateSwitch.low","ovenLight.next()","\/\/ ovenLight은 이제 .high와 같다","ovenLight.next()","\/\/ ovenLight은 이제 .off와 같다"],"type":"codeListing"},{"inlineContent":[{"type":"text","text":"이 예제는 세 가지 상태를 가진 스위치를 위한 열거형을 정의한다. 스위치는 "},{"type":"codeVoice","code":"next()"},{"type":"text","text":" 메서드가 호출될 때마다 세 가지 전원 상태("},{"code":"off","type":"codeVoice"},{"type":"text","text":", "},{"code":"low","type":"codeVoice"},{"text":", ","type":"text"},{"code":"high","type":"codeVoice"},{"type":"text","text":") 사이를 순환한다."}],"type":"paragraph"},{"text":"타입 메서드","level":2,"type":"heading","anchor":"%ED%83%80%EC%9E%85-%EB%A9%94%EC%84%9C%EB%93%9C"},{"type":"paragraph","inlineContent":[{"text":"앞서 설명한 인스턴스 메서드는 특정 타입의 인스턴스에서 호출하는 메서드이다. 반면, 타입 자체에서 호출하는 메서드도 정의할 수 있다. 이러한 메서드를 ","type":"text"},{"type":"emphasis","inlineContent":[{"text":"타입 메서드","type":"text"}]},{"text":"라고 한다. 타입 메서드는 메서드의 ","type":"text"},{"type":"codeVoice","code":"func"},{"type":"text","text":" 키워드 앞에 "},{"type":"codeVoice","code":"static"},{"text":" 키워드를 붙여 표시한다. 클래스의 경우 ","type":"text"},{"type":"codeVoice","code":"class"},{"text":" 키워드를 사용할 수 있으며, 이 경우 서브클래스가 슈퍼클래스의 메서드 구현을 재정의할 수 있다.","type":"text"}]},{"type":"aside","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Objective-C에서는 Objective-C 클래스에만 타입 레벨 메서드를 정의할 수 있다. 하지만 Swift에서는 모든 클래스, 구조체, 열거형에 타입 메서드를 정의할 수 있다. 각 타입 메서드는 해당 타입에 명시적으로 범위가 한정된다."}]}],"style":"note","name":"참고"},{"type":"paragraph","inlineContent":[{"text":"타입 메서드는 인스턴스 메서드와 마찬가지로 점 문법을 사용해 호출한다. 하지만 타입 메서드는 타입 자체에서 호출하며, 타입의 인스턴스에서 호출하지 않는다. 다음은 ","type":"text"},{"type":"codeVoice","code":"SomeClass"},{"type":"text","text":"라는 클래스의 타입 메서드를 호출하는 예시이다:"}]},{"syntax":"swift","type":"codeListing","code":["class SomeClass {","    class func someTypeMethod() {","        \/\/ 타입 메서드 구현","    }","}","SomeClass.someTypeMethod()"]},{"type":"paragraph","inlineContent":[{"text":"타입 메서드 내부에서 암시적 ","type":"text"},{"type":"codeVoice","code":"self"},{"type":"text","text":" 프로퍼티는 타입 자체를 참조하며, 타입의 인스턴스를 참조하지 않는다. 이는 타입 프로퍼티와 타입 메서드 매개변수 간의 모호함을 해결하기 위해 "},{"type":"codeVoice","code":"self"},{"type":"text","text":"를 사용할 수 있음을 의미한다. 이는 인스턴스 프로퍼티와 인스턴스 메서드 매개변수에서와 동일한 방식이다."}]},{"type":"paragraph","inlineContent":[{"text":"일반적으로 타입 메서드 내부에서 사용하는 모든 한정되지 않은 메서드와 프로퍼티 이름은 다른 타입 레벨 메서드와 프로퍼티를 참조한다. 타입 메서드는 다른 타입 메서드를 타입 이름 없이 메서드 이름만으로 호출할 수 있다. 마찬가지로 구조체와 열거형의 타입 메서드는 타입 프로퍼티를 타입 이름 없이 프로퍼티 이름만으로 접근할 수 있다.","type":"text"}]},{"type":"paragraph","inlineContent":[{"text":"다음 예제는 ","type":"text"},{"type":"codeVoice","code":"LevelTracker"},{"type":"text","text":"라는 구조체를 정의한다. 이 구조체는 게임의 다양한 레벨 또는 단계를 통해 플레이어의 진행 상황을 추적한다. 이 게임은 싱글 플레이어 게임이지만, 단일 기기에서 여러 플레이어의 정보를 저장할 수 있다."}]},{"inlineContent":[{"type":"text","text":"게임을 처음 시작할 때는 첫 번째 레벨을 제외한 모든 레벨이 잠겨 있다. 플레이어가 레벨을 완료할 때마다 해당 레벨은 기기의 모든 플레이어에 대해 잠금 해제된다. "},{"type":"codeVoice","code":"LevelTracker"},{"type":"text","text":" 구조체는 타입 프로퍼티와 메서드를 사용해 게임에서 잠금 해제된 레벨을 추적한다. 또한 개별 플레이어의 현재 레벨도 추적한다."}],"type":"paragraph"},{"type":"codeListing","syntax":"swift","code":["struct LevelTracker {","    static var highestUnlockedLevel = 1","    var currentLevel = 1","","    static func unlock(_ level: Int) {","        if level > highestUnlockedLevel { highestUnlockedLevel = level }","    }","","    static func isUnlocked(_ level: Int) -> Bool {","        return level <= highestUnlockedLevel","    }","","    @discardableResult","    mutating func advance(to level: Int) -> Bool {","        if LevelTracker.isUnlocked(level) {","            currentLevel = level","            return true","        } else {","            return false","        }","    }","}"]},{"inlineContent":[{"type":"codeVoice","code":"LevelTracker"},{"type":"text","text":" 구조체는 어떤 플레이어가 잠금 해제한 가장 높은 레벨을 추적한다. 이 값은 "},{"code":"highestUnlockedLevel","type":"codeVoice"},{"type":"text","text":"이라는 타입 프로퍼티에 저장된다."}],"type":"paragraph"},{"inlineContent":[{"type":"codeVoice","code":"LevelTracker"},{"type":"text","text":"는 "},{"type":"codeVoice","code":"highestUnlockedLevel"},{"text":" 프로퍼티를 다루기 위해 두 개의 타입 메서드를 정의한다. 첫 번째는 ","type":"text"},{"type":"codeVoice","code":"unlock(_:)"},{"text":"이라는 타입 메서드로, 새로운 레벨이 잠금 해제될 때마다 ","type":"text"},{"type":"codeVoice","code":"highestUnlockedLevel"},{"text":" 값을 업데이트한다. 두 번째는 ","type":"text"},{"type":"codeVoice","code":"isUnlocked(_:)"},{"text":"라는 편의 타입 메서드로, 특정 레벨 번호가 이미 잠금 해제되었는지 여부를 ","type":"text"},{"code":"true","type":"codeVoice"},{"type":"text","text":" 또는 "},{"type":"codeVoice","code":"false"},{"type":"text","text":"로 반환한다. (이 타입 메서드들은 "},{"type":"codeVoice","code":"LevelTracker.highestUnlockedLevel"},{"type":"text","text":"과 같이 타입 이름을 붙이지 않고도 "},{"type":"codeVoice","code":"highestUnlockedLevel"},{"type":"text","text":" 타입 프로퍼티에 접근할 수 있다.)"}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"type":"text","text":"타입 프로퍼티와 타입 메서드 외에도, "},{"type":"codeVoice","code":"LevelTracker"},{"text":"는 개별 플레이어의 게임 진행 상황을 추적한다. ","type":"text"},{"code":"currentLevel","type":"codeVoice"},{"text":"이라는 인스턴스 프로퍼티를 사용해 플레이어가 현재 진행 중인 레벨을 추적한다.","type":"text"}]},{"type":"paragraph","inlineContent":[{"code":"currentLevel","type":"codeVoice"},{"type":"text","text":" 프로퍼티를 관리하기 위해 "},{"code":"LevelTracker","type":"codeVoice"},{"text":"는 ","type":"text"},{"type":"codeVoice","code":"advance(to:)"},{"text":"라는 인스턴스 메서드를 정의한다. 이 메서드는 ","type":"text"},{"type":"codeVoice","code":"currentLevel"},{"text":"을 업데이트하기 전에 요청한 새 레벨이 이미 잠금 해제되었는지 확인한다. ","type":"text"},{"type":"codeVoice","code":"advance(to:)"},{"text":" 메서드는 ","type":"text"},{"code":"currentLevel","type":"codeVoice"},{"type":"text","text":"을 실제로 설정할 수 있었는지 여부를 나타내는 불리언 값을 반환한다. "},{"code":"advance(to:)","type":"codeVoice"},{"type":"text","text":" 메서드를 호출하는 코드가 반환 값을 무시해도 문제가 되지 않기 때문에, 이 함수는 "},{"code":"@discardableResult","type":"codeVoice"},{"type":"text","text":" 속성으로 표시된다. 이 속성에 대한 자세한 내용은 "},{"isActive":true,"type":"reference","identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Attributes"},{"type":"text","text":"를 참고한다."}]},{"type":"paragraph","inlineContent":[{"code":"LevelTracker","type":"codeVoice"},{"text":" 구조체는 아래에 표시된 ","type":"text"},{"type":"codeVoice","code":"Player"},{"type":"text","text":" 클래스와 함께 사용되어 개별 플레이어의 진행 상황을 추적하고 업데이트한다:"}]},{"type":"codeListing","syntax":"swift","code":["class Player {","    var tracker = LevelTracker()","    let playerName: String","    func complete(level: Int) {","        LevelTracker.unlock(level + 1)","        tracker.advance(to: level + 1)","    }","    init(name: String) {","        playerName = name","    }","}"]},{"inlineContent":[{"code":"Player","type":"codeVoice"},{"type":"text","text":" 클래스는 플레이어의 진행 상황을 추적하기 위해 "},{"type":"codeVoice","code":"LevelTracker"},{"type":"text","text":"의 새 인스턴스를 생성한다. 또한 "},{"type":"codeVoice","code":"complete(level:)"},{"type":"text","text":"이라는 메서드를 제공하며, 이 메서드는 플레이어가 특정 레벨을 완료할 때마다 호출된다. 이 메서드는 모든 플레이어를 위해 다음 레벨을 잠금 해제하고 플레이어의 진행 상황을 업데이트해 다음 레벨로 이동시킨다. ("},{"code":"advance(to:)","type":"codeVoice"},{"type":"text","text":"의 불리언 반환 값은 무시된다. 이전 줄에서 "},{"type":"codeVoice","code":"LevelTracker.unlock(_:)"},{"text":" 호출로 레벨이 잠금 해제되었음을 알 수 있기 때문이다.)","type":"text"}],"type":"paragraph"},{"inlineContent":[{"text":"새 플레이어를 위해 ","type":"text"},{"type":"codeVoice","code":"Player"},{"text":" 클래스의 인스턴스를 생성하고, 플레이어가 레벨 1을 완료할 때 어떤 일이 발생하는지 확인할 수 있다:","type":"text"}],"type":"paragraph"},{"syntax":"swift","type":"codeListing","code":["var player = Player(name: \"Argyrios\")","player.complete(level: 1)","print(\"highest unlocked level is now \\(LevelTracker.highestUnlockedLevel)\")","\/\/ \"highest unlocked level is now 2\" 출력"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"두 번째 플레이어를 생성하고, 아직 게임 내 어떤 플레이어도 잠금 해제하지 않은 레벨로 이동하려고 하면, 플레이어의 현재 레벨 설정 시도가 실패한다:"}]},{"type":"codeListing","code":["player = Player(name: \"Beto\")","if player.tracker.advance(to: 6) {","    print(\"player is now on level 6\")","} else {","    print(\"level 6 hasn't yet been unlocked\")","}","\/\/ \"level 6 hasn't yet been unlocked\" 출력"],"syntax":"swift"}],"kind":"content"}],"metadata":{"title":"메서드"},"hierarchy":{"paths":[["doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language"]]},"identifier":{"url":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Methods","interfaceLanguage":"swift"},"references":{"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/Attributes":{"url":"\/documentation\/the-swift-programming-language\/attributes","type":"topic","identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Attributes","abstract":[{"text":"선언과 타입에 추가 정보를 제공한다.","type":"text"}],"kind":"article","title":"속성","role":"article"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/Functions":{"url":"\/documentation\/the-swift-programming-language\/functions","type":"topic","identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Functions","kind":"article","abstract":[{"text":"특정 작업을 수행하는 독립적인 코드 블록인 함수를 정의하고 호출한다. 또한 함수의 인자에 레이블을 붙이고 반환 값을 사용하는 방법을 알아본다.","type":"text"}],"role":"article","title":"함수"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language":{"title":"The Swift Programming Language (6.1)","abstract":[],"kind":"article","role":"collection","type":"topic","url":"\/documentation\/the-swift-programming-language","identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language"}}}